# Scalars

scalar JSON

scalar Labels

scalar Timestamp

scalar Settings

scalar ApplicationMappingService

# Directives

directive @HasAccess(attributes: ResourceAttributes!) on FIELD_DEFINITION

input ResourceAttributes {
    verb: String!
    apiGroup: String
    apiVersion: String
    resource: String
    resourceArg: String
    subresource: String! = ""
    nameArg: String
    namespaceArg: String
    isChildResolver: Boolean! = false
}

# Rafter & Asset Store & CMS

type File {
    url: String!
    metadata: JSON!
}

type Asset {
    name: String!
    namespace: String!
    metadata: JSON! @deprecated(reason: "Use parameters")
    parameters: JSON!
    type: String!
    files(filterExtensions: [String!]): [File!]!
    status: AssetStatus!
}

type AssetEvent {
    type: SubscriptionEventType!
    asset: Asset!
}

type ClusterAsset {
    name: String!
    metadata: JSON! @deprecated(reason: "Use parameters")
    parameters: JSON!
    type: String!
    files(filterExtensions: [String!]): [File!]!
    status: AssetStatus!
}

type ClusterAssetEvent {
    type: SubscriptionEventType!
    clusterAsset: ClusterAsset!
}

type AssetStatus {
    phase: AssetPhaseType!
    reason: String!
    message: String!
}

enum AssetPhaseType {
    READY
    PENDING
    FAILED
}

type AssetGroup {
    name: String!
    namespace: String!
    groupName: String!
    assets(types: [String!]): [Asset!]!
    displayName: String!
    description: String!
    status: AssetGroupStatus!
}

type AssetGroupEvent {
    type: SubscriptionEventType!
    assetGroup: AssetGroup!
}

type ClusterAssetGroup {
    name: String!
    groupName: String!
    assets(types: [String!]): [ClusterAsset!]!
    displayName: String!
    description: String!
    status: AssetGroupStatus!
}

type ClusterAssetGroupEvent {
    type: SubscriptionEventType!
    clusterAssetGroup: ClusterAssetGroup!
}

type AssetGroupStatus {
    phase: AssetGroupPhaseType!
    reason: String!
    message: String!
}

enum AssetGroupPhaseType {
    READY
    PENDING
    FAILED
}

type DocsTopic {
    name: String!
    namespace: String!
    groupName: String!
    assets(types: [String!]): [Asset!]!
    displayName: String!
    description: String!
    status: DocsTopicStatus!
}

type DocsTopicEvent {
    type: SubscriptionEventType!
    docsTopic: DocsTopic!
}

type ClusterDocsTopic {
    name: String!
    groupName: String!
    assets(types: [String!]): [ClusterAsset!]!
    displayName: String!
    description: String!
    status: DocsTopicStatus!
}

type ClusterDocsTopicEvent {
    type: SubscriptionEventType!
    clusterDocsTopic: ClusterDocsTopic!
}

type DocsTopicStatus {
    phase: DocsTopicPhaseType!
    reason: String!
    message: String!
}

enum DocsTopicPhaseType {
    READY
    PENDING
    FAILED
}

# Service Catalog

type AddonsConfiguration {
    name: String!
    urls: [String!]
    repositories: [AddonsConfigurationRepository!]
    labels: Labels!
    status: AddonsConfigurationStatus!
}

type AddonsConfigurationRepository {
    url: String!
    secretRef: ResourceRef
}

type ResourceRef {
    name: String!
    namespace: String!
}

input AddonsConfigurationRepositoryInput {
    url: String!
    secretRef: ResourceRefInput
}

input ResourceRefInput {
    name: String!
    namespace: String!
}

type AddonsConfigurationStatus {
    phase: String!
    repositories: [AddonsConfigurationStatusRepository!]
}

type AddonsConfigurationStatusRepository {
    url: String!
    status: String!
    addons: [AddonsConfigurationStatusAddons!]
    reason: String!
    message: String!
}

type AddonsConfigurationStatusAddons {
    name: String!
    version: String!
    status: String!
    reason: String!
    message: String!
}

type AddonsConfigurationEvent {
    type: SubscriptionEventType!
    addonsConfiguration: AddonsConfiguration!
}

type ClusterAddonsConfigurationEvent {
    type: SubscriptionEventType!
    addonsConfiguration: AddonsConfiguration!
}

type ServiceInstance {
    name: String!
    namespace: String!
    planSpec: JSON
    creationTimestamp: Timestamp!
    labels: [String!]!
    status: ServiceInstanceStatus!
    classReference: ServiceInstanceResourceRef
    planReference: ServiceInstanceResourceRef
    serviceClass: ServiceClass
    clusterServiceClass: ClusterServiceClass
    servicePlan: ServicePlan
    clusterServicePlan: ClusterServicePlan
    bindable: Boolean!
    serviceBindings: ServiceBindings

    # Depends on servicecatalogaddons domain
    serviceBindingUsages: [ServiceBindingUsage!]
}

type ServiceInstanceResourceRef {
    name: String!
    displayName: String!
    clusterWide: Boolean!
}

type ServiceInstanceStatus {
    type: InstanceStatusType!
    reason: String!
    message: String!
}

enum InstanceStatusType {
    RUNNING
    PROVISIONING
    DEPROVISIONING
    PENDING
    FAILED
}

type ServiceInstanceEvent {
    type: SubscriptionEventType!
    serviceInstance: ServiceInstance!
}

type ServiceBrokerEvent {
    type: SubscriptionEventType!
    serviceBroker: ServiceBroker!
}

type ClusterServiceBrokerEvent {
    type: SubscriptionEventType!
    clusterServiceBroker: ClusterServiceBroker!
}

enum SubscriptionEventType {
    ADD
    UPDATE
    DELETE
}

input ServiceInstanceCreateInput {
    name: String!
    classRef: ServiceInstanceCreateInputResourceRef!
    planRef: ServiceInstanceCreateInputResourceRef!
    labels: [String!]!
    parameterSchema: JSON
}

input ServiceInstanceCreateInputResourceRef {
    externalName: String!
    clusterWide: Boolean!
}

type ServiceClass {
    name: String!
    namespace: String!
    externalName: String!
    displayName: String
    creationTimestamp: Timestamp!
    description: String!
    longDescription: String
    imageUrl: String
    documentationUrl: String
    supportUrl: String
    providerDisplayName: String
    tags: [String!]!
    labels: Labels!
    plans: [ServicePlan!]!
    activated: Boolean!
    instances: [ServiceInstance!]!

    # Depends on cms domain
    clusterDocsTopic: ClusterDocsTopic
    docsTopic: DocsTopic

    # Depends on rafter domain
    clusterAssetGroup: ClusterAssetGroup
    assetGroup: AssetGroup
}

type ClusterServiceClass {
    name: String!
    externalName: String!
    displayName: String
    creationTimestamp: Timestamp!
    description: String!
    longDescription: String
    imageUrl: String
    documentationUrl: String
    supportUrl: String
    providerDisplayName: String
    tags: [String!]!
    labels: Labels!
    plans: [ClusterServicePlan!]!
    activated(namespace: String): Boolean!
    instances(namespace: String): [ServiceInstance!]!

    # Depends on cms domain
    clusterDocsTopic: ClusterDocsTopic

    # Depends on rafter domain
    clusterAssetGroup: ClusterAssetGroup
}

type ServicePlan {
    name: String!
    namespace: String!
    displayName: String
    externalName: String!
    description: String!
    relatedServiceClassName: String!
    instanceCreateParameterSchema: JSON
    bindingCreateParameterSchema: JSON
}

type ClusterServicePlan {
    name: String!
    displayName: String
    externalName: String!
    description: String!
    relatedClusterServiceClassName: String!
    instanceCreateParameterSchema: JSON
    bindingCreateParameterSchema: JSON
}

type ServiceBroker {
    name: String!
    namespace: String!
    status: ServiceBrokerStatus!
    creationTimestamp: Timestamp!
    url: String!
    labels: Labels!
}

type ClusterServiceBroker {
    name: String!
    status: ServiceBrokerStatus!
    creationTimestamp: Timestamp!
    url: String!
    labels: Labels!
}

type ServiceBrokerStatus {
    ready: Boolean!
    reason: String!
    message: String!
}

type ServiceBindings {
    items: [ServiceBinding!]!
    stats: ServiceBindingsStats!
}

type ServiceBindingsStats {
    ready: Int!
    failed: Int!
    pending: Int!
    unknown: Int!
}

type ServiceBinding {
    name: String!
    serviceInstanceName: String!
    namespace: String!
    secret: Secret
    status: ServiceBindingStatus!
    parameters: JSON
}

type ServiceBindingStatus {
    type: ServiceBindingStatusType!
    reason: String!
    message: String!
}

enum ServiceBindingStatusType {
    READY
    PENDING
    FAILED
    UNKNOWN
}

type ServiceBindingEvent {
    type: SubscriptionEventType!
    serviceBinding: ServiceBinding!
}

# We cannot use ServiceBinding as a result of create action
# because secret at the moment of mutation execution is not available.
type CreateServiceBindingOutput {
    name: String!
    serviceInstanceName: String!
    namespace: String!
}

type Secret {
    name: String!
    namespace: String!
    data: JSON!
    type: String!
    creationTime: Timestamp!
    labels: JSON!
    annotations: JSON!
    json: JSON!
}

type DeleteServiceBindingOutput {
    name: String!
    namespace: String!
}

type DeleteServiceBindingUsageOutput {
    name: String!
    namespace: String!
}

type ServiceBindingUsage {
    name: String!
    namespace: String!
    serviceBinding: ServiceBinding
    usedBy: LocalObjectReference!
    parameters: ServiceBindingUsageParameters
    status: ServiceBindingUsageStatus!
}

type ServiceBindingUsageEvent {
    type: SubscriptionEventType!
    serviceBindingUsage: ServiceBindingUsage!
}

type ServiceBindingUsageStatus {
    type: ServiceBindingUsageStatusType!
    reason: String!
    message: String!
}

enum ServiceBindingUsageStatusType {
    READY
    PENDING
    FAILED
    UNKNOWN
}

type LocalObjectReference {
    kind: String!
    name: String!
}

type ServiceBindingUsageParameters {
    envPrefix: EnvPrefix
}

type EnvPrefix {
    name: String!
}

type LimitRange {
    name: String!
    limits: [LimitRangeItem!]!
}

type LimitRangeItem {
    limitType: LimitType!
    max: ResourceType!
    default: ResourceType!
    defaultRequest: ResourceType!
}

input LimitRangeInput {
    default: ResourceValuesInput!,
    defaultRequest: ResourceValuesInput!
    max: ResourceValuesInput!
    type: String!
}

enum LimitType {
    Container
    Pod
}

type ResourceType {
    memory: String
    cpu: String
}

input CreateServiceBindingUsageInput {
    name: String
    serviceBindingRef: ServiceBindingRefInput!
    usedBy: LocalObjectReferenceInput!
    parameters: ServiceBindingUsageParametersInput
}

input ServiceBindingRefInput {
    name: String!
}

input LocalObjectReferenceInput {
    kind: String!
    name: String!
}

input ServiceBindingUsageParametersInput {
    envPrefix: EnvPrefixInput
}

input EnvPrefixInput {
    name: String!
}

type Container {
    name: String!
    image: String!
}

type DeploymentStatus {
    replicas: Int!
    updatedReplicas: Int!
    readyReplicas: Int!
    availableReplicas: Int!
    conditions: [DeploymentCondition!]!
}

type DeploymentCondition {
    status: String!
    type: String!
    lastTransitionTimestamp: Timestamp!
    lastUpdateTimestamp: Timestamp!
    message: String!
    reason: String!
}

type Deployment {
    name: String!
    namespace: String!
    creationTimestamp: Timestamp!
    status: DeploymentStatus!
    labels: Labels!
    containers: [Container!]!

    # Depends on servicecatalog and servicecatalogaddons modules
    boundServiceInstanceNames: [String!]
}

enum ServiceProtocol {
    TCP
    UDP
    UNKNOWN
}

type ServicePort {
    name: String!
    serviceProtocol: ServiceProtocol!
    port: Int!
    nodePort: Int!
    targetPort: Int!
}

type LoadBalancerIngress {
    ip: String!
    hostName: String!
}

type LoadBalancerStatus {
    ingress: [LoadBalancerIngress!]!
}

type ServiceStatus {
    loadBalancer: LoadBalancerStatus!
}

type Service {
    name: String!
    clusterIP: String!
    creationTimestamp: Timestamp!
    labels: Labels!
    ports: [ServicePort!]!
    status: ServiceStatus!
    json: JSON!
}

type Pod {
    name: String!
    nodeName: String!
    namespace: String!
    restartCount: Int!
    creationTimestamp: Timestamp!
    labels: Labels!
    status: PodStatusType!
    containerStates: [ContainerState!]!
    json: JSON!
}

type ReplicaSet {
    name: String!
    pods: String!
    namespace: String!
    images: [String!]!
    creationTimestamp: Timestamp!
    labels: Labels!
    json: JSON!
}

enum PodStatusType {
    PENDING
    RUNNING
    SUCCEEDED
    FAILED
    UNKNOWN
}

type PodEvent {
    type: SubscriptionEventType!
    pod: Pod!
}

type ServiceEvent {
    type: SubscriptionEventType!
    service: Service!
}

type SecretEvent {
    type: SubscriptionEventType!
    secret: Secret!
}

type ApiEvent {
    type: SubscriptionEventType!
    api: API!
}

type ApiRuleEvent {
    type: SubscriptionEventType!
    apiRule: APIRule!
}

type ContainerState {
    state: ContainerStateType!
    reason: String!
    message: String!
}

enum ContainerStateType {
    WAITING
    RUNNING
    TERMINATED
}

type ResourceValues {
    memory: String
    cpu: String
}

type ResourceQuota {
    name: String!
    pods: String
    limits: ResourceValues!
    requests: ResourceValues!
}

input ResourceValuesInput {
    memory: String
    cpu: String
}

input ResourceQuotaInput {
    limits: ResourceValuesInput!
    requests: ResourceValuesInput!
}

type ResourceQuotasStatus {
    exceeded: Boolean!
    exceededQuotas: [ExceededQuota!]!
}

type ExceededQuota {
    quotaName: String!
    resourceName: String!
    affectedResources: [String!]!
}

# Applications

type Namespace {
    name: String!
    labels: Labels
    status: String!
    isSystemNamespace: Boolean!
    pods: [Pod!]!

    # Depends on application module
    applications: [String!]
}

type NamespaceEvent {
    type: SubscriptionEventType!
    namespace: Namespace!
}

type NamespaceMutationOutput {
    name: String!
    labels: Labels!
}

type Application {
    name: String!
    description: String!
    labels: Labels!
    services: [ApplicationService!]!
    enabledInNamespaces: [String!]!
    enabledMappingServices: [enabledMappingService]
    status: ApplicationStatus!
}

type enabledMappingService {
    namespace: String!
    allServices: Boolean!
    services: [EnabledApplicationService]
}

type EnabledApplicationService {
    id: String!
    displayName: String!
    exist: Boolean!
}

type ConnectorService {
    url: String!
}

type ApplicationMapping {
    namespace: String!
    application: String!
    allServices: Boolean
    services: [ApplicationMappingService]
}

type ApplicationService {
    id: String!
    displayName: String!
    longDescription: String!
    providerDisplayName: String!
    tags: [String!]!
    entries: [ApplicationEntry!]!
}

type ApplicationEntry {
    type: String!
    gatewayUrl: String
    accessLabel: String
}

enum ApplicationStatus {
    SERVING
    NOT_SERVING
    GATEWAY_NOT_CONFIGURED
}

type ApplicationEvent {
    type: SubscriptionEventType!
    application: Application!
}

type ApplicationMutationOutput {
    name: String!
    description: String!
    labels: Labels!
}

type DeleteApplicationOutput {
    name: String!
}

type EventActivationEvent {
    eventType: String!
    version: String!
    description: String!
    schema: JSON!
}

type EventActivation {
    name: String!
    displayName: String!
    sourceId: String!
    events: [EventActivationEvent!] # content module
}

type UsageKind {
    name: String!
    group: String!
    kind: String!
    version: String!
    displayName: String!
}

type UsageKindResource {
    name: String!
    namespace: String!
}

type BindableResourcesOutputItem {
    kind: String!
    displayName: String!
    resources: [UsageKindResource!]!
}

# IDP PRESETS

type IDPPreset {
    name: String!
    issuer: String!
    jwksUri: String!
}

# API controller

type ApiService {
    name: String!
    port: Int!
}

enum AuthenticationPolicyType {
    JWT
}

type AuthenticationPolicy  {
    type: AuthenticationPolicyType!
    issuer: String!
    jwksURI: String!
}

type API {
    name: String!
    hostname: String!
    service: ApiService!
    authenticationPolicies: [AuthenticationPolicy!]!
    creationTimestamp: Timestamp!
}

input APIInput {
    hostname: String!
    serviceName: String!
    servicePort: Int!
    jwksUri: String!
    issuer: String!
    disableIstioAuthPolicyMTLS: Boolean
    authenticationEnabled: Boolean
}

# API Gateway Controller

type APIRule {
    name: String!
    service: APIRuleService!
    gateway: String!
    rules: [Rule!]!
    status: APIRuleStatuses!
}

type APIRuleService{
    host: String!
    name: String!
    port: Int!
}

type Rule {
    path: String!
    methods: [String!]!
    accessStrategies: [APIRuleConfig!]!
    mutators: [APIRuleConfig!]
}

type APIRuleConfig {
    name: String!
    config: JSON!
}

type APIRuleStatuses {
    apiRuleStatus: APIRuleStatus
    accessRuleStatus: APIRuleStatus
    virtualServiceStatus: APIRuleStatus
}

type APIRuleStatus {
    code: String!
    desc: String
}

input APIRuleInput {
    host: String!
    serviceName: String!
    servicePort: Int!
    gateway: String!
    rules: [RuleInput!]!
}

input RuleInput {
    path: String!
    methods: [String!]!
    accessStrategies: [APIRuleConfigInput!]!
    mutators: [APIRuleConfigInput!]
}

input APIRuleConfigInput {
    name: String!
    config: JSON!
}

# Backend Module
type BackendModule {
    name: String!
}

# Config Maps

type ConfigMap {
    name: String!
    namespace: String!
    creationTimestamp: Timestamp!
    labels: Labels!
    json: JSON!
}

type ConfigMapEvent {
    type: SubscriptionEventType!
    configMap: ConfigMap!
}

# MF

type MicroFrontend {
    name: String!
    version: String!
    category: String!
    viewBaseUrl: String!
    navigationNodes: [NavigationNode!]!
}

type ClusterMicroFrontend {
    name: String!
    version: String!
    category: String!
    viewBaseUrl: String!
    placement: String!
    preloadUrl: String!
    navigationNodes: [NavigationNode!]!
}

type NavigationNode {
    label: String!
    navigationPath: String!
    viewUrl: String!
    showInNavigation: Boolean!
    order: Int!
    settings: Settings!
    externalLink: String
    requiredPermissions: [RequiredPermission!]!
}

type RequiredPermission {
    verbs: [String!]!
    apiGroup: String!
    resource: String!
}

# SelfSubjectRules

type ResourceRule {
    verbs: [String!]
    apiGroups: [String!]
    resources: [String!]
}

# Function

type Function {
    name: String!
	namespace: String!
	labels: Labels!
	runtime: String!
	size: String!
	status: FunctionStatusType!
    content: String!
    dependencies: String!
}

enum FunctionStatusType {
    Unknown
    Running
    Building
    Error
    Deploying
    Updating
}

type FunctionMutationOutput {
    name: String!
    namespace: String!
}

input FunctionUpdateInput {
    labels: Labels!
    size: String!
    runtime: String!
    content: String!
    dependencies: String!
}

# Queries

type Query {
    clusterDocsTopics(viewContext: String, groupName: String): [ClusterDocsTopic!]! @HasAccess(attributes: {resource: "clusterdocstopics", verb: "get", apiGroup: "cms.kyma-project.io", apiVersion: "v1alpha1"})

    clusterAssetGroups(viewContext: String, groupName: String): [ClusterAssetGroup!]! @HasAccess(attributes: {resource: "clusterassetgroups", verb: "get", apiGroup: "rafter.kyma-project.io", apiVersion: "v1beta1"})

    serviceInstance(name: String!, namespace: String!): ServiceInstance @HasAccess(attributes: {resource: "serviceinstances", verb: "get", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace", nameArg: "name"})
    serviceInstances(namespace: String!, first: Int, offset: Int, status: InstanceStatusType): [ServiceInstance!]! @HasAccess(attributes: {resource: "serviceinstances", verb: "list", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace"})

    clusterServiceClasses(first: Int, offset: Int): [ClusterServiceClass!]! @HasAccess(attributes: {resource: "clusterserviceclasses", verb: "list", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1"})
    clusterServiceClass(name: String!): ClusterServiceClass @HasAccess(attributes: {resource: "clusterserviceclasses", verb: "get", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", nameArg: "name"})
    serviceClasses(namespace: String!, first: Int, offset: Int): [ServiceClass!]! @HasAccess(attributes: {resource: "serviceclasses", verb: "list", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace"})
    serviceClass(namespace: String!, name: String!): ServiceClass @HasAccess(attributes: {resource: "serviceclasses", verb: "get", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace", nameArg: "name"})

    clusterServiceBrokers(first: Int, offset: Int): [ClusterServiceBroker!]! @HasAccess(attributes: {resource: "clusterservicebrokers", verb: "list", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1"})
    clusterServiceBroker(name: String!): ClusterServiceBroker @HasAccess(attributes: {resource: "clusterservicebrokers", verb: "get", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", nameArg: "name"})
    serviceBrokers(namespace: String!, first: Int, offset: Int): [ServiceBroker!]! @HasAccess(attributes: {resource: "servicebrokers", verb: "list", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace"})
    serviceBroker(name: String!, namespace: String!): ServiceBroker @HasAccess(attributes: {resource: "servicebrokers", verb: "get", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace", nameArg: "name"})

    serviceBindingUsage(name: String!, namespace: String!): ServiceBindingUsage @HasAccess(attributes: {resource: "servicebindingusages", verb: "get", apiGroup: "servicecatalog.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace", nameArg: "name"})
    serviceBinding(name: String!, namespace: String!): ServiceBinding @HasAccess(attributes: {resource: "servicebindings", verb: "get", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace", nameArg: "name"})
    usageKinds(first: Int, offset: Int): [UsageKind!]! @HasAccess(attributes: {resource: "usagekinds", verb: "list", apiGroup: "servicecatalog.kyma-project.io", apiVersion: "v1alpha1"})

    clusterAddonsConfigurations(first: Int, offset: Int): [AddonsConfiguration!]! @HasAccess(attributes: {resource: "clusteraddonsconfigurations", verb: "list", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1"})
    addonsConfigurations(namespace: String!, first: Int, offset: Int): [AddonsConfiguration!]! @HasAccess(attributes: {resource: "addonsconfigurations", verb: "list", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1"})

    # The query returns all instance of the resources which could be bound (proper UsageKind exists).
    bindableResources(namespace: String!): [BindableResourcesOutputItem!]! @HasAccess(attributes: {resource: "usagekinds", verb: "list", apiGroup: "servicecatalog.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace"})

    apis(namespace: String!, serviceName: String, hostname: String): [API!]! @HasAccess(attributes: {resource: "apis", verb: "list", apiGroup: "gateway.kyma-project.io", apiVersion: "v1alpha2", namespaceArg: "namespace"})
    api(name: String!, namespace: String!): API @HasAccess(attributes: {resource: "apis", verb: "get", apiGroup: "gateway.kyma-project.io", apiVersion: "v1alpha2", namespaceArg: "namespace", nameArg: "name"})

    APIRules(namespace: String!, serviceName: String, hostname: String): [APIRule!]! @HasAccess(attributes: {resource: "apirules", verb: "list", apiGroup: "gateway.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace"})
    APIRule(name: String!, namespace: String!): APIRule @HasAccess(attributes: {resource: "apirules", verb: "get", apiGroup: "gateway.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace", nameArg: "name"})

    application(name: String!): Application @HasAccess(attributes: {resource: "applications", verb: "get", apiGroup: "applicationconnector.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})
    applications(namespace: String, first: Int, offset: Int): [Application!]! @HasAccess(attributes: {resource: "applicationmappings", verb: "list", apiGroup: "applicationconnector.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace"}) @HasAccess(attributes: {resource: "applications", verb: "list", apiGroup: "applicationconnector.kyma-project.io", apiVersion: "v1alpha1"})
    connectorService(application: String!): ConnectorService! @HasAccess(attributes: {resource: "applications", verb: "create", apiGroup: "applicationconnector.kyma-project.io", apiVersion: "v1alpha1"})

    # Depends on 'application'
    namespaces(withSystemNamespaces: Boolean, withInactiveStatus: Boolean): [Namespace!]! @HasAccess(attributes: {resource: "namespaces", verb: "list", apiGroup: "", apiVersion: "v1"})
    namespace(name: String!): Namespace @HasAccess(attributes: {resource: "namespaces", verb: "get", apiGroup: "", apiVersion: "v1"})

    deployments(namespace: String!, excludeFunctions: Boolean): [Deployment!]! @HasAccess(attributes: {resource: "deployments", verb: "list", apiGroup: "apps", apiVersion: "v1beta2", namespaceArg: "namespace"})
    pod(name: String!, namespace: String!): Pod @HasAccess(attributes: {resource: "pods", verb: "get", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace", nameArg: "name"})
    pods(namespace: String!, first: Int, offset: Int): [Pod!]! @HasAccess(attributes: {resource: "pods", verb: "list", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})

    service(name: String!, namespace: String!): Service @HasAccess(attributes: {resource: "services", verb: "get", apiGroup: "", apiVersion: "v1"})
    services(namespace: String!, first: Int, offset: Int): [Service!]! @HasAccess(attributes: {resource: "services", verb: "list", apiGroup: "", apiVersion: "v1"})
    configMap(name: String!, namespace: String!): ConfigMap @HasAccess(attributes: {resource: "configmaps", verb: "get", apiGroup: "", apiVersion: "v1", nameArg: "name", namespaceArg: "namespace"})
    configMaps(namespace: String!, first: Int, offset: Int): [ConfigMap!]! @HasAccess(attributes: {resource: "configmaps", verb: "list", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})

    replicaSet(name: String!, namespace: String!): ReplicaSet @HasAccess(attributes: {resource: "replicasets", verb: "get", apiGroup: "apps", apiVersion: "v1", namespaceArg: "namespace", nameArg: "name"})
    replicaSets(namespace: String!, first: Int, offset: Int): [ReplicaSet!]! @HasAccess(attributes: {resource: "replicasets", verb: "list", apiGroup: "apps", apiVersion: "v1", namespaceArg: "namespace"})

    resourceQuotas(namespace: String!): [ResourceQuota!]! @HasAccess(attributes: {resource: "resourcequotas", verb: "list", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})
    resourceQuotasStatus(namespace: String!): ResourceQuotasStatus! @HasAccess(attributes: {resource: "resourcequotas", verb: "list", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})

    eventActivations(namespace: String!): [EventActivation!]! @HasAccess(attributes: {resource: "eventactivations", verb: "list", apiGroup: "applicationconnector.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace"})

    limitRanges(namespace: String!): [LimitRange!]! @HasAccess(attributes: {resource: "limitranges", verb: "list", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})

    backendModules: [BackendModule!]! @HasAccess(attributes: {resource: "backendmodules", verb: "list", apiGroup: "ui.kyma-project.io", apiVersion: "v1alpha1"})

    secret(name: String!, namespace: String!): Secret @HasAccess(attributes: {resource: "secrets", verb: "get", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})
    secrets(namespace: String!, first: Int, offset: Int): [Secret!]!  @HasAccess(attributes: {resource: "secrets", verb: "list", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})

    IDPPreset(name: String!): IDPPreset @HasAccess(attributes: {resource: "idppresets", verb: "get", apiGroup: "authentication.kyma-project.io", apiVersion: "v1alpha1"})
    IDPPresets(first: Int, offset: Int): [IDPPreset!]! @HasAccess(attributes: {resource: "idppresets", verb: "list", apiGroup: "authentication.kyma-project.io", apiVersion: "v1alpha1"})

    microFrontends(namespace: String!): [MicroFrontend!]! @HasAccess(attributes: {resource: "microfrontends", verb: "list", apiGroup: "ui.kyma-project.io", apiVersion: "v1alpha1"})
    clusterMicroFrontends: [ClusterMicroFrontend!]! @HasAccess(attributes: {resource: "clustermicrofrontends", verb: "list", apiGroup: "ui.kyma-project.io", apiVersion: "v1alpha1"})

    selfSubjectRules(namespace: String): [ResourceRule!]! @HasAccess(attributes: {apiGroup: "authorization.k8s.io", resource: "selfsubjectrulesreviews", verb: "create", apiVersion: "v1" namespaceArg: "namespace"})

    functions(namespace: String!): [Function!]! @HasAccess(attributes: {apiGroup: "serverless.kyma-project.io", resource: "functions", verb: "list", apiVersion: "v1alpha1" namespaceArg: "namespace"})
    function(name: String!, namespace: String!): Function @HasAccess(attributes: {apiGroup: "serverless.kyma-project.io", resource: "functions", verb: "get", apiVersion: "v1alpha1" nameArg:"name" namespaceArg: "namespace"})
}

# Mutations

type Mutation {
    createResource(namespace: String!, resource: JSON!): JSON @HasAccess(attributes: {verb: "create", resourceArg: "resource", namespaceArg: "namespace"})
    createServiceInstance(namespace: String!, params: ServiceInstanceCreateInput!): ServiceInstance @HasAccess(attributes: {resource: "serviceinstances", verb: "create", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace"})
    deleteServiceInstance(name: String!, namespace: String!): ServiceInstance @HasAccess(attributes: {resource: "serviceinstances", verb: "delete", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace", nameArg: "name"})
    createServiceBinding(serviceBindingName: String, serviceInstanceName: String!, namespace: String!, parameters: JSON): CreateServiceBindingOutput @HasAccess(attributes: {resource: "servicebindings", verb: "create", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace"})
    deleteServiceBinding(serviceBindingName: String!, namespace: String!): DeleteServiceBindingOutput @HasAccess(attributes: {resource: "servicebindings", verb: "delete", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace", nameArg: "serviceBindingName"})
    createServiceBindingUsage(namespace: String!, createServiceBindingUsageInput: CreateServiceBindingUsageInput): ServiceBindingUsage @HasAccess(attributes: {resource: "servicebindingusages", verb: "create", apiGroup: "servicecatalog.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace"})
    deleteServiceBindingUsage(serviceBindingUsageName: String!, namespace: String!): DeleteServiceBindingUsageOutput @HasAccess(attributes: {resource: "servicebindingusages", verb: "delete", apiGroup: "servicecatalog.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace", nameArg: "serviceBindingUsageName"})

    createClusterAddonsConfiguration(name: String!, repositories: [AddonsConfigurationRepositoryInput!], urls: [String!], labels: Labels): AddonsConfiguration @HasAccess(attributes: {resource: "clusteraddonsconfigurations", verb: "create", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})
    updateClusterAddonsConfiguration(name: String!, repositories: [AddonsConfigurationRepositoryInput!], urls: [String!], labels: Labels): AddonsConfiguration @HasAccess(attributes: {resource: "clusteraddonsconfigurations", verb: "update", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})
    deleteClusterAddonsConfiguration(name: String!): AddonsConfiguration @HasAccess(attributes: {resource: "clusteraddonsconfigurations", verb: "delete", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})
    addClusterAddonsConfigurationURLs(name: String!, urls: [String!]): AddonsConfiguration @HasAccess(attributes: {resource: "clusteraddonsconfigurations", verb: "update", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})
    removeClusterAddonsConfigurationURLs(name: String!, urls: [String!]): AddonsConfiguration @HasAccess(attributes: {resource: "clusteraddonsconfigurations", verb: "update", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})
    addClusterAddonsConfigurationRepository(name: String!, repositories: [AddonsConfigurationRepositoryInput!]): AddonsConfiguration @HasAccess(attributes: {resource: "clusteraddonsconfigurations", verb: "update", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})
    removeClusterAddonsConfigurationRepository(name: String!, urls: [String!]): AddonsConfiguration @HasAccess(attributes: {resource: "clusteraddonsconfigurations", verb: "update", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})
    resyncClusterAddonsConfiguration(name: String!): AddonsConfiguration @HasAccess(attributes: {resource: "clusteraddonsconfigurations", verb: "update", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})

    createAddonsConfiguration(name: String!, namespace: String!, repositories: [AddonsConfigurationRepositoryInput!], urls: [String!], labels: Labels): AddonsConfiguration @HasAccess(attributes: {resource: "addonsconfigurations", verb: "create", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})
    updateAddonsConfiguration(name: String!, namespace: String!, repositories: [AddonsConfigurationRepositoryInput!], urls: [String!], labels: Labels): AddonsConfiguration @HasAccess(attributes: {resource: "addonsconfigurations", verb: "update", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})
    deleteAddonsConfiguration(name: String!, namespace: String!): AddonsConfiguration @HasAccess(attributes: {resource: "addonsconfigurations", verb: "delete", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})
    addAddonsConfigurationURLs(name: String!, namespace: String!, urls: [String!]): AddonsConfiguration @HasAccess(attributes: {resource: "addonsconfigurations", verb: "update", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})
    removeAddonsConfigurationURLs(name: String!, namespace: String!, urls: [String!]): AddonsConfiguration @HasAccess(attributes: {resource: "addonsconfigurations", verb: "update", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})
    addAddonsConfigurationRepository(name: String!, namespace: String!, repositories: [AddonsConfigurationRepositoryInput!]): AddonsConfiguration @HasAccess(attributes: {resource: "addonsconfigurations", verb: "update", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})
    removeAddonsConfigurationRepository(name: String!, namespace: String!, urls: [String!]): AddonsConfiguration @HasAccess(attributes: {resource: "addonsconfigurations", verb: "update", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})
    resyncAddonsConfiguration(name: String!, namespace: String!): AddonsConfiguration @HasAccess(attributes: {resource: "addonsconfigurations", verb: "update", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})

    createApplication(name: String!, description: String, labels: Labels): ApplicationMutationOutput! @HasAccess(attributes: {resource: "applications", verb: "create", apiGroup: "applicationconnector.kyma-project.io", apiVersion: "v1alpha1"})
    updateApplication(name: String!, description: String, labels: Labels): ApplicationMutationOutput! @HasAccess(attributes: {resource: "applications", verb: "update", apiGroup: "applicationconnector.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})
    deleteApplication(name: String!): DeleteApplicationOutput! @HasAccess(attributes: {resource: "applications", verb: "delete", apiGroup: "applicationconnector.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})

    enableApplication(application: String!, namespace: String!, allServices: Boolean, services: [ApplicationMappingService]): ApplicationMapping @HasAccess(attributes: {resource: "applicationmappings", verb: "create", apiGroup: "applicationconnector.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace"})
    overloadApplication(application: String!, namespace: String!, allServices: Boolean, services: [ApplicationMappingService]): ApplicationMapping @HasAccess(attributes: {resource: "applicationmappings", verb: "update", apiGroup: "applicationconnector.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace"})
    disableApplication(application: String!, namespace: String!): ApplicationMapping @HasAccess(attributes: {resource: "applicationmappings", verb: "delete", apiGroup: "applicationconnector.kyma-project.io", apiVersion: "v1alpha1", nameArg: "application", namespaceArg: "namespace"})

    updatePod(name: String!, namespace: String!, pod: JSON!): Pod @HasAccess(attributes: {resource: "pods", verb: "update", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace", nameArg: "name"})
    deletePod(name: String!, namespace: String!): Pod @HasAccess(attributes: {resource: "pods", verb: "delete", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace", nameArg: "name"})

    updateSecret(name: String!, namespace: String!, secret: JSON!): Secret @HasAccess(attributes: {resource: "secrets", verb: "update", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})
    deleteSecret(name: String!, namespace: String!): Secret @HasAccess(attributes: {resource: "secrets", verb: "delete", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})

    updateReplicaSet(name: String!, namespace: String!, replicaSet: JSON!): ReplicaSet @HasAccess(attributes: {resource: "replicasets", verb: "update", apiGroup: "apps", apiVersion: "v1", namespaceArg: "namespace", nameArg: "name"})
    deleteReplicaSet(name: String!, namespace: String!): ReplicaSet @HasAccess(attributes: {resource: "replicasets", verb: "delete", apiGroup: "apps", apiVersion: "v1", namespaceArg: "namespace", nameArg: "name"})

    createResourceQuota(namespace: String!, name: String!, resourceQuota: ResourceQuotaInput!): ResourceQuota @HasAccess(attributes: {resource: "resourcequotas", verb: "create", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})

    updateConfigMap(name: String!, namespace: String!, configMap: JSON!): ConfigMap @HasAccess(attributes: {resource: "configmaps", verb: "update", apiGroup: "", apiVersion: "v1", nameArg: "name", namespaceArg: "namespace"})
    deleteConfigMap(name: String!, namespace: String!): ConfigMap @HasAccess(attributes: {resource: "configmaps", verb: "delete", apiGroup: "", apiVersion: "v1", nameArg: "name", namespaceArg: "namespace"})

    createIDPPreset(name: String!, issuer: String!, jwksUri: String!): IDPPreset @HasAccess(attributes: {resource: "idppresets", verb: "create", apiGroup: "authentication.kyma-project.io", apiVersion: "v1alpha1"})
    deleteIDPPreset(name: String!): IDPPreset @HasAccess(attributes: {resource: "idppresets", verb: "delete", apiGroup: "authentication.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})

    updateService(name: String!, namespace: String!, service: JSON!): Service @HasAccess(attributes: {resource: "services", verb: "update", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace", nameArg: "name"})
    deleteService(name: String!, namespace: String!): Service @HasAccess(attributes: {resource: "services", verb: "delete", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace", nameArg: "name"})

    createNamespace(name: String!, labels: Labels): NamespaceMutationOutput! @HasAccess(attributes: {resource: "namespaces", verb: "create", apiGroup: "", apiVersion: "v1"})
    updateNamespace(name: String!, labels: Labels!): NamespaceMutationOutput! @HasAccess(attributes: {resource: "namespaces", verb: "update", apiGroup: "", apiVersion: "v1"})
    deleteNamespace(name: String!): Namespace @HasAccess(attributes: {resource: "namespaces", verb: "delete", apiGroup: "", apiVersion: "v1"})

    createAPI(name: String!, namespace: String!, params: APIInput!): API! @HasAccess(attributes: {resource: "apis", verb: "create", apiGroup: "gateway.kyma-project.io", apiVersion: "v1alpha2", namespaceArg: "namespace", nameArg: "name"})
    updateAPI(name: String!, namespace: String!, params: APIInput!): API! @HasAccess(attributes: {resource: "apis", verb: "update", apiGroup: "gateway.kyma-project.io", apiVersion: "v1alpha2", namespaceArg: "namespace", nameArg: "name"})
    deleteAPI(name: String!, namespace: String!): API @HasAccess(attributes: {resource: "apis", verb: "delete", apiGroup: "gateway.kyma-project.io", apiVersion: "v1alpha2", namespaceArg: "namespace", nameArg: "name"})

    createAPIRule(name: String!, namespace: String!, params: APIRuleInput!): APIRule @HasAccess(attributes: {resource: "apirules", verb: "create", apiGroup: "gateway.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace", nameArg: "name"})
    updateAPIRule(name: String!, namespace: String!, params: APIRuleInput!): APIRule @HasAccess(attributes: {resource: "apirules", verb: "update", apiGroup: "gateway.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace", nameArg: "name"})
    deleteAPIRule(name: String!, namespace: String!): APIRule @HasAccess(attributes: {resource: "apirules", verb: "delete", apiGroup: "gateway.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace", nameArg: "name"})

    createLimitRange(namespace: String!, name: String!, limitRange: LimitRangeInput!): LimitRange @HasAccess(attributes: {resource: "limitrange", verb: "create", apiGroup: "", apiVersion: "v1"})

    deleteFunction(name: String!, namespace: String!): FunctionMutationOutput @HasAccess(attributes: {resource: "functions", verb: "delete", apiGroup: "serverless.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name",  namespaceArg: "namespace"})
    createFunction(name: String!, namespace: String!, labels: Labels!, size: String!, runtime: String!): Function @HasAccess(attributes: {resource: "functions", verb: "create", apiGroup: "serverless.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name",  namespaceArg: "namespace"})
    updateFunction(name: String!, namespace: String!, params: FunctionUpdateInput!): Function @HasAccess(attributes: {resource: "functions", verb: "create", apiGroup: "serverless.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name",  namespaceArg: "namespace"})
}

# Subscriptions

type Subscription {
    clusterAssetEvent: ClusterAssetEvent! @HasAccess(attributes: {resource: "clusterassets", verb: "watch", apiGroup: "assetstore.kyma-project.io", apiVersion: "v1alpha2"})
    assetEvent(namespace: String!): AssetEvent! @HasAccess(attributes: {resource: "assets", verb: "watch", apiGroup: "assetstore.kyma-project.io", apiVersion: "v1alpha2", namespaceArg: "namespace"})
    clusterDocsTopicEvent: ClusterDocsTopicEvent! @HasAccess(attributes: {resource: "clusterdocstopics", verb: "watch", apiGroup: "cms.kyma-project.io", apiVersion: "v1alpha1"})
    docsTopicEvent(namespace: String!): DocsTopicEvent! @HasAccess(attributes: {resource: "docstopics", verb: "watch", apiGroup: "cms.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace"})

    clusterAssetGroupEvent: ClusterAssetGroupEvent! @HasAccess(attributes: {resource: "clusterassetgroups", verb: "watch", apiGroup: "rafter.kyma-project.io", apiVersion: "v1beta1"})
    assetGroupEvent(namespace: String!): AssetGroupEvent! @HasAccess(attributes: {resource: "assetgroups", verb: "watch", apiGroup: "rafter.kyma-project.io", apiVersion: "v1beta1", namespaceArg: "namespace"})
    rafterClusterAssetEvent: ClusterAssetEvent! @HasAccess(attributes: {resource: "clusterassets", verb: "watch", apiGroup: "rafter.kyma-project.io", apiVersion: "v1beta1"})
    rafterAssetEvent(namespace: String!): AssetEvent! @HasAccess(attributes: {resource: "assets", verb: "watch", apiGroup: "rafter.kyma-project.io", apiVersion: "v1beta1", namespaceArg: "namespace"})

    serviceInstanceEvent(namespace: String!): ServiceInstanceEvent! @HasAccess(attributes: {resource: "serviceinstances", verb: "watch", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace"})
    serviceBindingEvent(namespace: String!): ServiceBindingEvent! @HasAccess(attributes: {resource: "servicebindings", verb: "watch", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace"})
    serviceBindingUsageEvent(namespace: String!): ServiceBindingUsageEvent! @HasAccess(attributes: {resource: "servicebindingusages", verb: "watch", apiGroup: "servicecatalog.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace"})
    serviceBrokerEvent(namespace: String!): ServiceBrokerEvent! @HasAccess(attributes: {resource: "servicebrokers", verb: "watch", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace"})
    clusterServiceBrokerEvent: ClusterServiceBrokerEvent! @HasAccess(attributes: {resource: "clusterservicebrokers", verb: "watch", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1"})

    applicationEvent: ApplicationEvent! @HasAccess(attributes: {resource: "applications", verb: "watch", apiGroup: "applicationconnector.kyma-project.io", apiVersion: "v1alpha1"})

    podEvent(namespace: String!): PodEvent! @HasAccess(attributes: {resource: "pods", verb: "watch", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})
    serviceEvent(namespace: String!): ServiceEvent! @HasAccess(attributes: {resource: "services", verb: "watch", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})
    configMapEvent(namespace: String!): ConfigMapEvent! @HasAccess(attributes: {resource: "configmaps", verb: "watch", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})

    clusterAddonsConfigurationEvent: ClusterAddonsConfigurationEvent! @HasAccess(attributes: {resource: "clusteraddonsconfigurations", verb: "watch", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1"})
    addonsConfigurationEvent(namespace: String!): AddonsConfigurationEvent! @HasAccess(attributes: {resource: "addonsconfigurations", verb: "watch", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1"})

    # secretEvent(namespace: String!): SecretEvent!  @HasAccess(attributes: {resource: "secrets", verb: "watch", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"}) # This subscription has to be disabled until https://github.com/kyma-project/kyma/issues/3412 gets resolved
    apiEvent(namespace: String!, serviceName: String): ApiEvent! @HasAccess(attributes: {resource: "apis", verb: "watch", apiGroup: "gateway.kyma-project.io", apiVersion: "v1alpha2", namespaceArg: "namespace"})
    apiRuleEvent(namespace: String!, serviceName: String): ApiRuleEvent! @HasAccess(attributes: {resource: "apirules", verb: "watch", apiGroup: "gateway.kyma-project.io", apiVersion: "v1alpha", namespaceArg: "namespace"})

    namespaceEvent(withSystemNamespaces: Boolean): NamespaceEvent! @HasAccess(attributes: {resource: "namespaces", verb: "watch", apiGroup: "", apiVersion: "v1"})
}

# Schema

schema {
    query: Query
    mutation: Mutation
}
