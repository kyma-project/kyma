# Scalars

scalar JSON

scalar Labels

scalar Timestamp

scalar Settings

scalar ApplicationMappingService

scalar Port @goModel(model: "github.com/kyma-project/kyma/components/console-backend-service/internal/gqlschema.Port")
scalar Extension @goModel(model: "github.com/kyma-project/kyma/components/console-backend-service/internal/gqlschema.RawExtension")
scalar UID @goModel(model: "github.com/kyma-project/kyma/components/console-backend-service/internal/gqlschema.UID")
scalar URI @goModel(model: "github.com/kyma-project/kyma/components/console-backend-service/internal/gqlschema.URI")

# Directives

directive @goModel(model: String, models: [String!]) on OBJECT
    | INPUT_OBJECT
    | SCALAR
    | ENUM
    | INTERFACE
    | UNION

directive @HasAccess(attributes: ResourceAttributes!) on FIELD_DEFINITION

input ResourceAttributes {
    verb: String!
    apiGroup: String
    apiVersion: String
    resource: String
    resourceArg: String
    subresource: String! = ""
    nameArg: String
    namespaceArg: String
    isChildResolver: Boolean! = false
}

# Rafter resources

type File {
    url: String!
    metadata: JSON!
}

type Asset {
    name: String!
    namespace: String!
    parameters: JSON!
    type: String!
    files(filterExtensions: [String!]): [File!]!
    status: AssetStatus!
    displayName: String
}

type AssetEvent {
    type: SubscriptionEventType!
    asset: Asset!
}

type ClusterAsset {
    name: String!
    parameters: JSON!
    type: String!
    files(filterExtensions: [String!]): [File!]!
    status: AssetStatus!
    displayName: String
}

type ClusterAssetEvent {
    type: SubscriptionEventType!
    clusterAsset: ClusterAsset!
}

type AssetStatus {
    phase: AssetPhaseType!
    reason: String!
    message: String!
}

enum AssetPhaseType {
    READY
    PENDING
    FAILED
}

type AssetGroup {
    name: String!
    namespace: String!
    groupName: String!
    assets(types: [String!]): [Asset!]!
    displayName: String!
    description: String!
    status: AssetGroupStatus!
}

type AssetGroupEvent {
    type: SubscriptionEventType!
    assetGroup: AssetGroup!
}

type ClusterAssetGroup {
    name: String!
    groupName: String!
    assets(types: [String!]): [ClusterAsset!]!
    displayName: String!
    description: String!
    status: AssetGroupStatus!
}

type ClusterAssetGroupEvent {
    type: SubscriptionEventType!
    clusterAssetGroup: ClusterAssetGroup!
}

type AssetGroupStatus {
    phase: AssetGroupPhaseType!
    reason: String!
    message: String!
}

enum AssetGroupPhaseType {
    READY
    PENDING
    FAILED
}

# Service Catalog

type AddonsConfiguration {
    name: String!
    urls: [String!]
    repositories: [AddonsConfigurationRepository!]
    labels: Labels!
    status: AddonsConfigurationStatus!
}

type AddonsConfigurationRepository {
    url: String!
    secretRef: ResourceRef
}

type ResourceRef {
    name: String!
    namespace: String!
}

input AddonsConfigurationRepositoryInput {
    url: String!
    secretRef: ResourceRefInput
}

input ResourceRefInput {
    name: String!
    namespace: String!
}

type AddonsConfigurationStatus {
    phase: String!
    repositories: [AddonsConfigurationStatusRepository!]
}

type AddonsConfigurationStatusRepository {
    url: String!
    status: String!
    addons: [AddonsConfigurationStatusAddons!]
    reason: String!
    message: String!
}

type AddonsConfigurationStatusAddons {
    name: String!
    version: String!
    status: String!
    reason: String!
    message: String!
}

type AddonsConfigurationEvent {
    type: SubscriptionEventType!
    addonsConfiguration: AddonsConfiguration!
}

type ClusterAddonsConfigurationEvent {
    type: SubscriptionEventType!
    addonsConfiguration: AddonsConfiguration!
}

type ServiceInstance {
    name: String!
    namespace: String!
    planSpec: JSON
    creationTimestamp: Timestamp!
    labels: [String!]!
    status: ServiceInstanceStatus!
    classReference: ServiceInstanceResourceRef
    planReference: ServiceInstanceResourceRef
    serviceClass: ServiceClass
    clusterServiceClass: ClusterServiceClass
    servicePlan: ServicePlan
    clusterServicePlan: ClusterServicePlan
    bindable: Boolean!
    serviceBindings: ServiceBindings

    # Depends on servicecatalogaddons domain
    serviceBindingUsages: [ServiceBindingUsage!]
}

type ServiceInstanceResourceRef {
    name: String!
    displayName: String!
    clusterWide: Boolean!
}

type ServiceInstanceStatus {
    type: InstanceStatusType!
    reason: String!
    message: String!
}

enum InstanceStatusType {
    RUNNING
    PROVISIONING
    DEPROVISIONING
    PENDING
    FAILED
}

type ServiceInstanceEvent {
    type: SubscriptionEventType!
    serviceInstance: ServiceInstance!
}

type ServiceBrokerEvent {
    type: SubscriptionEventType!
    serviceBroker: ServiceBroker!
}

type ClusterServiceBrokerEvent {
    type: SubscriptionEventType!
    clusterServiceBroker: ClusterServiceBroker!
}

enum SubscriptionEventType {
    ADD
    UPDATE
    DELETE
}

input ServiceInstanceCreateInput {
    name: String!
    classRef: ServiceInstanceCreateInputResourceRef!
    planRef: ServiceInstanceCreateInputResourceRef!
    labels: [String!]!
    parameterSchema: JSON
}

input ServiceInstanceCreateInputResourceRef {
    externalName: String!
    clusterWide: Boolean!
}

type ServiceClass {
    name: String!
    namespace: String!
    externalName: String!
    displayName: String
    creationTimestamp: Timestamp!
    description: String!
    longDescription: String
    imageUrl: String
    documentationUrl: String
    supportUrl: String
    providerDisplayName: String
    tags: [String!]!
    labels: Labels!
    plans: [ServicePlan!]!
    activated: Boolean!
    instances: [ServiceInstance!]!

    # Depends on rafter domain
    clusterAssetGroup: ClusterAssetGroup
    assetGroup: AssetGroup
}

type ClusterServiceClass {
    name: String!
    externalName: String!
    displayName: String
    creationTimestamp: Timestamp!
    description: String!
    longDescription: String
    imageUrl: String
    documentationUrl: String
    supportUrl: String
    providerDisplayName: String
    tags: [String!]!
    labels: Labels!
    plans: [ClusterServicePlan!]!
    activated(namespace: String): Boolean!
    instances(namespace: String): [ServiceInstance!]!

    # Depends on rafter domain
    clusterAssetGroup: ClusterAssetGroup
}

type ServicePlan {
  name: String!
  namespace: String!
  displayName: String
  externalName: String!
  description: String!
  relatedServiceClassName: String!
  instanceCreateParameterSchema: JSON
  bindingCreateParameterSchema: JSON

  # Depends on rafter domain
  clusterAssetGroup: ClusterAssetGroup
  assetGroup: AssetGroup
}

type ClusterServicePlan {
  name: String!
  displayName: String
  externalName: String!
  description: String!
  relatedClusterServiceClassName: String!
  instanceCreateParameterSchema: JSON
  bindingCreateParameterSchema: JSON

  # Depends on rafter domain
  clusterAssetGroup: ClusterAssetGroup
}

type ServiceBroker {
    name: String!
    namespace: String!
    status: ServiceBrokerStatus!
    creationTimestamp: Timestamp!
    url: String!
    labels: Labels!
}

type ClusterServiceBroker {
    name: String!
    status: ServiceBrokerStatus!
    creationTimestamp: Timestamp!
    url: String!
    labels: Labels!
}

type ServiceBrokerStatus {
    ready: Boolean!
    reason: String!
    message: String!
}

type ServiceBindings {
    items: [ServiceBinding!]!
    stats: ServiceBindingsStats!
}

type ServiceBindingsStats {
    ready: Int!
    failed: Int!
    pending: Int!
    unknown: Int!
}

type ServiceBinding {
    name: String!
    serviceInstanceName: String!
    namespace: String!
    secret: Secret
    status: ServiceBindingStatus!
    parameters: JSON
}

type ServiceBindingStatus {
    type: ServiceBindingStatusType!
    reason: String!
    message: String!
}

enum ServiceBindingStatusType {
    READY
    PENDING
    FAILED
    UNKNOWN
}

type ServiceBindingEvent {
    type: SubscriptionEventType!
    serviceBinding: ServiceBinding!
}

# We cannot use ServiceBinding as a result of create action
# because secret at the moment of mutation execution is not available.
type CreateServiceBindingOutput {
    name: String!
    serviceInstanceName: String!
    namespace: String!
}

type Secret {
    name: String!
    namespace: String!
    data: JSON!
    type: String!
    creationTime: Timestamp!
    labels: JSON!
    annotations: JSON!
    json: JSON!
}

type DeleteServiceBindingOutput {
    name: String!
    namespace: String!
}

type DeleteServiceBindingUsageOutput {
    name: String!
    namespace: String!
}

type ServiceBindingUsage {
    name: String!
    namespace: String!
    serviceBinding: ServiceBinding
    usedBy: LocalObjectReference!
    parameters: ServiceBindingUsageParameters
    status: ServiceBindingUsageStatus!
}

type ServiceBindingUsageEvent {
    type: SubscriptionEventType!
    serviceBindingUsage: ServiceBindingUsage!
}

type ServiceBindingUsageStatus {
    type: ServiceBindingUsageStatusType!
    reason: String!
    message: String!
}

enum ServiceBindingUsageStatusType {
    READY
    PENDING
    FAILED
    UNKNOWN
}

type LocalObjectReference {
    kind: String!
    name: String!
}

type ServiceBindingUsageParameters {
    envPrefix: EnvPrefix
}

type EnvPrefix {
    name: String!
}

type LimitRange {
    name: String!
    limits: [LimitRangeItem!]!
}

type LimitRangeItem {
    limitType: LimitType!
    max: ResourceType
    default: ResourceType
    defaultRequest: ResourceType
}

input LimitRangeInput {
    default: ResourceValuesInput!,
    defaultRequest: ResourceValuesInput!
    max: ResourceValuesInput!
    type: String!
}

enum LimitType {
    Container
    Pod
}

type ResourceType {
    memory: String
    cpu: String
}

input CreateServiceBindingUsageInput {
    name: String
    serviceBindingRef: ServiceBindingRefInput!
    usedBy: LocalObjectReferenceInput!
    parameters: ServiceBindingUsageParametersInput
}

input ServiceBindingRefInput {
    name: String!
}

input LocalObjectReferenceInput {
    kind: String!
    name: String!
}

input ServiceBindingUsageParametersInput {
    envPrefix: EnvPrefixInput
}

input EnvPrefixInput {
    name: String!
}

type Container {
    name: String!
    image: String!
}

type DeploymentStatus {
    replicas: Int!
    updatedReplicas: Int!
    readyReplicas: Int!
    availableReplicas: Int!
    conditions: [DeploymentCondition!]!
}

type DeploymentCondition {
    status: String!
    type: String!
    lastTransitionTimestamp: Timestamp!
    lastUpdateTimestamp: Timestamp!
    message: String!
    reason: String!
}

type Deployment {
    name: String!
    namespace: String!
    creationTimestamp: Timestamp!
    status: DeploymentStatus!
    labels: Labels!
    containers: [Container!]!

    # Depends on servicecatalog and servicecatalogaddons modules
    boundServiceInstanceNames: [String!]
}

type DeploymentEvent {
    type: SubscriptionEventType!
    deployment: Deployment!
}

enum ServiceProtocol {
    TCP
    UDP
    UNKNOWN
}

type ServicePort {
    name: String!
    serviceProtocol: ServiceProtocol!
    port: Int!
    nodePort: Int!
    targetPort: Int!
}

type LoadBalancerIngress {
    ip: String!
    hostName: String!
}

type LoadBalancerStatus {
    ingress: [LoadBalancerIngress!]!
}

type ServiceStatus {
    loadBalancer: LoadBalancerStatus!
}

type Service {
    name: String!
    clusterIP: String!
    creationTimestamp: Timestamp!
    labels: Labels!
    ports: [ServicePort!]!
    status: ServiceStatus!
    json: JSON!
    UID: String!
}

type Pod {
    name: String!
    nodeName: String!
    namespace: String!
    restartCount: Int!
    creationTimestamp: Timestamp!
    labels: Labels!
    status: PodStatusType!
    containerStates: [ContainerState!]!
    json: JSON!
}

type ReplicaSet {
    name: String!
    pods: String!
    namespace: String!
    images: [String!]!
    creationTimestamp: Timestamp!
    labels: Labels!
    json: JSON!
}

enum PodStatusType {
    PENDING
    RUNNING
    SUCCEEDED
    FAILED
    UNKNOWN
}

type PodEvent {
    type: SubscriptionEventType!
    pod: Pod!
}

type ServiceEvent {
    type: SubscriptionEventType!
    service: Service!
}

type SecretEvent {
    type: SubscriptionEventType!
    secret: Secret!
}

type ContainerState {
    state: ContainerStateType!
    reason: String!
    message: String!
}

enum ContainerStateType {
    WAITING
    RUNNING
    TERMINATED
}

type ResourceValues {
    memory: String
    cpu: String
}

type ResourceQuota {
    name: String!
    pods: String
    limits: ResourceValues!
    requests: ResourceValues!
}

input ResourceValuesInput {
    memory: String
    cpu: String
}

input ResourceQuotaInput {
    limits: ResourceValuesInput!
    requests: ResourceValuesInput!
}

type ResourceQuotasStatus {
    exceeded: Boolean!
    exceededQuotas: [ExceededQuota!]!
}

type ExceededQuota {
    quotaName: String!
    resourceName: String!
    affectedResources: [String!]!
}

# Applications

type Namespace {
    name: String!
    labels: Labels
    status: String!
    isSystemNamespace: Boolean!
    pods: [Pod!]!
    deployments(excludeFunctions: Boolean): [Deployment!]!

    # Depends on application module
    applications: [String!]
}

type NamespaceListItem {
    name: String!
    labels: Labels
    status: String!
    isSystemNamespace: Boolean!
    podsCount: Int!
    healthyPodsCount: Int!

    # Depends on application module
    applicationsCount: Int
}

type NamespaceEvent {
    type: SubscriptionEventType!
    namespace: NamespaceListItem!
}

type NamespaceMutationOutput {
    name: String!
    labels: Labels!
}

type Application {
    name: String!
    description: String!
    labels: Labels!
    services: [ApplicationService!]!
    enabledInNamespaces: [String!]!
    enabledMappingServices: [enabledMappingService]
    status: ApplicationStatus!
    compassMetadata: compassMetadata
}

type compassMetadata {
    applicationId: String!
}

type enabledMappingService {
    namespace: String!
    allServices: Boolean!
    services: [EnabledApplicationService]
}

type EnabledApplicationService {
    id: String!
    displayName: String!
    exist: Boolean!
}

type ConnectorService {
    url: String!
}

type ApplicationMapping {
    namespace: String!
    application: String!
    allServices: Boolean
    services: [ApplicationMappingService]
}

type ApplicationService {
    id: String!
    displayName: String!
    longDescription: String!
    providerDisplayName: String!
    tags: [String!]!
    entries: [ApplicationEntry!]!
}

type ApplicationEntry {
    type: String!
    gatewayUrl: String
    accessLabel: String
}

enum ApplicationStatus {
    SERVING
    NOT_SERVING
    GATEWAY_NOT_CONFIGURED
}

type ApplicationEvent {
    type: SubscriptionEventType!
    application: Application!
}

type ApplicationMutationOutput {
    name: String!
    description: String!
    labels: Labels!
}

type DeleteApplicationOutput {
    name: String!
}

type EventActivationEvent {
    eventType: String!
    version: String!
    description: String!
    schema: JSON!
}

type EventActivation {
    name: String!
    displayName: String!
    sourceId: String!
    events: [EventActivationEvent!] # content module
}

type UsageKind {
    name: String!
    group: String!
    kind: String!
    version: String!
    displayName: String!
}

type UsageKindResource {
    name: String!
    namespace: String!
}

type BindableResourcesOutputItem {
    kind: String!
    displayName: String!
    resources: [UsageKindResource!]!
}

# Backend Module
type BackendModule {
    name: String!
}

# Config Maps

type ConfigMap {
    name: String!
    namespace: String!
    creationTimestamp: Timestamp!
    labels: Labels!
    json: JSON!
}

type ConfigMapEvent {
    type: SubscriptionEventType!
    configMap: ConfigMap!
}

# MF

type MicroFrontend {
    name: String!
    version: String!
    category: String!
    viewBaseUrl: String!
    navigationNodes: [NavigationNode!]!
}

type ClusterMicroFrontend {
    name: String!
    version: String!
    category: String!
    viewBaseUrl: String!
    placement: String!
    preloadUrl: String!
    navigationNodes: [NavigationNode!]!
}

type NavigationNode {
    label: String!
    navigationPath: String!
    viewUrl: String!
    showInNavigation: Boolean!
    order: Int!
    settings: Settings!
    externalLink: String
    requiredPermissions: [RequiredPermission!]!
}

type RequiredPermission {
    verbs: [String!]!
    apiGroup: String!
    resource: String!
}

# SelfSubjectRules

type ResourceRule {
    verbs: [String!]
    apiGroups: [String!]
    resources: [String!]
}

# Function

type Function {
    # meta
    name: String!
	namespace: String!
	UID: String!
	labels: Labels!

    # spec
    source: String!
    dependencies: String!
    env: [FunctionEnv!]!
    replicas: FunctionReplicas!
    resources: FunctionResources!
    runtime: String
    sourceType: String

    # status
    status: FunctionStatus!
}

type FunctionEnv {
    name: String!
    value: String!
    valueFrom: FunctionEnvValueFrom
}

type FunctionEnvValueFrom {
    type: FunctionEnvValueFromType!
    name: String!
    key: String!
    optional: Boolean
}

input FunctionEnvInput {
    name: String!
    value: String!
    valueFrom: FunctionEnvValueFromInput
}

input FunctionEnvValueFromInput {
    type: FunctionEnvValueFromType!
    name: String!
    key: String!
    optional: Boolean
}

enum FunctionEnvValueFromType {
    ConfigMap
    Secret
}

type FunctionReplicas {
    min: Int
    max: Int
}

input FunctionReplicasInput {
    min: Int
    max: Int
}

type FunctionResources {
    limits: ResourceValues!
    requests: ResourceValues!
}

input FunctionResourcesInput {
    limits: ResourceValuesInput!
    requests: ResourceValuesInput!
}

type FunctionStatus {
    phase: FunctionPhaseType!
    reason: FunctionReasonType
    message: String
}

enum FunctionPhaseType {
    INITIALIZING
    BUILDING
    DEPLOYING
    RUNNING
    NEW_REVISION_ERROR
    FAILED
}

enum FunctionReasonType {
    CONFIG # ConfigMap
    JOB # K8S Job
    SERVICE #  Deployment + Service + hpa
}

input FunctionMutationInput {
    labels: Labels!
    source: String!
    dependencies: String!
    env: [FunctionEnvInput!]!
    replicas: FunctionReplicasInput!
    resources: FunctionResourcesInput!
    runtime: String
    sourceType: String
}

type FunctionMetadata {
    name: String!
    namespace: String!
}

input FunctionMetadataInput {
    name: String!
    namespace: String!
}

type FunctionEvent {
    type: SubscriptionEventType!
    function: Function!
}

# Misc

type VersionInfo {
    kymaVersion: String
}

# Queries

type Query {
    clusterAssetGroups(viewContext: String, groupName: String): [ClusterAssetGroup!]! @HasAccess(attributes: {resource: "clusterassetgroups", verb: "list", apiGroup: "rafter.kyma-project.io", apiVersion: "v1beta1"})

    serviceInstance(name: String!, namespace: String!): ServiceInstance @HasAccess(attributes: {resource: "serviceinstances", verb: "get", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace", nameArg: "name"})
    serviceInstances(namespace: String!, first: Int, offset: Int, status: InstanceStatusType): [ServiceInstance!]! @HasAccess(attributes: {resource: "serviceinstances", verb: "list", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace"})

    clusterServiceClasses(first: Int, offset: Int): [ClusterServiceClass!]! @HasAccess(attributes: {resource: "clusterserviceclasses", verb: "list", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1"})
    clusterServiceClass(name: String!): ClusterServiceClass @HasAccess(attributes: {resource: "clusterserviceclasses", verb: "get", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", nameArg: "name"})
    serviceClasses(namespace: String!, first: Int, offset: Int): [ServiceClass!]! @HasAccess(attributes: {resource: "serviceclasses", verb: "list", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace"})
    serviceClass(namespace: String!, name: String!): ServiceClass @HasAccess(attributes: {resource: "serviceclasses", verb: "get", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace", nameArg: "name"})

    clusterServiceBrokers(first: Int, offset: Int): [ClusterServiceBroker!]! @HasAccess(attributes: {resource: "clusterservicebrokers", verb: "list", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1"})
    clusterServiceBroker(name: String!): ClusterServiceBroker @HasAccess(attributes: {resource: "clusterservicebrokers", verb: "get", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", nameArg: "name"})
    serviceBrokers(namespace: String!, first: Int, offset: Int): [ServiceBroker!]! @HasAccess(attributes: {resource: "servicebrokers", verb: "list", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace"})
    serviceBroker(name: String!, namespace: String!): ServiceBroker @HasAccess(attributes: {resource: "servicebrokers", verb: "get", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace", nameArg: "name"})

    serviceBindingUsage(name: String!, namespace: String!): ServiceBindingUsage @HasAccess(attributes: {resource: "servicebindingusages", verb: "get", apiGroup: "servicecatalog.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace", nameArg: "name"})
    serviceBindingUsages(namespace: String!, resourceKind: String, resourceName: String): [ServiceBindingUsage!]! @HasAccess(attributes: {resource: "servicebindingusages", verb: "get", apiGroup: "servicecatalog.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace"})
    serviceBinding(name: String!, namespace: String!): ServiceBinding @HasAccess(attributes: {resource: "servicebindings", verb: "get", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace", nameArg: "name"})
    usageKinds(first: Int, offset: Int): [UsageKind!]! @HasAccess(attributes: {resource: "usagekinds", verb: "list", apiGroup: "servicecatalog.kyma-project.io", apiVersion: "v1alpha1"})

    clusterAddonsConfigurations(first: Int, offset: Int): [AddonsConfiguration!]! @HasAccess(attributes: {resource: "clusteraddonsconfigurations", verb: "list", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1"})
    addonsConfigurations(namespace: String!, first: Int, offset: Int): [AddonsConfiguration!]! @HasAccess(attributes: {resource: "addonsconfigurations", verb: "list", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1"})

    # The query returns all instance of the resources which could be bound (proper UsageKind exists).
    bindableResources(namespace: String!): [BindableResourcesOutputItem!]! @HasAccess(attributes: {resource: "usagekinds", verb: "list", apiGroup: "servicecatalog.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace"})

    application(name: String!): Application @HasAccess(attributes: {resource: "applications", verb: "get", apiGroup: "applicationconnector.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})
    applications(namespace: String, first: Int, offset: Int): [Application!]! @HasAccess(attributes: {resource: "applications", verb: "list", apiGroup: "applicationconnector.kyma-project.io", apiVersion: "v1alpha1"})
    connectorService(application: String!): ConnectorService! @HasAccess(attributes: {resource: "applications", verb: "create", apiGroup: "applicationconnector.kyma-project.io", apiVersion: "v1alpha1"})

    # Depends on 'application'
    namespaces(withSystemNamespaces: Boolean, withInactiveStatus: Boolean): [NamespaceListItem!]! @HasAccess(attributes: {resource: "namespaces", verb: "list", apiGroup: "", apiVersion: "v1"})
    namespace(name: String!): Namespace @HasAccess(attributes: {resource: "namespaces", verb: "get", apiGroup: "", apiVersion: "v1", namespaceArg: "name"})

    deployments(namespace: String!, excludeFunctions: Boolean): [Deployment!]! @HasAccess(attributes: {resource: "deployments", verb: "list", apiGroup: "apps", apiVersion: "v1beta2", namespaceArg: "namespace"})
    versionInfo: VersionInfo!

    pod(name: String!, namespace: String!): Pod @HasAccess(attributes: {resource: "pods", verb: "get", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace", nameArg: "name"})
    pods(namespace: String!, first: Int, offset: Int): [Pod!]! @HasAccess(attributes: {resource: "pods", verb: "list", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})

    service(name: String!, namespace: String!): Service @HasAccess(attributes: {resource: "services", verb: "get", apiGroup: "", apiVersion: "v1", nameArg: "name", namespaceArg: "namespace"})
    services(namespace: String!, excludedLabels: [String!], first: Int, offset: Int): [Service!]! @HasAccess(attributes: {resource: "services", verb: "list", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})
    configMap(name: String!, namespace: String!): ConfigMap @HasAccess(attributes: {resource: "configmaps", verb: "get", apiGroup: "", apiVersion: "v1", nameArg: "name", namespaceArg: "namespace"})
    configMaps(namespace: String!, first: Int, offset: Int): [ConfigMap!]! @HasAccess(attributes: {resource: "configmaps", verb: "list", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})

    replicaSet(name: String!, namespace: String!): ReplicaSet @HasAccess(attributes: {resource: "replicasets", verb: "get", apiGroup: "apps", apiVersion: "v1", namespaceArg: "namespace", nameArg: "name"})
    replicaSets(namespace: String!, first: Int, offset: Int): [ReplicaSet!]! @HasAccess(attributes: {resource: "replicasets", verb: "list", apiGroup: "apps", apiVersion: "v1", namespaceArg: "namespace"})

    resourceQuotas(namespace: String!): [ResourceQuota!]! @HasAccess(attributes: {resource: "resourcequotas", verb: "list", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})
    resourceQuotasStatus(namespace: String!): ResourceQuotasStatus! @HasAccess(attributes: {resource: "resourcequotas", verb: "list", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})

    eventActivations(namespace: String!): [EventActivation!]! @HasAccess(attributes: {resource: "eventactivations", verb: "list", apiGroup: "applicationconnector.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace"})

    limitRanges(namespace: String!): [LimitRange!]! @HasAccess(attributes: {resource: "limitranges", verb: "list", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})

    backendModules: [BackendModule!]! @HasAccess(attributes: {resource: "backendmodules", verb: "list", apiGroup: "ui.kyma-project.io", apiVersion: "v1alpha1"})

    secret(name: String!, namespace: String!): Secret @HasAccess(attributes: {resource: "secrets", verb: "get", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})
    secrets(namespace: String!, first: Int, offset: Int): [Secret!]!  @HasAccess(attributes: {resource: "secrets", verb: "list", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})

    microFrontends(namespace: String!): [MicroFrontend!]! @HasAccess(attributes: {resource: "microfrontends", verb: "list", apiGroup: "ui.kyma-project.io", apiVersion: "v1alpha1"})
    clusterMicroFrontends: [ClusterMicroFrontend!]! @HasAccess(attributes: {resource: "clustermicrofrontends", verb: "list", apiGroup: "ui.kyma-project.io", apiVersion: "v1alpha1"})

    selfSubjectRules(namespace: String): [ResourceRule!]! @HasAccess(attributes: {apiGroup: "authorization.k8s.io", resource: "selfsubjectrulesreviews", verb: "create", apiVersion: "v1" namespaceArg: "namespace"})

    function(name: String!, namespace: String!): Function @HasAccess(attributes: {apiGroup: "serverless.kyma-project.io", resource: "functions", verb: "get", apiVersion: "v1alpha1" nameArg:"name" namespaceArg: "namespace"})
    functions(namespace: String!): [Function!]! @HasAccess(attributes: {apiGroup: "serverless.kyma-project.io", resource: "functions", verb: "list", apiVersion: "v1alpha1" namespaceArg: "namespace"})
}

# Mutations

type Mutation {
    createResource(namespace: String!, resource: JSON!): JSON @HasAccess(attributes: {verb: "create", resourceArg: "resource", namespaceArg: "namespace"})
    createServiceInstance(namespace: String!, params: ServiceInstanceCreateInput!): ServiceInstance @HasAccess(attributes: {resource: "serviceinstances", verb: "create", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace"})
    deleteServiceInstance(name: String!, namespace: String!): ServiceInstance @HasAccess(attributes: {resource: "serviceinstances", verb: "delete", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace", nameArg: "name"})
    createServiceBinding(serviceBindingName: String, serviceInstanceName: String!, namespace: String!, parameters: JSON): CreateServiceBindingOutput @HasAccess(attributes: {resource: "servicebindings", verb: "create", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace"})
    deleteServiceBinding(serviceBindingName: String!, namespace: String!): DeleteServiceBindingOutput @HasAccess(attributes: {resource: "servicebindings", verb: "delete", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace", nameArg: "serviceBindingName"})
    createServiceBindingUsage(namespace: String!, createServiceBindingUsageInput: CreateServiceBindingUsageInput): ServiceBindingUsage @HasAccess(attributes: {resource: "servicebindingusages", verb: "create", apiGroup: "servicecatalog.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace"})
    deleteServiceBindingUsage(serviceBindingUsageName: String!, namespace: String!): DeleteServiceBindingUsageOutput @HasAccess(attributes: {resource: "servicebindingusages", verb: "delete", apiGroup: "servicecatalog.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace", nameArg: "serviceBindingUsageName"})
    deleteServiceBindingUsages(serviceBindingUsageNames: [String!]!, namespace: String!): [DeleteServiceBindingUsageOutput] @HasAccess(attributes: {resource: "servicebindingusages", verb: "delete", apiGroup: "servicecatalog.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace"})

    createClusterAddonsConfiguration(name: String!, repositories: [AddonsConfigurationRepositoryInput!], urls: [String!], labels: Labels): AddonsConfiguration @HasAccess(attributes: {resource: "clusteraddonsconfigurations", verb: "create", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})
    updateClusterAddonsConfiguration(name: String!, repositories: [AddonsConfigurationRepositoryInput!], urls: [String!], labels: Labels): AddonsConfiguration @HasAccess(attributes: {resource: "clusteraddonsconfigurations", verb: "update", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})
    deleteClusterAddonsConfiguration(name: String!): AddonsConfiguration @HasAccess(attributes: {resource: "clusteraddonsconfigurations", verb: "delete", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})
    addClusterAddonsConfigurationURLs(name: String!, urls: [String!]): AddonsConfiguration @HasAccess(attributes: {resource: "clusteraddonsconfigurations", verb: "update", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})
    removeClusterAddonsConfigurationURLs(name: String!, urls: [String!]): AddonsConfiguration @HasAccess(attributes: {resource: "clusteraddonsconfigurations", verb: "update", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})
    addClusterAddonsConfigurationRepository(name: String!, repositories: [AddonsConfigurationRepositoryInput!]): AddonsConfiguration @HasAccess(attributes: {resource: "clusteraddonsconfigurations", verb: "update", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})
    removeClusterAddonsConfigurationRepository(name: String!, urls: [String!]): AddonsConfiguration @HasAccess(attributes: {resource: "clusteraddonsconfigurations", verb: "update", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})
    resyncClusterAddonsConfiguration(name: String!): AddonsConfiguration @HasAccess(attributes: {resource: "clusteraddonsconfigurations", verb: "update", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})

    createAddonsConfiguration(name: String!, namespace: String!, repositories: [AddonsConfigurationRepositoryInput!], urls: [String!], labels: Labels): AddonsConfiguration @HasAccess(attributes: {resource: "addonsconfigurations", verb: "create", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})
    updateAddonsConfiguration(name: String!, namespace: String!, repositories: [AddonsConfigurationRepositoryInput!], urls: [String!], labels: Labels): AddonsConfiguration @HasAccess(attributes: {resource: "addonsconfigurations", verb: "update", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})
    deleteAddonsConfiguration(name: String!, namespace: String!): AddonsConfiguration @HasAccess(attributes: {resource: "addonsconfigurations", verb: "delete", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})
    addAddonsConfigurationURLs(name: String!, namespace: String!, urls: [String!]): AddonsConfiguration @HasAccess(attributes: {resource: "addonsconfigurations", verb: "update", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})
    removeAddonsConfigurationURLs(name: String!, namespace: String!, urls: [String!]): AddonsConfiguration @HasAccess(attributes: {resource: "addonsconfigurations", verb: "update", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})
    addAddonsConfigurationRepository(name: String!, namespace: String!, repositories: [AddonsConfigurationRepositoryInput!]): AddonsConfiguration @HasAccess(attributes: {resource: "addonsconfigurations", verb: "update", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})
    removeAddonsConfigurationRepository(name: String!, namespace: String!, urls: [String!]): AddonsConfiguration @HasAccess(attributes: {resource: "addonsconfigurations", verb: "update", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})
    resyncAddonsConfiguration(name: String!, namespace: String!): AddonsConfiguration @HasAccess(attributes: {resource: "addonsconfigurations", verb: "update", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})

    createApplication(name: String!, description: String, labels: Labels): ApplicationMutationOutput! @HasAccess(attributes: {resource: "applications", verb: "create", apiGroup: "applicationconnector.kyma-project.io", apiVersion: "v1alpha1"})
    updateApplication(name: String!, description: String, labels: Labels): ApplicationMutationOutput! @HasAccess(attributes: {resource: "applications", verb: "update", apiGroup: "applicationconnector.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})
    deleteApplication(name: String!): DeleteApplicationOutput! @HasAccess(attributes: {resource: "applications", verb: "delete", apiGroup: "applicationconnector.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})

    enableApplication(application: String!, namespace: String!, allServices: Boolean, services: [ApplicationMappingService]): ApplicationMapping @HasAccess(attributes: {resource: "applicationmappings", verb: "create", apiGroup: "applicationconnector.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace"})
    overloadApplication(application: String!, namespace: String!, allServices: Boolean, services: [ApplicationMappingService]): ApplicationMapping @HasAccess(attributes: {resource: "applicationmappings", verb: "update", apiGroup: "applicationconnector.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace"})
    disableApplication(application: String!, namespace: String!): ApplicationMapping @HasAccess(attributes: {resource: "applicationmappings", verb: "delete", apiGroup: "applicationconnector.kyma-project.io", apiVersion: "v1alpha1", nameArg: "application", namespaceArg: "namespace"})

    updatePod(name: String!, namespace: String!, pod: JSON!): Pod @HasAccess(attributes: {resource: "pods", verb: "update", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace", nameArg: "name"})
    deletePod(name: String!, namespace: String!): Pod @HasAccess(attributes: {resource: "pods", verb: "delete", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace", nameArg: "name"})

    updateSecret(name: String!, namespace: String!, secret: JSON!): Secret @HasAccess(attributes: {resource: "secrets", verb: "update", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})
    deleteSecret(name: String!, namespace: String!): Secret @HasAccess(attributes: {resource: "secrets", verb: "delete", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})

    updateReplicaSet(name: String!, namespace: String!, replicaSet: JSON!): ReplicaSet @HasAccess(attributes: {resource: "replicasets", verb: "update", apiGroup: "apps", apiVersion: "v1", namespaceArg: "namespace", nameArg: "name"})
    deleteReplicaSet(name: String!, namespace: String!): ReplicaSet @HasAccess(attributes: {resource: "replicasets", verb: "delete", apiGroup: "apps", apiVersion: "v1", namespaceArg: "namespace", nameArg: "name"})

    createResourceQuota(namespace: String!, name: String!, resourceQuota: ResourceQuotaInput!): ResourceQuota @HasAccess(attributes: {resource: "resourcequotas", verb: "create", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})

    updateConfigMap(name: String!, namespace: String!, configMap: JSON!): ConfigMap @HasAccess(attributes: {resource: "configmaps", verb: "update", apiGroup: "", apiVersion: "v1", nameArg: "name", namespaceArg: "namespace"})
    deleteConfigMap(name: String!, namespace: String!): ConfigMap @HasAccess(attributes: {resource: "configmaps", verb: "delete", apiGroup: "", apiVersion: "v1", nameArg: "name", namespaceArg: "namespace"})
    
    updateService(name: String!, namespace: String!, service: JSON!): Service @HasAccess(attributes: {resource: "services", verb: "update", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace", nameArg: "name"})
    deleteService(name: String!, namespace: String!): Service @HasAccess(attributes: {resource: "services", verb: "delete", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace", nameArg: "name"})

    createNamespace(name: String!, labels: Labels): NamespaceMutationOutput! @HasAccess(attributes: {resource: "namespaces", verb: "create", apiGroup: "", apiVersion: "v1"})
    updateNamespace(name: String!, labels: Labels): NamespaceMutationOutput! @HasAccess(attributes: {resource: "namespaces", verb: "update", apiGroup: "", apiVersion: "v1", namespaceArg: "name"})
    deleteNamespace(name: String!): Namespace @HasAccess(attributes: {resource: "namespaces", verb: "delete", apiGroup: "", apiVersion: "v1", namespaceArg: "name"})

    createLimitRange(namespace: String!, name: String!, limitRange: LimitRangeInput!): LimitRange @HasAccess(attributes: {resource: "limitrange", verb: "create", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})

    createFunction(name: String!, namespace: String!, params: FunctionMutationInput!): Function @HasAccess(attributes: {resource: "functions", verb: "create", apiGroup: "serverless.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name",  namespaceArg: "namespace"})
    updateFunction(name: String!, namespace: String!, params: FunctionMutationInput!): Function @HasAccess(attributes: {resource: "functions", verb: "create", apiGroup: "serverless.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name",  namespaceArg: "namespace"})
    deleteFunction(namespace: String!, function: FunctionMetadataInput!): FunctionMetadata @HasAccess(attributes: {resource: "functions", verb: "delete", apiGroup: "serverless.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace"})
    deleteManyFunctions(namespace: String!, functions: [FunctionMetadataInput!]!): [FunctionMetadata!] @HasAccess(attributes: {resource: "functions", verb: "delete", apiGroup: "serverless.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace"})
}

# Subscriptions

type Subscription {
    clusterAssetEvent: ClusterAssetEvent! @HasAccess(attributes: {resource: "clusterassets", verb: "watch", apiGroup: "rafter.kyma-project.io", apiVersion: "v1beta1"})
    assetEvent(namespace: String!): AssetEvent! @HasAccess(attributes: {resource: "assets", verb: "watch", apiGroup: "rafter.kyma-project.io", apiVersion: "v1beta1", namespaceArg: "namespace"})
    clusterAssetGroupEvent: ClusterAssetGroupEvent! @HasAccess(attributes: {resource: "clusterassetgroups", verb: "watch", apiGroup: "rafter.kyma-project.io", apiVersion: "v1beta1"})
    assetGroupEvent(namespace: String!): AssetGroupEvent! @HasAccess(attributes: {resource: "assetgroups", verb: "watch", apiGroup: "rafter.kyma-project.io", apiVersion: "v1beta1", namespaceArg: "namespace"})

    serviceInstanceEvent(namespace: String!): ServiceInstanceEvent! @HasAccess(attributes: {resource: "serviceinstances", verb: "watch", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace"})
    serviceBindingEvent(namespace: String!): ServiceBindingEvent! @HasAccess(attributes: {resource: "servicebindings", verb: "watch", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace"})
    serviceBindingUsageEvent(namespace: String!, resourceKind: String, resourceName: String): ServiceBindingUsageEvent! @HasAccess(attributes: {resource: "servicebindingusages", verb: "watch", apiGroup: "servicecatalog.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace"})
    serviceBrokerEvent(namespace: String!): ServiceBrokerEvent! @HasAccess(attributes: {resource: "servicebrokers", verb: "watch", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace"})
    clusterServiceBrokerEvent: ClusterServiceBrokerEvent! @HasAccess(attributes: {resource: "clusterservicebrokers", verb: "watch", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1"})

    applicationEvent: ApplicationEvent! @HasAccess(attributes: {resource: "applications", verb: "watch", apiGroup: "applicationconnector.kyma-project.io", apiVersion: "v1alpha1"})

    podEvent(namespace: String!): PodEvent! @HasAccess(attributes: {resource: "pods", verb: "watch", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})
    deploymentEvent(namespace: String!): DeploymentEvent! @HasAccess(attributes: {resource: "deployments", verb: "watch", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})
    serviceEvent(namespace: String!): ServiceEvent! @HasAccess(attributes: {resource: "services", verb: "watch", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})
    configMapEvent(namespace: String!): ConfigMapEvent! @HasAccess(attributes: {resource: "configmaps", verb: "watch", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})
    secretEvent(namespace: String!): SecretEvent! @HasAccess(attributes: {resource: "secrets", verb: "watch", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})

    clusterAddonsConfigurationEvent: ClusterAddonsConfigurationEvent! @HasAccess(attributes: {resource: "clusteraddonsconfigurations", verb: "watch", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1"})
    addonsConfigurationEvent(namespace: String!): AddonsConfigurationEvent! @HasAccess(attributes: {resource: "addonsconfigurations", verb: "watch", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1"})

    namespaceEvent(withSystemNamespaces: Boolean): NamespaceEvent! @HasAccess(attributes: {resource: "namespaces", verb: "watch", apiGroup: "", apiVersion: "v1"})

    functionEvent(namespace: String!, functionName: String): FunctionEvent! @HasAccess(attributes: {resource: "functions", verb: "watch", apiGroup: "serverless.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace"})
}

# Schema

schema {
    query: Query
    mutation: Mutation
}
