# Scalars

scalar JSON

scalar Labels

scalar Timestamp

# Directives

directive @HasAccess(attributes: ResourceAttributes!) on FIELD_DEFINITION

input ResourceAttributes {
    verb: String!
    apiGroup: String
    apiVersion: String
    resource: String
    resourceArg: String
    subresource: String! = ""
    nameArg: String
    namespaceArg: String
    isChildResolver: Boolean! = false
}

# Content


type Title {
    name: String!
    anchor: String!
    titles: [Title!]
}

type Section {
    name: String!
    anchor: String!
    titles: [Title!]!
    topicType: String!
}

type TopicEntry {
    contentType: String!
    id: String!
    sections: [Section!]!
}

# Service Catalog

type ServiceInstance {
    name: String!
    namespace: String!
    planSpec: JSON
    creationTimestamp: Timestamp!
    labels: [String!]!
    status: ServiceInstanceStatus!
    classReference: ServiceInstanceResourceRef
    planReference: ServiceInstanceResourceRef
    serviceClass: ServiceClass
    clusterServiceClass: ClusterServiceClass
    servicePlan: ServicePlan
    clusterServicePlan: ClusterServicePlan
    bindable: Boolean!
    serviceBindings: ServiceBindings

    # Depends on servicecatalogaddons domain
    serviceBindingUsages: [ServiceBindingUsage!]
}

type ServiceInstanceResourceRef {
    name: String!
    displayName: String!
    clusterWide: Boolean!
}

type ServiceInstanceStatus {
    type: InstanceStatusType!
    reason: String!
    message: String!
}

enum InstanceStatusType {
    RUNNING
    PROVISIONING
    DEPROVISIONING
    PENDING
    FAILED
}

type ServiceInstanceEvent {
    type: SubscriptionEventType!
    serviceInstance: ServiceInstance!
}

type ServiceBrokerEvent {
    type: SubscriptionEventType!
    serviceBroker: ServiceBroker!
}

type ClusterServiceBrokerEvent {
    type: SubscriptionEventType!
    clusterServiceBroker: ClusterServiceBroker!
}

enum SubscriptionEventType {
    ADD
    UPDATE
    DELETE
}

input ServiceInstanceCreateInput {
    name: String!
    classRef: ServiceInstanceCreateInputResourceRef!
    planRef: ServiceInstanceCreateInputResourceRef!
    labels: [String!]!
    parameterSchema: JSON
}

input ServiceInstanceCreateInputResourceRef {
    externalName: String!
    clusterWide: Boolean!
}

type ServiceClass {
    name: String!
    namespace: String!
    externalName: String!
    displayName: String
    creationTimestamp: Timestamp!
    description: String!
    longDescription: String
    imageUrl: String
    documentationUrl: String
    supportUrl: String
    providerDisplayName: String
    tags: [String!]!
    labels: Labels!
    plans: [ServicePlan!]!
    activated: Boolean!
    instances: [ServiceInstance!]!
    apiSpec: JSON @deprecated(reason: "No longer supported")
    openApiSpec: JSON
    odataSpec: String
    asyncApiSpec: JSON
    content: JSON
}

type ClusterServiceClass {
    name: String!
    externalName: String!
    displayName: String
    creationTimestamp: Timestamp!
    description: String!
    longDescription: String
    imageUrl: String
    documentationUrl: String
    supportUrl: String
    providerDisplayName: String
    tags: [String!]!
    labels: Labels!
    plans: [ClusterServicePlan!]!
    activated(namespace: String): Boolean!
    instances(namespace: String): [ServiceInstance!]!
    apiSpec: JSON @deprecated(reason: "No longer supported")
    openApiSpec: JSON
    odataSpec: String
    asyncApiSpec: JSON
    content: JSON
}

type ServicePlan {
    name: String!
    namespace: String!
    displayName: String
    externalName: String!
    description: String!
    relatedServiceClassName: String!
    instanceCreateParameterSchema: JSON
    bindingCreateParameterSchema: JSON
}

type ClusterServicePlan {
    name: String!
    displayName: String
    externalName: String!
    description: String!
    relatedClusterServiceClassName: String!
    instanceCreateParameterSchema: JSON
    bindingCreateParameterSchema: JSON
}

type ServiceBroker {
    name: String!
    namespace: String!
    status: ServiceBrokerStatus!
    creationTimestamp: Timestamp!
    url: String!
    labels: Labels!
}

type ClusterServiceBroker {
    name: String!
    status: ServiceBrokerStatus!
    creationTimestamp: Timestamp!
    url: String!
    labels: Labels!
}

type ServiceBrokerStatus {
    ready: Boolean!
    reason: String!
    message: String!
}

type ServiceBindings {
    items: [ServiceBinding!]!
    stats: ServiceBindingsStats!
}

type ServiceBindingsStats {
    ready: Int!
    failed: Int!
    pending: Int!
    unknown: Int!
}

type ServiceBinding {
    name: String!
    serviceInstanceName: String!
    namespace: String!
    secret: Secret
    status: ServiceBindingStatus!
    parameters: JSON
}

type ServiceBindingStatus {
    type: ServiceBindingStatusType!
    reason: String!
    message: String!
}

enum ServiceBindingStatusType {
    READY
    PENDING
    FAILED
    UNKNOWN
}

type ServiceBindingEvent {
    type: SubscriptionEventType!
    serviceBinding: ServiceBinding!
}

# We cannot use ServiceBinding as a result of create action
# because secret at the moment of mutation execution is not available.
type CreateServiceBindingOutput {
    name: String!
    serviceInstanceName: String!
    namespace: String!
}

type Secret {
    name: String!
    namespace: String!
    data: JSON!
    type: String!
    creationTime: Timestamp!
    labels: JSON!
    annotations: JSON!
    json: JSON!
}

type DeleteServiceBindingOutput {
    name: String!
    namespace: String!
}

type DeleteServiceBindingUsageOutput {
    name: String!
    namespace: String!
}

type ServiceBindingUsage {
    name: String!
    namespace: String!
    serviceBinding: ServiceBinding
    usedBy: LocalObjectReference!
    parameters: ServiceBindingUsageParameters
    status: ServiceBindingUsageStatus!
}

type ServiceBindingUsageEvent {
    type: SubscriptionEventType!
    serviceBindingUsage: ServiceBindingUsage!
}

type ServiceBindingUsageStatus {
    type: ServiceBindingUsageStatusType!
    reason: String!
    message: String!
}

enum ServiceBindingUsageStatusType {
    READY
    PENDING
    FAILED
    UNKNOWN
}

type LocalObjectReference {
    kind: String!
    name: String!
}

type ServiceBindingUsageParameters {
    envPrefix: EnvPrefix
}

type EnvPrefix {
    name: String!
}

type LimitRange {
    name: String!
    limits: [LimitRangeItem!]!
}

type LimitRangeItem {
    limitType: LimitType!
    max: ResourceType!
    default: ResourceType!
    defaultRequest: ResourceType!
}

enum LimitType {
    Container
    Pod
}

type ResourceType {
    memory: String
    cpu: String
}

input CreateServiceBindingUsageInput {
    name: String
    serviceBindingRef: ServiceBindingRefInput!
    usedBy: LocalObjectReferenceInput!
    parameters: ServiceBindingUsageParametersInput
}

input ServiceBindingRefInput {
    name: String!
}

input LocalObjectReferenceInput {
    kind: String!
    name: String!
}

input ServiceBindingUsageParametersInput {
    envPrefix: EnvPrefixInput
}

input EnvPrefixInput {
    name: String!
}

type Container {
    name: String!
    image: String!
}

type DeploymentStatus {
    replicas: Int!
    updatedReplicas: Int!
    readyReplicas: Int!
    availableReplicas: Int!
    conditions: [DeploymentCondition!]!
}

type DeploymentCondition {
    status: String!
    type: String!
    lastTransitionTimestamp: Timestamp!
    lastUpdateTimestamp: Timestamp!
    message: String!
    reason: String!
}

type Deployment {
    name: String!
    namespace: String!
    creationTimestamp: Timestamp!
    status: DeploymentStatus!
    labels: Labels!
    containers: [Container!]!

    # Depends on servicecatalog and servicecatalogaddons modules
    boundServiceInstanceNames: [String!]
}

enum ServiceProtocol {
    TCP
    UDP
    UNKNOWN
}

type ServicePort {
    name: String!
    serviceProtocol: ServiceProtocol!
    port: Int!
    nodePort: Int!
    targetPort: Int!
}

type LoadBalancerIngress {
    ip: String!
    hostName: String!
}

type LoadBalancerStatus {
    ingress: [LoadBalancerIngress!]!
}

type ServiceStatus {
    loadBalancer: LoadBalancerStatus!
}

type Service {
    name: String!
    clusterIP: String!
    creationTimestamp: Timestamp!
    labels: Labels!
    ports: [ServicePort!]!
    status: ServiceStatus!
    json: JSON!
}

type Pod {
    name: String!
    nodeName: String!
    namespace: String!
    restartCount: Int!
    creationTimestamp: Timestamp!
    labels: Labels!
    status: PodStatusType!
    containerStates: [ContainerState!]!
    json: JSON!
}

type ReplicaSet {
    name: String!
    pods: String!
    namespace: String!
    images: [String!]!
    creationTimestamp: Timestamp!
    labels: Labels!
    json: JSON!
}

enum PodStatusType {
    PENDING
    RUNNING
    SUCCEEDED
    FAILED
    UNKNOWN
}

type PodEvent {
    type: SubscriptionEventType!
    pod: Pod!
}

type ServiceEvent {
    type: SubscriptionEventType!
    service: Service!
}

type SecretEvent {
    type: SubscriptionEventType!
    secret: Secret!
}

type ContainerState {
    state: ContainerStateType!
    reason: String!
    message: String!
}

enum ContainerStateType {
    WAITING
    RUNNING
    TERMINATED
}

type ResourceValues {
    memory: String
    cpu: String
}

type ResourceQuota {
    name: String!
    pods: String
    limits: ResourceValues!
    requests: ResourceValues!
}

type ResourceQuotasStatus {
    exceeded: Boolean!
    exceededQuotas: [ExceededQuota!]!
}

type ExceededQuota {
    quotaName: String!
    resourceName: String!
    affectedResources: [String!]!
}

# Applications

type Namespace {
    name: String!

    # Depends on application module
    applications: [String!]
}

type Application {
    name: String!
    description: String!
    labels: Labels!
    services: [ApplicationService!]!
    enabledInNamespaces: [String!]!
    status: ApplicationStatus!
}

type ConnectorService {
    url: String!
}

type ApplicationMapping {
    namespace: String!
    application: String!
}

type ApplicationService {
    id: String!
    displayName: String!
    longDescription: String!
    providerDisplayName: String!
    tags: [String!]!
    entries: [ApplicationEntry!]!
}

type ApplicationEntry {
    type: String!
    gatewayUrl: String
    accessLabel: String
}

enum ApplicationStatus {
    SERVING
    NOT_SERVING
    GATEWAY_NOT_CONFIGURED
}

type ApplicationEvent {
    type: SubscriptionEventType!
    application: Application!
}

type ApplicationMutationOutput {
    name: String!
    description: String!
    labels: Labels!
}

type DeleteApplicationOutput {
    name: String!
}

type EventActivationEvent {
    eventType: String!
    version: String!
    description: String!
}

type EventActivation {
    name: String!
    displayName: String!
    sourceId: String!
    events: [EventActivationEvent!] # content module
}

type UsageKind {
    name: String!
    group: String!
    kind: String!
    version: String!
    displayName: String!
}

type UsageKindResource {
    name: String!
    namespace: String!
}

type BindableResourcesOutputItem {
    kind: String!
    displayName: String!
    resources: [UsageKindResource!]!
}

# IDP PRESETS

type IDPPreset {
    name: String!
    issuer: String!
    jwksUri: String!
}

# Kubeless

type Function {
    name: String!
    trigger: String!
    creationTimestamp: Timestamp!
    labels: Labels!
    namespace: String!
}

input InputTopic {
    id: String!
    type: String!
}

# API controller

type ApiService {
    name: String!
    port: Int!
}

enum AuthenticationPolicyType {
    JWT
}

type AuthenticationPolicy  {
    type: AuthenticationPolicyType!
    issuer: String!
    jwksURI: String!
}

type API {
    name: String!
    hostname: String!
    service: ApiService!
    authenticationPolicies: [AuthenticationPolicy!]!
}

# Backend Module
type BackendModule {
    name: String!
}

# Config Maps

type ConfigMap {
    name: String!
    namespace: String!
    creationTimestamp: Timestamp!
    labels: Labels!
    json: JSON!
}

type ConfigMapEvent {
    type: SubscriptionEventType!
    configMap: ConfigMap!
}

# Queries

type Query {
    serviceInstance(name: String!, namespace: String!): ServiceInstance @HasAccess(attributes: {resource: "serviceinstances", verb: "get", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace", nameArg: "name"})
    serviceInstances(namespace: String!, first: Int, offset: Int, status: InstanceStatusType): [ServiceInstance!]! @HasAccess(attributes: {resource: "serviceinstances", verb: "list", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace"})

    clusterServiceClasses(first: Int, offset: Int): [ClusterServiceClass!]! @HasAccess(attributes: {resource: "clusterserviceclasses", verb: "list", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1"})
    clusterServiceClass(name: String!): ClusterServiceClass @HasAccess(attributes: {resource: "clusterserviceclasses", verb: "get", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", nameArg: "name"})
    serviceClasses(namespace: String!, first: Int, offset: Int): [ServiceClass!]! @HasAccess(attributes: {resource: "serviceclasses", verb: "list", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace"})
    serviceClass(namespace: String!, name: String!): ServiceClass @HasAccess(attributes: {resource: "serviceclasses", verb: "get", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace", nameArg: "name"})

    clusterServiceBrokers(first: Int, offset: Int): [ClusterServiceBroker!]! @HasAccess(attributes: {resource: "clusterservicebrokers", verb: "list", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1"})
    clusterServiceBroker(name: String!): ClusterServiceBroker @HasAccess(attributes: {resource: "clusterservicebrokers", verb: "get", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", nameArg: "name"})
    serviceBrokers(namespace: String!, first: Int, offset: Int): [ServiceBroker!]! @HasAccess(attributes: {resource: "servicebrokers", verb: "list", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace"})
    serviceBroker(name: String!, namespace: String!): ServiceBroker @HasAccess(attributes: {resource: "servicebrokers", verb: "get", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace", nameArg: "name"})

    serviceBindingUsage(name: String!, namespace: String!): ServiceBindingUsage @HasAccess(attributes: {resource: "servicebindingusages", verb: "get", apiGroup: "servicecatalog.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace", nameArg: "name"})
    serviceBinding(name: String!, namespace: String!): ServiceBinding @HasAccess(attributes: {resource: "servicebindings", verb: "get", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace", nameArg: "name"})
    usageKinds(first: Int, offset: Int): [UsageKind!]! @HasAccess(attributes: {resource: "usagekinds", verb: "list", apiGroup: "servicecatalog.kyma-project.io", apiVersion: "v1alpha1"})

    # The query returns all instance of the resources which could be bound (proper UsageKind exists).
    bindableResources(namespace: String!): [BindableResourcesOutputItem!]! @HasAccess(attributes: {resource: "usagekinds", verb: "list", apiGroup: "servicecatalog.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace"})

    apis(namespace: String!, serviceName: String, hostname: String): [API!]! @HasAccess(attributes: {resource: "apis", verb: "list", apiGroup: "gateway.kyma-project.io", apiVersion: "v1alpha2", namespaceArg: "namespace"})

    application(name: String!): Application @HasAccess(attributes: {resource: "applications", verb: "get", apiGroup: "applicationconnector.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})
    applications(namespace: String, first: Int, offset: Int): [Application!]! @HasAccess(attributes: {resource: "applicationmappings", verb: "list", apiGroup: "applicationconnector.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace"}) @HasAccess(attributes: {resource: "applications", verb: "list", apiGroup: "applicationconnector.kyma-project.io", apiVersion: "v1alpha1"})
    connectorService(application: String!): ConnectorService! @HasAccess(attributes: {resource: "applications", verb: "create", apiGroup: "applicationconnector.kyma-project.io", apiVersion: "v1alpha1"})

    # Depends on 'application'
    namespaces(application: String): [Namespace!]! @HasAccess(attributes: {resource: "namespaces", verb: "list", apiGroup: "", apiVersion: "v1"})

    deployments(namespace: String!, excludeFunctions: Boolean): [Deployment!]! @HasAccess(attributes: {resource: "deployments", verb: "list", apiGroup: "apps", apiVersion: "v1beta2", namespaceArg: "namespace"})
    pod(name: String!, namespace: String!): Pod @HasAccess(attributes: {resource: "pods", verb: "get", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace", nameArg: "name"})
    pods(namespace: String!, first: Int, offset: Int): [Pod!]! @HasAccess(attributes: {resource: "pods", verb: "list", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})

    service(name: String!, namespace: String!): Service @HasAccess(attributes: {resource: "services", verb: "get", apiGroup: "", apiVersion: "v1"})
    services(namespace: String!, first: Int, offset: Int): [Service!]! @HasAccess(attributes: {resource: "services", verb: "list", apiGroup: "", apiVersion: "v1"})
    configMap(name: String!, namespace: String!): ConfigMap @HasAccess(attributes: {resource: "configmaps", verb: "get", apiGroup: "", apiVersion: "v1", nameArg: "name", namespaceArg: "namespace"})
    configMaps(namespace: String!, first: Int, offset: Int): [ConfigMap!]! @HasAccess(attributes: {resource: "configmaps", verb: "list", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})

    replicaSet(name: String!, namespace: String!): ReplicaSet @HasAccess(attributes: {resource: "replicasets", verb: "get", apiGroup: "apps", apiVersion: "v1", namespaceArg: "namespace", nameArg: "name"})
    replicaSets(namespace: String!, first: Int, offset: Int): [ReplicaSet!]! @HasAccess(attributes: {resource: "replicasets", verb: "list", apiGroup: "apps", apiVersion: "v1", namespaceArg: "namespace"})

    resourceQuotas(namespace: String!): [ResourceQuota!]! @HasAccess(attributes: {resource: "resourcequotas", verb: "list", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})
    resourceQuotasStatus(namespace: String!): ResourceQuotasStatus! @HasAccess(attributes: {resource: "resourcequotas", verb: "list", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})

    functions(namespace: String!, first: Int, offset: Int): [Function!]! @HasAccess(attributes: {resource: "functions", verb: "list", apiGroup: "kubeless.io", apiVersion: "v1beta1", namespaceArg: "namespace"})

    content(contentType: String!, id: String!): JSON # TODO: TO BE REMOVED
    topics(input: [InputTopic!]!, internal: Boolean): [TopicEntry!] # TODO: TO BE REMOVED
    eventActivations(namespace: String!): [EventActivation!]! @HasAccess(attributes: {resource: "eventactivations", verb: "list", apiGroup: "applicationconnector.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace"})

    limitRanges(namespace: String!): [LimitRange!]! @HasAccess(attributes: {resource: "limitranges", verb: "list", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})

    backendModules: [BackendModule!]! @HasAccess(attributes: {resource: "backendmodules", verb: "list", apiGroup: "ui.kyma-project.io", apiVersion: "v1alpha1"})

    secret(name: String!, namespace: String!): Secret @HasAccess(attributes: {resource: "secrets", verb: "get", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})
    secrets(namespace: String!, first: Int, offset: Int): [Secret!]!  @HasAccess(attributes: {resource: "secrets", verb: "list", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})

    IDPPreset(name: String!): IDPPreset @HasAccess(attributes: {resource: "idppresets", verb: "get", apiGroup: "authentication.kyma-project.io", apiVersion: "v1alpha1"})
    IDPPresets(first: Int, offset: Int): [IDPPreset!]! @HasAccess(attributes: {resource: "idppresets", verb: "list", apiGroup: "authentication.kyma-project.io", apiVersion: "v1alpha1"})
}

# Mutations

type Mutation {
    createResource(namespace: String!, resource: JSON!): JSON @HasAccess(attributes: {verb: "create", resourceArg: "resource", namespaceArg: "namespace"})
    createServiceInstance(namespace: String!, params: ServiceInstanceCreateInput!): ServiceInstance @HasAccess(attributes: {resource: "serviceinstances", verb: "create", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace"})
    deleteServiceInstance(name: String!, namespace: String!): ServiceInstance @HasAccess(attributes: {resource: "serviceinstances", verb: "delete", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace", nameArg: "name"})
    createServiceBinding(serviceBindingName: String, serviceInstanceName: String!, namespace: String!, parameters: JSON): CreateServiceBindingOutput @HasAccess(attributes: {resource: "servicebindings", verb: "create", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace"})
    deleteServiceBinding(serviceBindingName: String!, namespace: String!): DeleteServiceBindingOutput @HasAccess(attributes: {resource: "servicebindings", verb: "delete", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace", nameArg: "serviceBindingName"})
    createServiceBindingUsage(namespace: String!, createServiceBindingUsageInput: CreateServiceBindingUsageInput): ServiceBindingUsage @HasAccess(attributes: {resource: "servicebindingusages", verb: "create", apiGroup: "servicecatalog.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace"})
    deleteServiceBindingUsage(serviceBindingUsageName: String!, namespace: String!): DeleteServiceBindingUsageOutput @HasAccess(attributes: {resource: "servicebindingusages", verb: "delete", apiGroup: "servicecatalog.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace", nameArg: "serviceBindingUsageName"})

    createApplication(name: String!, description: String, labels: Labels): ApplicationMutationOutput! @HasAccess(attributes: {resource: "applications", verb: "create", apiGroup: "applicationconnector.kyma-project.io", apiVersion: "v1alpha1"})
    updateApplication(name: String!, description: String, labels: Labels): ApplicationMutationOutput! @HasAccess(attributes: {resource: "applications", verb: "update", apiGroup: "applicationconnector.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})
    deleteApplication(name: String!): DeleteApplicationOutput! @HasAccess(attributes: {resource: "applications", verb: "delete", apiGroup: "applicationconnector.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})

    enableApplication(application: String!, namespace: String!): ApplicationMapping @HasAccess(attributes: {resource: "applicationmappings", verb: "create", apiGroup: "applicationconnector.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace"})
    disableApplication(application: String!, namespace: String!): ApplicationMapping @HasAccess(attributes: {resource: "applicationmappings", verb: "delete", apiGroup: "applicationconnector.kyma-project.io", apiVersion: "v1alpha1", nameArg: "application", namespaceArg: "namespace"})

    updatePod(name: String!, namespace: String!, pod: JSON!): Pod @HasAccess(attributes: {resource: "pods", verb: "update", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace", nameArg: "name"})
    deletePod(name: String!, namespace: String!): Pod @HasAccess(attributes: {resource: "pods", verb: "delete", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace", nameArg: "name"})

    updateSecret(name: String!, namespace: String!, secret: JSON!): Secret @HasAccess(attributes: {resource: "secrets", verb: "update", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})
    deleteSecret(name: String!, namespace: String!): Secret @HasAccess(attributes: {resource: "secrets", verb: "delete", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})

    updateReplicaSet(name: String!, namespace: String!, replicaSet: JSON!): ReplicaSet @HasAccess(attributes: {resource: "replicasets", verb: "update", apiGroup: "apps", apiVersion: "v1", namespaceArg: "namespace", nameArg: "name"})
    deleteReplicaSet(name: String!, namespace: String!): ReplicaSet @HasAccess(attributes: {resource: "replicasets", verb: "delete", apiGroup: "apps", apiVersion: "v1", namespaceArg: "namespace", nameArg: "name"})

    updateConfigMap(name: String!, namespace: String!, configMap: JSON!): ConfigMap @HasAccess(attributes: {resource: "configmaps", verb: "update", apiGroup: "", apiVersion: "v1", nameArg: "name", namespaceArg: "namespace"})
    deleteConfigMap(name: String!, namespace: String!): ConfigMap @HasAccess(attributes: {resource: "configmaps", verb: "delete", apiGroup: "", apiVersion: "v1", nameArg: "name", namespaceArg: "namespace"})

    createIDPPreset(name: String!, issuer: String!, jwksUri: String!): IDPPreset @HasAccess(attributes: {resource: "idppresets", verb: "create", apiGroup: "authentication.kyma-project.io", apiVersion: "v1alpha1"})
    deleteIDPPreset(name: String!): IDPPreset @HasAccess(attributes: {resource: "idppresets", verb: "delete", apiGroup: "authentication.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})

    updateService(name: String!, namespace: String!, service: JSON!): Service @HasAccess(attributes: {resource: "services", verb: "update", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace", nameArg: "name"})
    deleteService(name: String!, namespace: String!): Service @HasAccess(attributes: {resource: "services", verb: "delete", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace", nameArg: "name"})
}

# Subscriptions

type Subscription {
    serviceInstanceEvent(namespace: String!): ServiceInstanceEvent! @HasAccess(attributes: {resource: "serviceinstances", verb: "watch", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace"})
    serviceBindingEvent(namespace: String!): ServiceBindingEvent! @HasAccess(attributes: {resource: "servicebindings", verb: "watch", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace"})
    serviceBindingUsageEvent(namespace: String!): ServiceBindingUsageEvent! @HasAccess(attributes: {resource: "servicebindingusages", verb: "watch", apiGroup: "servicecatalog.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace"})
    serviceBrokerEvent(namespace: String!): ServiceBrokerEvent! @HasAccess(attributes: {resource: "servicebrokers", verb: "watch", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace"})
    clusterServiceBrokerEvent: ClusterServiceBrokerEvent! @HasAccess(attributes: {resource: "clusterservicebrokers", verb: "watch", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1"})
    applicationEvent: ApplicationEvent! @HasAccess(attributes: {resource: "applications", verb: "watch", apiGroup: "applicationconnector.kyma-project.io", apiVersion: "v1alpha1"})
    podEvent(namespace: String!): PodEvent! @HasAccess(attributes: {resource: "pods", verb: "watch", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})
    serviceEvent(namespace: String!): ServiceEvent! @HasAccess(attributes: {resource: "services", verb: "watch", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})
    configMapEvent(namespace: String!): ConfigMapEvent! @HasAccess(attributes: {resource: "configmaps", verb: "watch", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})
    # secretEvent(namespace: String!): SecretEvent!  @HasAccess(attributes: {resource: "secrets", verb: "watch", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"}) # This subscription has to be disabled until https://github.com/kyma-project/kyma/issues/3412 gets resolved
}

# Schema

schema {
    query: Query
    mutation: Mutation
}
