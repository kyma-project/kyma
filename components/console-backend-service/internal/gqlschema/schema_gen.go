// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gqlschema

import (
	"bytes"
	"context"
	"errors"
	"strconv"
	"sync"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/vektah/gqlparser"
	"github.com/vektah/gqlparser/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Application() ApplicationResolver
	Asset() AssetResolver
	ClusterAsset() ClusterAssetResolver
	ClusterDocsTopic() ClusterDocsTopicResolver
	ClusterServiceClass() ClusterServiceClassResolver
	Deployment() DeploymentResolver
	DocsTopic() DocsTopicResolver
	EventActivation() EventActivationResolver
	Mutation() MutationResolver
	Namespace() NamespaceResolver
	Query() QueryResolver
	ServiceBinding() ServiceBindingResolver
	ServiceBindingUsage() ServiceBindingUsageResolver
	ServiceClass() ServiceClassResolver
	ServiceInstance() ServiceInstanceResolver
	Subscription() SubscriptionResolver
}

type DirectiveRoot struct {
	HasAccess func(ctx context.Context, obj interface{}, next graphql.Resolver, attributes ResourceAttributes) (res interface{}, err error)
}

type ComplexityRoot struct {
	Api struct {
		Name                   func(childComplexity int) int
		Hostname               func(childComplexity int) int
		Service                func(childComplexity int) int
		AuthenticationPolicies func(childComplexity int) int
	}

	AddonsConfiguration struct {
		Name   func(childComplexity int) int
		Urls   func(childComplexity int) int
		Labels func(childComplexity int) int
	}

	AddonsConfigurationEvent struct {
		Type                func(childComplexity int) int
		AddonsConfiguration func(childComplexity int) int
	}

	ApiService struct {
		Name func(childComplexity int) int
		Port func(childComplexity int) int
	}

	Application struct {
		Name                func(childComplexity int) int
		Description         func(childComplexity int) int
		Labels              func(childComplexity int) int
		Services            func(childComplexity int) int
		EnabledInNamespaces func(childComplexity int) int
		Status              func(childComplexity int) int
	}

	ApplicationEntry struct {
		Type        func(childComplexity int) int
		GatewayUrl  func(childComplexity int) int
		AccessLabel func(childComplexity int) int
	}

	ApplicationEvent struct {
		Type        func(childComplexity int) int
		Application func(childComplexity int) int
	}

	ApplicationMapping struct {
		Namespace   func(childComplexity int) int
		Application func(childComplexity int) int
	}

	ApplicationMutationOutput struct {
		Name        func(childComplexity int) int
		Description func(childComplexity int) int
		Labels      func(childComplexity int) int
	}

	ApplicationService struct {
		Id                  func(childComplexity int) int
		DisplayName         func(childComplexity int) int
		LongDescription     func(childComplexity int) int
		ProviderDisplayName func(childComplexity int) int
		Tags                func(childComplexity int) int
		Entries             func(childComplexity int) int
	}

	Asset struct {
		Name      func(childComplexity int) int
		Namespace func(childComplexity int) int
		Type      func(childComplexity int) int
		Files     func(childComplexity int, filterExtensions []string) int
		Status    func(childComplexity int) int
	}

	AssetEvent struct {
		Type  func(childComplexity int) int
		Asset func(childComplexity int) int
	}

	AssetStatus struct {
		Phase   func(childComplexity int) int
		Reason  func(childComplexity int) int
		Message func(childComplexity int) int
	}

	AuthenticationPolicy struct {
		Type    func(childComplexity int) int
		Issuer  func(childComplexity int) int
		JwksUri func(childComplexity int) int
	}

	BackendModule struct {
		Name func(childComplexity int) int
	}

	BindableResourcesOutputItem struct {
		Kind        func(childComplexity int) int
		DisplayName func(childComplexity int) int
		Resources   func(childComplexity int) int
	}

	ClusterAsset struct {
		Name   func(childComplexity int) int
		Type   func(childComplexity int) int
		Files  func(childComplexity int, filterExtensions []string) int
		Status func(childComplexity int) int
	}

	ClusterAssetEvent struct {
		Type         func(childComplexity int) int
		ClusterAsset func(childComplexity int) int
	}

	ClusterDocsTopic struct {
		Name        func(childComplexity int) int
		GroupName   func(childComplexity int) int
		Assets      func(childComplexity int, types []string) int
		DisplayName func(childComplexity int) int
		Description func(childComplexity int) int
		Status      func(childComplexity int) int
	}

	ClusterDocsTopicEvent struct {
		Type             func(childComplexity int) int
		ClusterDocsTopic func(childComplexity int) int
	}

	ClusterServiceBroker struct {
		Name              func(childComplexity int) int
		Status            func(childComplexity int) int
		CreationTimestamp func(childComplexity int) int
		Url               func(childComplexity int) int
		Labels            func(childComplexity int) int
	}

	ClusterServiceBrokerEvent struct {
		Type                 func(childComplexity int) int
		ClusterServiceBroker func(childComplexity int) int
	}

	ClusterServiceClass struct {
		Name                func(childComplexity int) int
		ExternalName        func(childComplexity int) int
		DisplayName         func(childComplexity int) int
		CreationTimestamp   func(childComplexity int) int
		Description         func(childComplexity int) int
		LongDescription     func(childComplexity int) int
		ImageUrl            func(childComplexity int) int
		DocumentationUrl    func(childComplexity int) int
		SupportUrl          func(childComplexity int) int
		ProviderDisplayName func(childComplexity int) int
		Tags                func(childComplexity int) int
		Labels              func(childComplexity int) int
		Plans               func(childComplexity int) int
		Activated           func(childComplexity int, namespace *string) int
		Instances           func(childComplexity int, namespace *string) int
		ApiSpec             func(childComplexity int) int
		OpenApiSpec         func(childComplexity int) int
		OdataSpec           func(childComplexity int) int
		AsyncApiSpec        func(childComplexity int) int
		Content             func(childComplexity int) int
		ClusterDocsTopic    func(childComplexity int) int
	}

	ClusterServicePlan struct {
		Name                           func(childComplexity int) int
		DisplayName                    func(childComplexity int) int
		ExternalName                   func(childComplexity int) int
		Description                    func(childComplexity int) int
		RelatedClusterServiceClassName func(childComplexity int) int
		InstanceCreateParameterSchema  func(childComplexity int) int
		BindingCreateParameterSchema   func(childComplexity int) int
	}

	ConfigMap struct {
		Name              func(childComplexity int) int
		Namespace         func(childComplexity int) int
		CreationTimestamp func(childComplexity int) int
		Labels            func(childComplexity int) int
		Json              func(childComplexity int) int
	}

	ConfigMapEvent struct {
		Type      func(childComplexity int) int
		ConfigMap func(childComplexity int) int
	}

	ConnectorService struct {
		Url func(childComplexity int) int
	}

	Container struct {
		Name  func(childComplexity int) int
		Image func(childComplexity int) int
	}

	ContainerState struct {
		State   func(childComplexity int) int
		Reason  func(childComplexity int) int
		Message func(childComplexity int) int
	}

	CreateServiceBindingOutput struct {
		Name                func(childComplexity int) int
		ServiceInstanceName func(childComplexity int) int
		Namespace           func(childComplexity int) int
	}

	DeleteApplicationOutput struct {
		Name func(childComplexity int) int
	}

	DeleteServiceBindingOutput struct {
		Name      func(childComplexity int) int
		Namespace func(childComplexity int) int
	}

	DeleteServiceBindingUsageOutput struct {
		Name      func(childComplexity int) int
		Namespace func(childComplexity int) int
	}

	Deployment struct {
		Name                      func(childComplexity int) int
		Namespace                 func(childComplexity int) int
		CreationTimestamp         func(childComplexity int) int
		Status                    func(childComplexity int) int
		Labels                    func(childComplexity int) int
		Containers                func(childComplexity int) int
		BoundServiceInstanceNames func(childComplexity int) int
	}

	DeploymentCondition struct {
		Status                  func(childComplexity int) int
		Type                    func(childComplexity int) int
		LastTransitionTimestamp func(childComplexity int) int
		LastUpdateTimestamp     func(childComplexity int) int
		Message                 func(childComplexity int) int
		Reason                  func(childComplexity int) int
	}

	DeploymentStatus struct {
		Replicas          func(childComplexity int) int
		UpdatedReplicas   func(childComplexity int) int
		ReadyReplicas     func(childComplexity int) int
		AvailableReplicas func(childComplexity int) int
		Conditions        func(childComplexity int) int
	}

	DocsTopic struct {
		Name        func(childComplexity int) int
		Namespace   func(childComplexity int) int
		GroupName   func(childComplexity int) int
		Assets      func(childComplexity int, types []string) int
		DisplayName func(childComplexity int) int
		Description func(childComplexity int) int
		Status      func(childComplexity int) int
	}

	DocsTopicEvent struct {
		Type      func(childComplexity int) int
		DocsTopic func(childComplexity int) int
	}

	DocsTopicStatus struct {
		Phase   func(childComplexity int) int
		Reason  func(childComplexity int) int
		Message func(childComplexity int) int
	}

	EnvPrefix struct {
		Name func(childComplexity int) int
	}

	EventActivation struct {
		Name        func(childComplexity int) int
		DisplayName func(childComplexity int) int
		SourceId    func(childComplexity int) int
		Events      func(childComplexity int) int
	}

	EventActivationEvent struct {
		EventType   func(childComplexity int) int
		Version     func(childComplexity int) int
		Description func(childComplexity int) int
	}

	ExceededQuota struct {
		QuotaName         func(childComplexity int) int
		ResourceName      func(childComplexity int) int
		AffectedResources func(childComplexity int) int
	}

	File struct {
		Url      func(childComplexity int) int
		Metadata func(childComplexity int) int
	}

	Function struct {
		Name              func(childComplexity int) int
		Trigger           func(childComplexity int) int
		CreationTimestamp func(childComplexity int) int
		Labels            func(childComplexity int) int
		Namespace         func(childComplexity int) int
	}

	Idppreset struct {
		Name    func(childComplexity int) int
		Issuer  func(childComplexity int) int
		JwksUri func(childComplexity int) int
	}

	LimitRange struct {
		Name   func(childComplexity int) int
		Limits func(childComplexity int) int
	}

	LimitRangeItem struct {
		LimitType      func(childComplexity int) int
		Max            func(childComplexity int) int
		Default        func(childComplexity int) int
		DefaultRequest func(childComplexity int) int
	}

	LoadBalancerIngress struct {
		Ip       func(childComplexity int) int
		HostName func(childComplexity int) int
	}

	LoadBalancerStatus struct {
		Ingress func(childComplexity int) int
	}

	LocalObjectReference struct {
		Kind func(childComplexity int) int
		Name func(childComplexity int) int
	}

	Mutation struct {
		CreateResource                func(childComplexity int, namespace string, resource JSON) int
		CreateServiceInstance         func(childComplexity int, namespace string, params ServiceInstanceCreateInput) int
		DeleteServiceInstance         func(childComplexity int, name string, namespace string) int
		CreateServiceBinding          func(childComplexity int, serviceBindingName *string, serviceInstanceName string, namespace string, parameters *JSON) int
		DeleteServiceBinding          func(childComplexity int, serviceBindingName string, namespace string) int
		CreateServiceBindingUsage     func(childComplexity int, namespace string, createServiceBindingUsageInput *CreateServiceBindingUsageInput) int
		DeleteServiceBindingUsage     func(childComplexity int, serviceBindingUsageName string, namespace string) int
		CreateAddonsConfiguration     func(childComplexity int, name string, urls []string, labels *Labels) int
		UpdateAddonsConfiguration     func(childComplexity int, name string, urls []string, labels *Labels) int
		DeleteAddonsConfiguration     func(childComplexity int, name string) int
		AddAddonsConfigurationUrls    func(childComplexity int, name string, urls []string) int
		RemoveAddonsConfigurationUrls func(childComplexity int, name string, urls []string) int
		CreateApplication             func(childComplexity int, name string, description *string, labels *Labels) int
		UpdateApplication             func(childComplexity int, name string, description *string, labels *Labels) int
		DeleteApplication             func(childComplexity int, name string) int
		EnableApplication             func(childComplexity int, application string, namespace string) int
		DisableApplication            func(childComplexity int, application string, namespace string) int
		UpdatePod                     func(childComplexity int, name string, namespace string, pod JSON) int
		DeletePod                     func(childComplexity int, name string, namespace string) int
		UpdateSecret                  func(childComplexity int, name string, namespace string, secret JSON) int
		DeleteSecret                  func(childComplexity int, name string, namespace string) int
		UpdateReplicaSet              func(childComplexity int, name string, namespace string, replicaSet JSON) int
		DeleteReplicaSet              func(childComplexity int, name string, namespace string) int
		UpdateConfigMap               func(childComplexity int, name string, namespace string, configMap JSON) int
		DeleteConfigMap               func(childComplexity int, name string, namespace string) int
		CreateIdppreset               func(childComplexity int, name string, issuer string, jwksUri string) int
		DeleteIdppreset               func(childComplexity int, name string) int
		UpdateService                 func(childComplexity int, name string, namespace string, service JSON) int
		DeleteService                 func(childComplexity int, name string, namespace string) int
	}

	Namespace struct {
		Name         func(childComplexity int) int
		Applications func(childComplexity int) int
	}

	Pod struct {
		Name              func(childComplexity int) int
		NodeName          func(childComplexity int) int
		Namespace         func(childComplexity int) int
		RestartCount      func(childComplexity int) int
		CreationTimestamp func(childComplexity int) int
		Labels            func(childComplexity int) int
		Status            func(childComplexity int) int
		ContainerStates   func(childComplexity int) int
		Json              func(childComplexity int) int
	}

	PodEvent struct {
		Type func(childComplexity int) int
		Pod  func(childComplexity int) int
	}

	Query struct {
		ClusterDocsTopics     func(childComplexity int, viewContext *string, groupName *string) int
		ServiceInstance       func(childComplexity int, name string, namespace string) int
		ServiceInstances      func(childComplexity int, namespace string, first *int, offset *int, status *InstanceStatusType) int
		ClusterServiceClasses func(childComplexity int, first *int, offset *int) int
		ClusterServiceClass   func(childComplexity int, name string) int
		ServiceClasses        func(childComplexity int, namespace string, first *int, offset *int) int
		ServiceClass          func(childComplexity int, namespace string, name string) int
		ClusterServiceBrokers func(childComplexity int, first *int, offset *int) int
		ClusterServiceBroker  func(childComplexity int, name string) int
		ServiceBrokers        func(childComplexity int, namespace string, first *int, offset *int) int
		ServiceBroker         func(childComplexity int, name string, namespace string) int
		ServiceBindingUsage   func(childComplexity int, name string, namespace string) int
		ServiceBinding        func(childComplexity int, name string, namespace string) int
		UsageKinds            func(childComplexity int, first *int, offset *int) int
		AddonsConfigurations  func(childComplexity int, first *int, offset *int) int
		BindableResources     func(childComplexity int, namespace string) int
		Apis                  func(childComplexity int, namespace string, serviceName *string, hostname *string) int
		Application           func(childComplexity int, name string) int
		Applications          func(childComplexity int, namespace *string, first *int, offset *int) int
		ConnectorService      func(childComplexity int, application string) int
		Namespaces            func(childComplexity int, application *string) int
		Deployments           func(childComplexity int, namespace string, excludeFunctions *bool) int
		Pod                   func(childComplexity int, name string, namespace string) int
		Pods                  func(childComplexity int, namespace string, first *int, offset *int) int
		Service               func(childComplexity int, name string, namespace string) int
		Services              func(childComplexity int, namespace string, first *int, offset *int) int
		ConfigMap             func(childComplexity int, name string, namespace string) int
		ConfigMaps            func(childComplexity int, namespace string, first *int, offset *int) int
		ReplicaSet            func(childComplexity int, name string, namespace string) int
		ReplicaSets           func(childComplexity int, namespace string, first *int, offset *int) int
		ResourceQuotas        func(childComplexity int, namespace string) int
		ResourceQuotasStatus  func(childComplexity int, namespace string) int
		Functions             func(childComplexity int, namespace string, first *int, offset *int) int
		Content               func(childComplexity int, contentType string, id string) int
		Topics                func(childComplexity int, input []InputTopic, internal *bool) int
		EventActivations      func(childComplexity int, namespace string) int
		LimitRanges           func(childComplexity int, namespace string) int
		BackendModules        func(childComplexity int) int
		Secret                func(childComplexity int, name string, namespace string) int
		Secrets               func(childComplexity int, namespace string, first *int, offset *int) int
		Idppreset             func(childComplexity int, name string) int
		Idppresets            func(childComplexity int, first *int, offset *int) int
		SelfSubjectRules      func(childComplexity int, namespace *string) int
	}

	ReplicaSet struct {
		Name              func(childComplexity int) int
		Pods              func(childComplexity int) int
		Namespace         func(childComplexity int) int
		Images            func(childComplexity int) int
		CreationTimestamp func(childComplexity int) int
		Labels            func(childComplexity int) int
		Json              func(childComplexity int) int
	}

	ResourceQuota struct {
		Name     func(childComplexity int) int
		Pods     func(childComplexity int) int
		Limits   func(childComplexity int) int
		Requests func(childComplexity int) int
	}

	ResourceQuotasStatus struct {
		Exceeded       func(childComplexity int) int
		ExceededQuotas func(childComplexity int) int
	}

	ResourceRule struct {
		Verbs     func(childComplexity int) int
		ApiGroups func(childComplexity int) int
		Resources func(childComplexity int) int
	}

	ResourceType struct {
		Memory func(childComplexity int) int
		Cpu    func(childComplexity int) int
	}

	ResourceValues struct {
		Memory func(childComplexity int) int
		Cpu    func(childComplexity int) int
	}

	Secret struct {
		Name         func(childComplexity int) int
		Namespace    func(childComplexity int) int
		Data         func(childComplexity int) int
		Type         func(childComplexity int) int
		CreationTime func(childComplexity int) int
		Labels       func(childComplexity int) int
		Annotations  func(childComplexity int) int
		Json         func(childComplexity int) int
	}

	SecretEvent struct {
		Type   func(childComplexity int) int
		Secret func(childComplexity int) int
	}

	Section struct {
		Name      func(childComplexity int) int
		Anchor    func(childComplexity int) int
		Titles    func(childComplexity int) int
		TopicType func(childComplexity int) int
	}

	Service struct {
		Name              func(childComplexity int) int
		ClusterIp         func(childComplexity int) int
		CreationTimestamp func(childComplexity int) int
		Labels            func(childComplexity int) int
		Ports             func(childComplexity int) int
		Status            func(childComplexity int) int
		Json              func(childComplexity int) int
	}

	ServiceBinding struct {
		Name                func(childComplexity int) int
		ServiceInstanceName func(childComplexity int) int
		Namespace           func(childComplexity int) int
		Secret              func(childComplexity int) int
		Status              func(childComplexity int) int
		Parameters          func(childComplexity int) int
	}

	ServiceBindingEvent struct {
		Type           func(childComplexity int) int
		ServiceBinding func(childComplexity int) int
	}

	ServiceBindingStatus struct {
		Type    func(childComplexity int) int
		Reason  func(childComplexity int) int
		Message func(childComplexity int) int
	}

	ServiceBindingUsage struct {
		Name           func(childComplexity int) int
		Namespace      func(childComplexity int) int
		ServiceBinding func(childComplexity int) int
		UsedBy         func(childComplexity int) int
		Parameters     func(childComplexity int) int
		Status         func(childComplexity int) int
	}

	ServiceBindingUsageEvent struct {
		Type                func(childComplexity int) int
		ServiceBindingUsage func(childComplexity int) int
	}

	ServiceBindingUsageParameters struct {
		EnvPrefix func(childComplexity int) int
	}

	ServiceBindingUsageStatus struct {
		Type    func(childComplexity int) int
		Reason  func(childComplexity int) int
		Message func(childComplexity int) int
	}

	ServiceBindings struct {
		Items func(childComplexity int) int
		Stats func(childComplexity int) int
	}

	ServiceBindingsStats struct {
		Ready   func(childComplexity int) int
		Failed  func(childComplexity int) int
		Pending func(childComplexity int) int
		Unknown func(childComplexity int) int
	}

	ServiceBroker struct {
		Name              func(childComplexity int) int
		Namespace         func(childComplexity int) int
		Status            func(childComplexity int) int
		CreationTimestamp func(childComplexity int) int
		Url               func(childComplexity int) int
		Labels            func(childComplexity int) int
	}

	ServiceBrokerEvent struct {
		Type          func(childComplexity int) int
		ServiceBroker func(childComplexity int) int
	}

	ServiceBrokerStatus struct {
		Ready   func(childComplexity int) int
		Reason  func(childComplexity int) int
		Message func(childComplexity int) int
	}

	ServiceClass struct {
		Name                func(childComplexity int) int
		Namespace           func(childComplexity int) int
		ExternalName        func(childComplexity int) int
		DisplayName         func(childComplexity int) int
		CreationTimestamp   func(childComplexity int) int
		Description         func(childComplexity int) int
		LongDescription     func(childComplexity int) int
		ImageUrl            func(childComplexity int) int
		DocumentationUrl    func(childComplexity int) int
		SupportUrl          func(childComplexity int) int
		ProviderDisplayName func(childComplexity int) int
		Tags                func(childComplexity int) int
		Labels              func(childComplexity int) int
		Plans               func(childComplexity int) int
		Activated           func(childComplexity int) int
		Instances           func(childComplexity int) int
		ApiSpec             func(childComplexity int) int
		OpenApiSpec         func(childComplexity int) int
		OdataSpec           func(childComplexity int) int
		AsyncApiSpec        func(childComplexity int) int
		Content             func(childComplexity int) int
		ClusterDocsTopic    func(childComplexity int) int
		DocsTopic           func(childComplexity int) int
	}

	ServiceEvent struct {
		Type    func(childComplexity int) int
		Service func(childComplexity int) int
	}

	ServiceInstance struct {
		Name                 func(childComplexity int) int
		Namespace            func(childComplexity int) int
		PlanSpec             func(childComplexity int) int
		CreationTimestamp    func(childComplexity int) int
		Labels               func(childComplexity int) int
		Status               func(childComplexity int) int
		ClassReference       func(childComplexity int) int
		PlanReference        func(childComplexity int) int
		ServiceClass         func(childComplexity int) int
		ClusterServiceClass  func(childComplexity int) int
		ServicePlan          func(childComplexity int) int
		ClusterServicePlan   func(childComplexity int) int
		Bindable             func(childComplexity int) int
		ServiceBindings      func(childComplexity int) int
		ServiceBindingUsages func(childComplexity int) int
	}

	ServiceInstanceEvent struct {
		Type            func(childComplexity int) int
		ServiceInstance func(childComplexity int) int
	}

	ServiceInstanceResourceRef struct {
		Name        func(childComplexity int) int
		DisplayName func(childComplexity int) int
		ClusterWide func(childComplexity int) int
	}

	ServiceInstanceStatus struct {
		Type    func(childComplexity int) int
		Reason  func(childComplexity int) int
		Message func(childComplexity int) int
	}

	ServicePlan struct {
		Name                          func(childComplexity int) int
		Namespace                     func(childComplexity int) int
		DisplayName                   func(childComplexity int) int
		ExternalName                  func(childComplexity int) int
		Description                   func(childComplexity int) int
		RelatedServiceClassName       func(childComplexity int) int
		InstanceCreateParameterSchema func(childComplexity int) int
		BindingCreateParameterSchema  func(childComplexity int) int
	}

	ServicePort struct {
		Name            func(childComplexity int) int
		ServiceProtocol func(childComplexity int) int
		Port            func(childComplexity int) int
		NodePort        func(childComplexity int) int
		TargetPort      func(childComplexity int) int
	}

	ServiceStatus struct {
		LoadBalancer func(childComplexity int) int
	}

	Subscription struct {
		ClusterAssetEvent         func(childComplexity int) int
		AssetEvent                func(childComplexity int, namespace string) int
		ClusterDocsTopicEvent     func(childComplexity int) int
		DocsTopicEvent            func(childComplexity int, namespace string) int
		ServiceInstanceEvent      func(childComplexity int, namespace string) int
		ServiceBindingEvent       func(childComplexity int, namespace string) int
		ServiceBindingUsageEvent  func(childComplexity int, namespace string) int
		ServiceBrokerEvent        func(childComplexity int, namespace string) int
		ClusterServiceBrokerEvent func(childComplexity int) int
		ApplicationEvent          func(childComplexity int) int
		PodEvent                  func(childComplexity int, namespace string) int
		ServiceEvent              func(childComplexity int, namespace string) int
		ConfigMapEvent            func(childComplexity int, namespace string) int
		AddonsConfigurationEvent  func(childComplexity int) int
	}

	Title struct {
		Name   func(childComplexity int) int
		Anchor func(childComplexity int) int
		Titles func(childComplexity int) int
	}

	TopicEntry struct {
		ContentType func(childComplexity int) int
		Id          func(childComplexity int) int
		Sections    func(childComplexity int) int
	}

	UsageKind struct {
		Name        func(childComplexity int) int
		Group       func(childComplexity int) int
		Kind        func(childComplexity int) int
		Version     func(childComplexity int) int
		DisplayName func(childComplexity int) int
	}

	UsageKindResource struct {
		Name      func(childComplexity int) int
		Namespace func(childComplexity int) int
	}
}

type ApplicationResolver interface {
	EnabledInNamespaces(ctx context.Context, obj *Application) ([]string, error)
	Status(ctx context.Context, obj *Application) (ApplicationStatus, error)
}
type AssetResolver interface {
	Files(ctx context.Context, obj *Asset, filterExtensions []string) ([]File, error)
}
type ClusterAssetResolver interface {
	Files(ctx context.Context, obj *ClusterAsset, filterExtensions []string) ([]File, error)
}
type ClusterDocsTopicResolver interface {
	Assets(ctx context.Context, obj *ClusterDocsTopic, types []string) ([]ClusterAsset, error)
}
type ClusterServiceClassResolver interface {
	Plans(ctx context.Context, obj *ClusterServiceClass) ([]ClusterServicePlan, error)
	Activated(ctx context.Context, obj *ClusterServiceClass, namespace *string) (bool, error)
	Instances(ctx context.Context, obj *ClusterServiceClass, namespace *string) ([]ServiceInstance, error)
	APISpec(ctx context.Context, obj *ClusterServiceClass) (*JSON, error)
	OpenAPISpec(ctx context.Context, obj *ClusterServiceClass) (*JSON, error)
	OdataSpec(ctx context.Context, obj *ClusterServiceClass) (*string, error)
	AsyncAPISpec(ctx context.Context, obj *ClusterServiceClass) (*JSON, error)
	Content(ctx context.Context, obj *ClusterServiceClass) (*JSON, error)
	ClusterDocsTopic(ctx context.Context, obj *ClusterServiceClass) (*ClusterDocsTopic, error)
}
type DeploymentResolver interface {
	BoundServiceInstanceNames(ctx context.Context, obj *Deployment) ([]string, error)
}
type DocsTopicResolver interface {
	Assets(ctx context.Context, obj *DocsTopic, types []string) ([]Asset, error)
}
type EventActivationResolver interface {
	Events(ctx context.Context, obj *EventActivation) ([]EventActivationEvent, error)
}
type MutationResolver interface {
	CreateResource(ctx context.Context, namespace string, resource JSON) (*JSON, error)
	CreateServiceInstance(ctx context.Context, namespace string, params ServiceInstanceCreateInput) (*ServiceInstance, error)
	DeleteServiceInstance(ctx context.Context, name string, namespace string) (*ServiceInstance, error)
	CreateServiceBinding(ctx context.Context, serviceBindingName *string, serviceInstanceName string, namespace string, parameters *JSON) (*CreateServiceBindingOutput, error)
	DeleteServiceBinding(ctx context.Context, serviceBindingName string, namespace string) (*DeleteServiceBindingOutput, error)
	CreateServiceBindingUsage(ctx context.Context, namespace string, createServiceBindingUsageInput *CreateServiceBindingUsageInput) (*ServiceBindingUsage, error)
	DeleteServiceBindingUsage(ctx context.Context, serviceBindingUsageName string, namespace string) (*DeleteServiceBindingUsageOutput, error)
	CreateAddonsConfiguration(ctx context.Context, name string, urls []string, labels *Labels) (*AddonsConfiguration, error)
	UpdateAddonsConfiguration(ctx context.Context, name string, urls []string, labels *Labels) (*AddonsConfiguration, error)
	DeleteAddonsConfiguration(ctx context.Context, name string) (*AddonsConfiguration, error)
	AddAddonsConfigurationURLs(ctx context.Context, name string, urls []string) (*AddonsConfiguration, error)
	RemoveAddonsConfigurationURLs(ctx context.Context, name string, urls []string) (*AddonsConfiguration, error)
	CreateApplication(ctx context.Context, name string, description *string, labels *Labels) (ApplicationMutationOutput, error)
	UpdateApplication(ctx context.Context, name string, description *string, labels *Labels) (ApplicationMutationOutput, error)
	DeleteApplication(ctx context.Context, name string) (DeleteApplicationOutput, error)
	EnableApplication(ctx context.Context, application string, namespace string) (*ApplicationMapping, error)
	DisableApplication(ctx context.Context, application string, namespace string) (*ApplicationMapping, error)
	UpdatePod(ctx context.Context, name string, namespace string, pod JSON) (*Pod, error)
	DeletePod(ctx context.Context, name string, namespace string) (*Pod, error)
	UpdateSecret(ctx context.Context, name string, namespace string, secret JSON) (*Secret, error)
	DeleteSecret(ctx context.Context, name string, namespace string) (*Secret, error)
	UpdateReplicaSet(ctx context.Context, name string, namespace string, replicaSet JSON) (*ReplicaSet, error)
	DeleteReplicaSet(ctx context.Context, name string, namespace string) (*ReplicaSet, error)
	UpdateConfigMap(ctx context.Context, name string, namespace string, configMap JSON) (*ConfigMap, error)
	DeleteConfigMap(ctx context.Context, name string, namespace string) (*ConfigMap, error)
	CreateIDPPreset(ctx context.Context, name string, issuer string, jwksUri string) (*IDPPreset, error)
	DeleteIDPPreset(ctx context.Context, name string) (*IDPPreset, error)
	UpdateService(ctx context.Context, name string, namespace string, service JSON) (*Service, error)
	DeleteService(ctx context.Context, name string, namespace string) (*Service, error)
}
type NamespaceResolver interface {
	Applications(ctx context.Context, obj *Namespace) ([]string, error)
}
type QueryResolver interface {
	ClusterDocsTopics(ctx context.Context, viewContext *string, groupName *string) ([]ClusterDocsTopic, error)
	ServiceInstance(ctx context.Context, name string, namespace string) (*ServiceInstance, error)
	ServiceInstances(ctx context.Context, namespace string, first *int, offset *int, status *InstanceStatusType) ([]ServiceInstance, error)
	ClusterServiceClasses(ctx context.Context, first *int, offset *int) ([]ClusterServiceClass, error)
	ClusterServiceClass(ctx context.Context, name string) (*ClusterServiceClass, error)
	ServiceClasses(ctx context.Context, namespace string, first *int, offset *int) ([]ServiceClass, error)
	ServiceClass(ctx context.Context, namespace string, name string) (*ServiceClass, error)
	ClusterServiceBrokers(ctx context.Context, first *int, offset *int) ([]ClusterServiceBroker, error)
	ClusterServiceBroker(ctx context.Context, name string) (*ClusterServiceBroker, error)
	ServiceBrokers(ctx context.Context, namespace string, first *int, offset *int) ([]ServiceBroker, error)
	ServiceBroker(ctx context.Context, name string, namespace string) (*ServiceBroker, error)
	ServiceBindingUsage(ctx context.Context, name string, namespace string) (*ServiceBindingUsage, error)
	ServiceBinding(ctx context.Context, name string, namespace string) (*ServiceBinding, error)
	UsageKinds(ctx context.Context, first *int, offset *int) ([]UsageKind, error)
	AddonsConfigurations(ctx context.Context, first *int, offset *int) ([]AddonsConfiguration, error)
	BindableResources(ctx context.Context, namespace string) ([]BindableResourcesOutputItem, error)
	Apis(ctx context.Context, namespace string, serviceName *string, hostname *string) ([]API, error)
	Application(ctx context.Context, name string) (*Application, error)
	Applications(ctx context.Context, namespace *string, first *int, offset *int) ([]Application, error)
	ConnectorService(ctx context.Context, application string) (ConnectorService, error)
	Namespaces(ctx context.Context, application *string) ([]Namespace, error)
	Deployments(ctx context.Context, namespace string, excludeFunctions *bool) ([]Deployment, error)
	Pod(ctx context.Context, name string, namespace string) (*Pod, error)
	Pods(ctx context.Context, namespace string, first *int, offset *int) ([]Pod, error)
	Service(ctx context.Context, name string, namespace string) (*Service, error)
	Services(ctx context.Context, namespace string, first *int, offset *int) ([]Service, error)
	ConfigMap(ctx context.Context, name string, namespace string) (*ConfigMap, error)
	ConfigMaps(ctx context.Context, namespace string, first *int, offset *int) ([]ConfigMap, error)
	ReplicaSet(ctx context.Context, name string, namespace string) (*ReplicaSet, error)
	ReplicaSets(ctx context.Context, namespace string, first *int, offset *int) ([]ReplicaSet, error)
	ResourceQuotas(ctx context.Context, namespace string) ([]ResourceQuota, error)
	ResourceQuotasStatus(ctx context.Context, namespace string) (ResourceQuotasStatus, error)
	Functions(ctx context.Context, namespace string, first *int, offset *int) ([]Function, error)
	Content(ctx context.Context, contentType string, id string) (*JSON, error)
	Topics(ctx context.Context, input []InputTopic, internal *bool) ([]TopicEntry, error)
	EventActivations(ctx context.Context, namespace string) ([]EventActivation, error)
	LimitRanges(ctx context.Context, namespace string) ([]LimitRange, error)
	BackendModules(ctx context.Context) ([]BackendModule, error)
	Secret(ctx context.Context, name string, namespace string) (*Secret, error)
	Secrets(ctx context.Context, namespace string, first *int, offset *int) ([]Secret, error)
	IDPPreset(ctx context.Context, name string) (*IDPPreset, error)
	IDPPresets(ctx context.Context, first *int, offset *int) ([]IDPPreset, error)
	SelfSubjectRules(ctx context.Context, namespace *string) ([]ResourceRule, error)
}
type ServiceBindingResolver interface {
	Secret(ctx context.Context, obj *ServiceBinding) (*Secret, error)
}
type ServiceBindingUsageResolver interface {
	ServiceBinding(ctx context.Context, obj *ServiceBindingUsage) (*ServiceBinding, error)
}
type ServiceClassResolver interface {
	Plans(ctx context.Context, obj *ServiceClass) ([]ServicePlan, error)
	Activated(ctx context.Context, obj *ServiceClass) (bool, error)
	Instances(ctx context.Context, obj *ServiceClass) ([]ServiceInstance, error)
	APISpec(ctx context.Context, obj *ServiceClass) (*JSON, error)
	OpenAPISpec(ctx context.Context, obj *ServiceClass) (*JSON, error)
	OdataSpec(ctx context.Context, obj *ServiceClass) (*string, error)
	AsyncAPISpec(ctx context.Context, obj *ServiceClass) (*JSON, error)
	Content(ctx context.Context, obj *ServiceClass) (*JSON, error)
	ClusterDocsTopic(ctx context.Context, obj *ServiceClass) (*ClusterDocsTopic, error)
	DocsTopic(ctx context.Context, obj *ServiceClass) (*DocsTopic, error)
}
type ServiceInstanceResolver interface {
	ServiceClass(ctx context.Context, obj *ServiceInstance) (*ServiceClass, error)
	ClusterServiceClass(ctx context.Context, obj *ServiceInstance) (*ClusterServiceClass, error)
	ServicePlan(ctx context.Context, obj *ServiceInstance) (*ServicePlan, error)
	ClusterServicePlan(ctx context.Context, obj *ServiceInstance) (*ClusterServicePlan, error)
	Bindable(ctx context.Context, obj *ServiceInstance) (bool, error)
	ServiceBindings(ctx context.Context, obj *ServiceInstance) (*ServiceBindings, error)
	ServiceBindingUsages(ctx context.Context, obj *ServiceInstance) ([]ServiceBindingUsage, error)
}
type SubscriptionResolver interface {
	ClusterAssetEvent(ctx context.Context) (<-chan ClusterAssetEvent, error)
	AssetEvent(ctx context.Context, namespace string) (<-chan AssetEvent, error)
	ClusterDocsTopicEvent(ctx context.Context) (<-chan ClusterDocsTopicEvent, error)
	DocsTopicEvent(ctx context.Context, namespace string) (<-chan DocsTopicEvent, error)
	ServiceInstanceEvent(ctx context.Context, namespace string) (<-chan ServiceInstanceEvent, error)
	ServiceBindingEvent(ctx context.Context, namespace string) (<-chan ServiceBindingEvent, error)
	ServiceBindingUsageEvent(ctx context.Context, namespace string) (<-chan ServiceBindingUsageEvent, error)
	ServiceBrokerEvent(ctx context.Context, namespace string) (<-chan ServiceBrokerEvent, error)
	ClusterServiceBrokerEvent(ctx context.Context) (<-chan ClusterServiceBrokerEvent, error)
	ApplicationEvent(ctx context.Context) (<-chan ApplicationEvent, error)
	PodEvent(ctx context.Context, namespace string) (<-chan PodEvent, error)
	ServiceEvent(ctx context.Context, namespace string) (<-chan ServiceEvent, error)
	ConfigMapEvent(ctx context.Context, namespace string) (<-chan ConfigMapEvent, error)
	AddonsConfigurationEvent(ctx context.Context) (<-chan AddonsConfigurationEvent, error)
}

func field_Asset_files_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["filterExtensions"]; ok {
		var err error
		var rawIf1 []interface{}
		if tmp != nil {
			if tmp1, ok := tmp.([]interface{}); ok {
				rawIf1 = tmp1
			} else {
				rawIf1 = []interface{}{tmp}
			}
		}
		arg0 = make([]string, len(rawIf1))
		for idx1 := range rawIf1 {
			arg0[idx1], err = graphql.UnmarshalString(rawIf1[idx1])
		}
		if err != nil {
			return nil, err
		}
	}
	args["filterExtensions"] = arg0
	return args, nil

}

func field_ClusterAsset_files_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["filterExtensions"]; ok {
		var err error
		var rawIf1 []interface{}
		if tmp != nil {
			if tmp1, ok := tmp.([]interface{}); ok {
				rawIf1 = tmp1
			} else {
				rawIf1 = []interface{}{tmp}
			}
		}
		arg0 = make([]string, len(rawIf1))
		for idx1 := range rawIf1 {
			arg0[idx1], err = graphql.UnmarshalString(rawIf1[idx1])
		}
		if err != nil {
			return nil, err
		}
	}
	args["filterExtensions"] = arg0
	return args, nil

}

func field_ClusterDocsTopic_assets_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["types"]; ok {
		var err error
		var rawIf1 []interface{}
		if tmp != nil {
			if tmp1, ok := tmp.([]interface{}); ok {
				rawIf1 = tmp1
			} else {
				rawIf1 = []interface{}{tmp}
			}
		}
		arg0 = make([]string, len(rawIf1))
		for idx1 := range rawIf1 {
			arg0[idx1], err = graphql.UnmarshalString(rawIf1[idx1])
		}
		if err != nil {
			return nil, err
		}
	}
	args["types"] = arg0
	return args, nil

}

func field_ClusterServiceClass_activated_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	return args, nil

}

func field_ClusterServiceClass_instances_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	return args, nil

}

func field_DocsTopic_assets_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["types"]; ok {
		var err error
		var rawIf1 []interface{}
		if tmp != nil {
			if tmp1, ok := tmp.([]interface{}); ok {
				rawIf1 = tmp1
			} else {
				rawIf1 = []interface{}{tmp}
			}
		}
		arg0 = make([]string, len(rawIf1))
		for idx1 := range rawIf1 {
			arg0[idx1], err = graphql.UnmarshalString(rawIf1[idx1])
		}
		if err != nil {
			return nil, err
		}
	}
	args["types"] = arg0
	return args, nil

}

func field_Mutation_createResource_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	var arg1 JSON
	if tmp, ok := rawArgs["resource"]; ok {
		var err error
		err = (&arg1).UnmarshalGQL(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["resource"] = arg1
	return args, nil

}

func field_Mutation_createServiceInstance_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	var arg1 ServiceInstanceCreateInput
	if tmp, ok := rawArgs["params"]; ok {
		var err error
		arg1, err = UnmarshalServiceInstanceCreateInput(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["params"] = arg1
	return args, nil

}

func field_Mutation_deleteServiceInstance_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil

}

func field_Mutation_createServiceBinding_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["serviceBindingName"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["serviceBindingName"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["serviceInstanceName"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["serviceInstanceName"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg2, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg2
	var arg3 *JSON
	if tmp, ok := rawArgs["parameters"]; ok {
		var err error
		var ptr1 JSON
		if tmp != nil {
			err = (&ptr1).UnmarshalGQL(tmp)
			arg3 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["parameters"] = arg3
	return args, nil

}

func field_Mutation_deleteServiceBinding_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["serviceBindingName"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["serviceBindingName"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil

}

func field_Mutation_createServiceBindingUsage_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	var arg1 *CreateServiceBindingUsageInput
	if tmp, ok := rawArgs["createServiceBindingUsageInput"]; ok {
		var err error
		var ptr1 CreateServiceBindingUsageInput
		if tmp != nil {
			ptr1, err = UnmarshalCreateServiceBindingUsageInput(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["createServiceBindingUsageInput"] = arg1
	return args, nil

}

func field_Mutation_deleteServiceBindingUsage_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["serviceBindingUsageName"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["serviceBindingUsageName"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil

}

func field_Mutation_createAddonsConfiguration_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 []string
	if tmp, ok := rawArgs["urls"]; ok {
		var err error
		var rawIf1 []interface{}
		if tmp != nil {
			if tmp1, ok := tmp.([]interface{}); ok {
				rawIf1 = tmp1
			} else {
				rawIf1 = []interface{}{tmp}
			}
		}
		arg1 = make([]string, len(rawIf1))
		for idx1 := range rawIf1 {
			arg1[idx1], err = graphql.UnmarshalString(rawIf1[idx1])
		}
		if err != nil {
			return nil, err
		}
	}
	args["urls"] = arg1
	var arg2 *Labels
	if tmp, ok := rawArgs["labels"]; ok {
		var err error
		var ptr1 Labels
		if tmp != nil {
			err = (&ptr1).UnmarshalGQL(tmp)
			arg2 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["labels"] = arg2
	return args, nil

}

func field_Mutation_updateAddonsConfiguration_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 []string
	if tmp, ok := rawArgs["urls"]; ok {
		var err error
		var rawIf1 []interface{}
		if tmp != nil {
			if tmp1, ok := tmp.([]interface{}); ok {
				rawIf1 = tmp1
			} else {
				rawIf1 = []interface{}{tmp}
			}
		}
		arg1 = make([]string, len(rawIf1))
		for idx1 := range rawIf1 {
			arg1[idx1], err = graphql.UnmarshalString(rawIf1[idx1])
		}
		if err != nil {
			return nil, err
		}
	}
	args["urls"] = arg1
	var arg2 *Labels
	if tmp, ok := rawArgs["labels"]; ok {
		var err error
		var ptr1 Labels
		if tmp != nil {
			err = (&ptr1).UnmarshalGQL(tmp)
			arg2 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["labels"] = arg2
	return args, nil

}

func field_Mutation_deleteAddonsConfiguration_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil

}

func field_Mutation_addAddonsConfigurationURLs_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 []string
	if tmp, ok := rawArgs["urls"]; ok {
		var err error
		var rawIf1 []interface{}
		if tmp != nil {
			if tmp1, ok := tmp.([]interface{}); ok {
				rawIf1 = tmp1
			} else {
				rawIf1 = []interface{}{tmp}
			}
		}
		arg1 = make([]string, len(rawIf1))
		for idx1 := range rawIf1 {
			arg1[idx1], err = graphql.UnmarshalString(rawIf1[idx1])
		}
		if err != nil {
			return nil, err
		}
	}
	args["urls"] = arg1
	return args, nil

}

func field_Mutation_removeAddonsConfigurationURLs_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 []string
	if tmp, ok := rawArgs["urls"]; ok {
		var err error
		var rawIf1 []interface{}
		if tmp != nil {
			if tmp1, ok := tmp.([]interface{}); ok {
				rawIf1 = tmp1
			} else {
				rawIf1 = []interface{}{tmp}
			}
		}
		arg1 = make([]string, len(rawIf1))
		for idx1 := range rawIf1 {
			arg1[idx1], err = graphql.UnmarshalString(rawIf1[idx1])
		}
		if err != nil {
			return nil, err
		}
	}
	args["urls"] = arg1
	return args, nil

}

func field_Mutation_createApplication_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["description"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["description"] = arg1
	var arg2 *Labels
	if tmp, ok := rawArgs["labels"]; ok {
		var err error
		var ptr1 Labels
		if tmp != nil {
			err = (&ptr1).UnmarshalGQL(tmp)
			arg2 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["labels"] = arg2
	return args, nil

}

func field_Mutation_updateApplication_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["description"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["description"] = arg1
	var arg2 *Labels
	if tmp, ok := rawArgs["labels"]; ok {
		var err error
		var ptr1 Labels
		if tmp != nil {
			err = (&ptr1).UnmarshalGQL(tmp)
			arg2 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["labels"] = arg2
	return args, nil

}

func field_Mutation_deleteApplication_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil

}

func field_Mutation_enableApplication_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["application"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["application"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil

}

func field_Mutation_disableApplication_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["application"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["application"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil

}

func field_Mutation_updatePod_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	var arg2 JSON
	if tmp, ok := rawArgs["pod"]; ok {
		var err error
		err = (&arg2).UnmarshalGQL(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pod"] = arg2
	return args, nil

}

func field_Mutation_deletePod_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil

}

func field_Mutation_updateSecret_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	var arg2 JSON
	if tmp, ok := rawArgs["secret"]; ok {
		var err error
		err = (&arg2).UnmarshalGQL(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["secret"] = arg2
	return args, nil

}

func field_Mutation_deleteSecret_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil

}

func field_Mutation_updateReplicaSet_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	var arg2 JSON
	if tmp, ok := rawArgs["replicaSet"]; ok {
		var err error
		err = (&arg2).UnmarshalGQL(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["replicaSet"] = arg2
	return args, nil

}

func field_Mutation_deleteReplicaSet_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil

}

func field_Mutation_updateConfigMap_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	var arg2 JSON
	if tmp, ok := rawArgs["configMap"]; ok {
		var err error
		err = (&arg2).UnmarshalGQL(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["configMap"] = arg2
	return args, nil

}

func field_Mutation_deleteConfigMap_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil

}

func field_Mutation_createIDPPreset_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["issuer"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["issuer"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["jwksUri"]; ok {
		var err error
		arg2, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["jwksUri"] = arg2
	return args, nil

}

func field_Mutation_deleteIDPPreset_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil

}

func field_Mutation_updateService_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	var arg2 JSON
	if tmp, ok := rawArgs["service"]; ok {
		var err error
		err = (&arg2).UnmarshalGQL(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["service"] = arg2
	return args, nil

}

func field_Mutation_deleteService_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil

}

func field_Query_clusterDocsTopics_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["viewContext"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["viewContext"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["groupName"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["groupName"] = arg1
	return args, nil

}

func field_Query_serviceInstance_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil

}

func field_Query_serviceInstances_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["offset"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg2 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg2
	var arg3 *InstanceStatusType
	if tmp, ok := rawArgs["status"]; ok {
		var err error
		var ptr1 InstanceStatusType
		if tmp != nil {
			err = (&ptr1).UnmarshalGQL(tmp)
			arg3 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["status"] = arg3
	return args, nil

}

func field_Query_clusterServiceClasses_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["first"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	return args, nil

}

func field_Query_clusterServiceClass_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil

}

func field_Query_serviceClasses_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["offset"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg2 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg2
	return args, nil

}

func field_Query_serviceClass_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg1
	return args, nil

}

func field_Query_clusterServiceBrokers_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["first"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	return args, nil

}

func field_Query_clusterServiceBroker_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil

}

func field_Query_serviceBrokers_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["offset"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg2 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg2
	return args, nil

}

func field_Query_serviceBroker_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil

}

func field_Query_serviceBindingUsage_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil

}

func field_Query_serviceBinding_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil

}

func field_Query_usageKinds_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["first"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	return args, nil

}

func field_Query_addonsConfigurations_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["first"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	return args, nil

}

func field_Query_bindableResources_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	return args, nil

}

func field_Query_apis_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["serviceName"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["serviceName"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["hostname"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg2 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["hostname"] = arg2
	return args, nil

}

func field_Query_application_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil

}

func field_Query_applications_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["offset"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg2 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg2
	return args, nil

}

func field_Query_connectorService_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["application"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["application"] = arg0
	return args, nil

}

func field_Query_namespaces_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["application"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["application"] = arg0
	return args, nil

}

func field_Query_deployments_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	var arg1 *bool
	if tmp, ok := rawArgs["excludeFunctions"]; ok {
		var err error
		var ptr1 bool
		if tmp != nil {
			ptr1, err = graphql.UnmarshalBoolean(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["excludeFunctions"] = arg1
	return args, nil

}

func field_Query_pod_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil

}

func field_Query_pods_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["offset"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg2 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg2
	return args, nil

}

func field_Query_service_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil

}

func field_Query_services_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["offset"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg2 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg2
	return args, nil

}

func field_Query_configMap_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil

}

func field_Query_configMaps_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["offset"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg2 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg2
	return args, nil

}

func field_Query_replicaSet_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil

}

func field_Query_replicaSets_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["offset"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg2 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg2
	return args, nil

}

func field_Query_resourceQuotas_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	return args, nil

}

func field_Query_resourceQuotasStatus_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	return args, nil

}

func field_Query_functions_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["offset"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg2 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg2
	return args, nil

}

func field_Query_content_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["contentType"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["contentType"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["id"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg1
	return args, nil

}

func field_Query_topics_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 []InputTopic
	if tmp, ok := rawArgs["input"]; ok {
		var err error
		var rawIf1 []interface{}
		if tmp != nil {
			if tmp1, ok := tmp.([]interface{}); ok {
				rawIf1 = tmp1
			} else {
				rawIf1 = []interface{}{tmp}
			}
		}
		arg0 = make([]InputTopic, len(rawIf1))
		for idx1 := range rawIf1 {
			arg0[idx1], err = UnmarshalInputTopic(rawIf1[idx1])
		}
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	var arg1 *bool
	if tmp, ok := rawArgs["internal"]; ok {
		var err error
		var ptr1 bool
		if tmp != nil {
			ptr1, err = graphql.UnmarshalBoolean(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["internal"] = arg1
	return args, nil

}

func field_Query_eventActivations_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	return args, nil

}

func field_Query_limitRanges_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	return args, nil

}

func field_Query_secret_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil

}

func field_Query_secrets_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["offset"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg2 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg2
	return args, nil

}

func field_Query_IDPPreset_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil

}

func field_Query_IDPPresets_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["first"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	return args, nil

}

func field_Query_selfSubjectRules_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	return args, nil

}

func field_Query___type_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil

}

func field_Subscription_assetEvent_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	return args, nil

}

func field_Subscription_docsTopicEvent_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	return args, nil

}

func field_Subscription_serviceInstanceEvent_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	return args, nil

}

func field_Subscription_serviceBindingEvent_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	return args, nil

}

func field_Subscription_serviceBindingUsageEvent_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	return args, nil

}

func field_Subscription_serviceBrokerEvent_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	return args, nil

}

func field_Subscription_podEvent_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	return args, nil

}

func field_Subscription_serviceEvent_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	return args, nil

}

func field_Subscription_configMapEvent_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	return args, nil

}

func field___Type_fields_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		var err error
		arg0, err = graphql.UnmarshalBoolean(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil

}

func field___Type_enumValues_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		var err error
		arg0, err = graphql.UnmarshalBoolean(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil

}

func dir_HasAccess_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 ResourceAttributes
	if tmp, ok := rawArgs["attributes"]; ok {
		var err error
		arg0, err = UnmarshalResourceAttributes(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["attributes"] = arg0
	return args, nil

}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	switch typeName + "." + field {

	case "API.name":
		if e.complexity.Api.Name == nil {
			break
		}

		return e.complexity.Api.Name(childComplexity), true

	case "API.hostname":
		if e.complexity.Api.Hostname == nil {
			break
		}

		return e.complexity.Api.Hostname(childComplexity), true

	case "API.service":
		if e.complexity.Api.Service == nil {
			break
		}

		return e.complexity.Api.Service(childComplexity), true

	case "API.authenticationPolicies":
		if e.complexity.Api.AuthenticationPolicies == nil {
			break
		}

		return e.complexity.Api.AuthenticationPolicies(childComplexity), true

	case "AddonsConfiguration.name":
		if e.complexity.AddonsConfiguration.Name == nil {
			break
		}

		return e.complexity.AddonsConfiguration.Name(childComplexity), true

	case "AddonsConfiguration.urls":
		if e.complexity.AddonsConfiguration.Urls == nil {
			break
		}

		return e.complexity.AddonsConfiguration.Urls(childComplexity), true

	case "AddonsConfiguration.labels":
		if e.complexity.AddonsConfiguration.Labels == nil {
			break
		}

		return e.complexity.AddonsConfiguration.Labels(childComplexity), true

	case "AddonsConfigurationEvent.type":
		if e.complexity.AddonsConfigurationEvent.Type == nil {
			break
		}

		return e.complexity.AddonsConfigurationEvent.Type(childComplexity), true

	case "AddonsConfigurationEvent.addonsConfiguration":
		if e.complexity.AddonsConfigurationEvent.AddonsConfiguration == nil {
			break
		}

		return e.complexity.AddonsConfigurationEvent.AddonsConfiguration(childComplexity), true

	case "ApiService.name":
		if e.complexity.ApiService.Name == nil {
			break
		}

		return e.complexity.ApiService.Name(childComplexity), true

	case "ApiService.port":
		if e.complexity.ApiService.Port == nil {
			break
		}

		return e.complexity.ApiService.Port(childComplexity), true

	case "Application.name":
		if e.complexity.Application.Name == nil {
			break
		}

		return e.complexity.Application.Name(childComplexity), true

	case "Application.description":
		if e.complexity.Application.Description == nil {
			break
		}

		return e.complexity.Application.Description(childComplexity), true

	case "Application.labels":
		if e.complexity.Application.Labels == nil {
			break
		}

		return e.complexity.Application.Labels(childComplexity), true

	case "Application.services":
		if e.complexity.Application.Services == nil {
			break
		}

		return e.complexity.Application.Services(childComplexity), true

	case "Application.enabledInNamespaces":
		if e.complexity.Application.EnabledInNamespaces == nil {
			break
		}

		return e.complexity.Application.EnabledInNamespaces(childComplexity), true

	case "Application.status":
		if e.complexity.Application.Status == nil {
			break
		}

		return e.complexity.Application.Status(childComplexity), true

	case "ApplicationEntry.type":
		if e.complexity.ApplicationEntry.Type == nil {
			break
		}

		return e.complexity.ApplicationEntry.Type(childComplexity), true

	case "ApplicationEntry.gatewayUrl":
		if e.complexity.ApplicationEntry.GatewayUrl == nil {
			break
		}

		return e.complexity.ApplicationEntry.GatewayUrl(childComplexity), true

	case "ApplicationEntry.accessLabel":
		if e.complexity.ApplicationEntry.AccessLabel == nil {
			break
		}

		return e.complexity.ApplicationEntry.AccessLabel(childComplexity), true

	case "ApplicationEvent.type":
		if e.complexity.ApplicationEvent.Type == nil {
			break
		}

		return e.complexity.ApplicationEvent.Type(childComplexity), true

	case "ApplicationEvent.application":
		if e.complexity.ApplicationEvent.Application == nil {
			break
		}

		return e.complexity.ApplicationEvent.Application(childComplexity), true

	case "ApplicationMapping.namespace":
		if e.complexity.ApplicationMapping.Namespace == nil {
			break
		}

		return e.complexity.ApplicationMapping.Namespace(childComplexity), true

	case "ApplicationMapping.application":
		if e.complexity.ApplicationMapping.Application == nil {
			break
		}

		return e.complexity.ApplicationMapping.Application(childComplexity), true

	case "ApplicationMutationOutput.name":
		if e.complexity.ApplicationMutationOutput.Name == nil {
			break
		}

		return e.complexity.ApplicationMutationOutput.Name(childComplexity), true

	case "ApplicationMutationOutput.description":
		if e.complexity.ApplicationMutationOutput.Description == nil {
			break
		}

		return e.complexity.ApplicationMutationOutput.Description(childComplexity), true

	case "ApplicationMutationOutput.labels":
		if e.complexity.ApplicationMutationOutput.Labels == nil {
			break
		}

		return e.complexity.ApplicationMutationOutput.Labels(childComplexity), true

	case "ApplicationService.id":
		if e.complexity.ApplicationService.Id == nil {
			break
		}

		return e.complexity.ApplicationService.Id(childComplexity), true

	case "ApplicationService.displayName":
		if e.complexity.ApplicationService.DisplayName == nil {
			break
		}

		return e.complexity.ApplicationService.DisplayName(childComplexity), true

	case "ApplicationService.longDescription":
		if e.complexity.ApplicationService.LongDescription == nil {
			break
		}

		return e.complexity.ApplicationService.LongDescription(childComplexity), true

	case "ApplicationService.providerDisplayName":
		if e.complexity.ApplicationService.ProviderDisplayName == nil {
			break
		}

		return e.complexity.ApplicationService.ProviderDisplayName(childComplexity), true

	case "ApplicationService.tags":
		if e.complexity.ApplicationService.Tags == nil {
			break
		}

		return e.complexity.ApplicationService.Tags(childComplexity), true

	case "ApplicationService.entries":
		if e.complexity.ApplicationService.Entries == nil {
			break
		}

		return e.complexity.ApplicationService.Entries(childComplexity), true

	case "Asset.name":
		if e.complexity.Asset.Name == nil {
			break
		}

		return e.complexity.Asset.Name(childComplexity), true

	case "Asset.namespace":
		if e.complexity.Asset.Namespace == nil {
			break
		}

		return e.complexity.Asset.Namespace(childComplexity), true

	case "Asset.type":
		if e.complexity.Asset.Type == nil {
			break
		}

		return e.complexity.Asset.Type(childComplexity), true

	case "Asset.files":
		if e.complexity.Asset.Files == nil {
			break
		}

		args, err := field_Asset_files_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Asset.Files(childComplexity, args["filterExtensions"].([]string)), true

	case "Asset.status":
		if e.complexity.Asset.Status == nil {
			break
		}

		return e.complexity.Asset.Status(childComplexity), true

	case "AssetEvent.type":
		if e.complexity.AssetEvent.Type == nil {
			break
		}

		return e.complexity.AssetEvent.Type(childComplexity), true

	case "AssetEvent.asset":
		if e.complexity.AssetEvent.Asset == nil {
			break
		}

		return e.complexity.AssetEvent.Asset(childComplexity), true

	case "AssetStatus.phase":
		if e.complexity.AssetStatus.Phase == nil {
			break
		}

		return e.complexity.AssetStatus.Phase(childComplexity), true

	case "AssetStatus.reason":
		if e.complexity.AssetStatus.Reason == nil {
			break
		}

		return e.complexity.AssetStatus.Reason(childComplexity), true

	case "AssetStatus.message":
		if e.complexity.AssetStatus.Message == nil {
			break
		}

		return e.complexity.AssetStatus.Message(childComplexity), true

	case "AuthenticationPolicy.type":
		if e.complexity.AuthenticationPolicy.Type == nil {
			break
		}

		return e.complexity.AuthenticationPolicy.Type(childComplexity), true

	case "AuthenticationPolicy.issuer":
		if e.complexity.AuthenticationPolicy.Issuer == nil {
			break
		}

		return e.complexity.AuthenticationPolicy.Issuer(childComplexity), true

	case "AuthenticationPolicy.jwksURI":
		if e.complexity.AuthenticationPolicy.JwksUri == nil {
			break
		}

		return e.complexity.AuthenticationPolicy.JwksUri(childComplexity), true

	case "BackendModule.name":
		if e.complexity.BackendModule.Name == nil {
			break
		}

		return e.complexity.BackendModule.Name(childComplexity), true

	case "BindableResourcesOutputItem.kind":
		if e.complexity.BindableResourcesOutputItem.Kind == nil {
			break
		}

		return e.complexity.BindableResourcesOutputItem.Kind(childComplexity), true

	case "BindableResourcesOutputItem.displayName":
		if e.complexity.BindableResourcesOutputItem.DisplayName == nil {
			break
		}

		return e.complexity.BindableResourcesOutputItem.DisplayName(childComplexity), true

	case "BindableResourcesOutputItem.resources":
		if e.complexity.BindableResourcesOutputItem.Resources == nil {
			break
		}

		return e.complexity.BindableResourcesOutputItem.Resources(childComplexity), true

	case "ClusterAsset.name":
		if e.complexity.ClusterAsset.Name == nil {
			break
		}

		return e.complexity.ClusterAsset.Name(childComplexity), true

	case "ClusterAsset.type":
		if e.complexity.ClusterAsset.Type == nil {
			break
		}

		return e.complexity.ClusterAsset.Type(childComplexity), true

	case "ClusterAsset.files":
		if e.complexity.ClusterAsset.Files == nil {
			break
		}

		args, err := field_ClusterAsset_files_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ClusterAsset.Files(childComplexity, args["filterExtensions"].([]string)), true

	case "ClusterAsset.status":
		if e.complexity.ClusterAsset.Status == nil {
			break
		}

		return e.complexity.ClusterAsset.Status(childComplexity), true

	case "ClusterAssetEvent.type":
		if e.complexity.ClusterAssetEvent.Type == nil {
			break
		}

		return e.complexity.ClusterAssetEvent.Type(childComplexity), true

	case "ClusterAssetEvent.clusterAsset":
		if e.complexity.ClusterAssetEvent.ClusterAsset == nil {
			break
		}

		return e.complexity.ClusterAssetEvent.ClusterAsset(childComplexity), true

	case "ClusterDocsTopic.name":
		if e.complexity.ClusterDocsTopic.Name == nil {
			break
		}

		return e.complexity.ClusterDocsTopic.Name(childComplexity), true

	case "ClusterDocsTopic.groupName":
		if e.complexity.ClusterDocsTopic.GroupName == nil {
			break
		}

		return e.complexity.ClusterDocsTopic.GroupName(childComplexity), true

	case "ClusterDocsTopic.assets":
		if e.complexity.ClusterDocsTopic.Assets == nil {
			break
		}

		args, err := field_ClusterDocsTopic_assets_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ClusterDocsTopic.Assets(childComplexity, args["types"].([]string)), true

	case "ClusterDocsTopic.displayName":
		if e.complexity.ClusterDocsTopic.DisplayName == nil {
			break
		}

		return e.complexity.ClusterDocsTopic.DisplayName(childComplexity), true

	case "ClusterDocsTopic.description":
		if e.complexity.ClusterDocsTopic.Description == nil {
			break
		}

		return e.complexity.ClusterDocsTopic.Description(childComplexity), true

	case "ClusterDocsTopic.status":
		if e.complexity.ClusterDocsTopic.Status == nil {
			break
		}

		return e.complexity.ClusterDocsTopic.Status(childComplexity), true

	case "ClusterDocsTopicEvent.type":
		if e.complexity.ClusterDocsTopicEvent.Type == nil {
			break
		}

		return e.complexity.ClusterDocsTopicEvent.Type(childComplexity), true

	case "ClusterDocsTopicEvent.clusterDocsTopic":
		if e.complexity.ClusterDocsTopicEvent.ClusterDocsTopic == nil {
			break
		}

		return e.complexity.ClusterDocsTopicEvent.ClusterDocsTopic(childComplexity), true

	case "ClusterServiceBroker.name":
		if e.complexity.ClusterServiceBroker.Name == nil {
			break
		}

		return e.complexity.ClusterServiceBroker.Name(childComplexity), true

	case "ClusterServiceBroker.status":
		if e.complexity.ClusterServiceBroker.Status == nil {
			break
		}

		return e.complexity.ClusterServiceBroker.Status(childComplexity), true

	case "ClusterServiceBroker.creationTimestamp":
		if e.complexity.ClusterServiceBroker.CreationTimestamp == nil {
			break
		}

		return e.complexity.ClusterServiceBroker.CreationTimestamp(childComplexity), true

	case "ClusterServiceBroker.url":
		if e.complexity.ClusterServiceBroker.Url == nil {
			break
		}

		return e.complexity.ClusterServiceBroker.Url(childComplexity), true

	case "ClusterServiceBroker.labels":
		if e.complexity.ClusterServiceBroker.Labels == nil {
			break
		}

		return e.complexity.ClusterServiceBroker.Labels(childComplexity), true

	case "ClusterServiceBrokerEvent.type":
		if e.complexity.ClusterServiceBrokerEvent.Type == nil {
			break
		}

		return e.complexity.ClusterServiceBrokerEvent.Type(childComplexity), true

	case "ClusterServiceBrokerEvent.clusterServiceBroker":
		if e.complexity.ClusterServiceBrokerEvent.ClusterServiceBroker == nil {
			break
		}

		return e.complexity.ClusterServiceBrokerEvent.ClusterServiceBroker(childComplexity), true

	case "ClusterServiceClass.name":
		if e.complexity.ClusterServiceClass.Name == nil {
			break
		}

		return e.complexity.ClusterServiceClass.Name(childComplexity), true

	case "ClusterServiceClass.externalName":
		if e.complexity.ClusterServiceClass.ExternalName == nil {
			break
		}

		return e.complexity.ClusterServiceClass.ExternalName(childComplexity), true

	case "ClusterServiceClass.displayName":
		if e.complexity.ClusterServiceClass.DisplayName == nil {
			break
		}

		return e.complexity.ClusterServiceClass.DisplayName(childComplexity), true

	case "ClusterServiceClass.creationTimestamp":
		if e.complexity.ClusterServiceClass.CreationTimestamp == nil {
			break
		}

		return e.complexity.ClusterServiceClass.CreationTimestamp(childComplexity), true

	case "ClusterServiceClass.description":
		if e.complexity.ClusterServiceClass.Description == nil {
			break
		}

		return e.complexity.ClusterServiceClass.Description(childComplexity), true

	case "ClusterServiceClass.longDescription":
		if e.complexity.ClusterServiceClass.LongDescription == nil {
			break
		}

		return e.complexity.ClusterServiceClass.LongDescription(childComplexity), true

	case "ClusterServiceClass.imageUrl":
		if e.complexity.ClusterServiceClass.ImageUrl == nil {
			break
		}

		return e.complexity.ClusterServiceClass.ImageUrl(childComplexity), true

	case "ClusterServiceClass.documentationUrl":
		if e.complexity.ClusterServiceClass.DocumentationUrl == nil {
			break
		}

		return e.complexity.ClusterServiceClass.DocumentationUrl(childComplexity), true

	case "ClusterServiceClass.supportUrl":
		if e.complexity.ClusterServiceClass.SupportUrl == nil {
			break
		}

		return e.complexity.ClusterServiceClass.SupportUrl(childComplexity), true

	case "ClusterServiceClass.providerDisplayName":
		if e.complexity.ClusterServiceClass.ProviderDisplayName == nil {
			break
		}

		return e.complexity.ClusterServiceClass.ProviderDisplayName(childComplexity), true

	case "ClusterServiceClass.tags":
		if e.complexity.ClusterServiceClass.Tags == nil {
			break
		}

		return e.complexity.ClusterServiceClass.Tags(childComplexity), true

	case "ClusterServiceClass.labels":
		if e.complexity.ClusterServiceClass.Labels == nil {
			break
		}

		return e.complexity.ClusterServiceClass.Labels(childComplexity), true

	case "ClusterServiceClass.plans":
		if e.complexity.ClusterServiceClass.Plans == nil {
			break
		}

		return e.complexity.ClusterServiceClass.Plans(childComplexity), true

	case "ClusterServiceClass.activated":
		if e.complexity.ClusterServiceClass.Activated == nil {
			break
		}

		args, err := field_ClusterServiceClass_activated_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ClusterServiceClass.Activated(childComplexity, args["namespace"].(*string)), true

	case "ClusterServiceClass.instances":
		if e.complexity.ClusterServiceClass.Instances == nil {
			break
		}

		args, err := field_ClusterServiceClass_instances_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ClusterServiceClass.Instances(childComplexity, args["namespace"].(*string)), true

	case "ClusterServiceClass.apiSpec":
		if e.complexity.ClusterServiceClass.ApiSpec == nil {
			break
		}

		return e.complexity.ClusterServiceClass.ApiSpec(childComplexity), true

	case "ClusterServiceClass.openApiSpec":
		if e.complexity.ClusterServiceClass.OpenApiSpec == nil {
			break
		}

		return e.complexity.ClusterServiceClass.OpenApiSpec(childComplexity), true

	case "ClusterServiceClass.odataSpec":
		if e.complexity.ClusterServiceClass.OdataSpec == nil {
			break
		}

		return e.complexity.ClusterServiceClass.OdataSpec(childComplexity), true

	case "ClusterServiceClass.asyncApiSpec":
		if e.complexity.ClusterServiceClass.AsyncApiSpec == nil {
			break
		}

		return e.complexity.ClusterServiceClass.AsyncApiSpec(childComplexity), true

	case "ClusterServiceClass.content":
		if e.complexity.ClusterServiceClass.Content == nil {
			break
		}

		return e.complexity.ClusterServiceClass.Content(childComplexity), true

	case "ClusterServiceClass.clusterDocsTopic":
		if e.complexity.ClusterServiceClass.ClusterDocsTopic == nil {
			break
		}

		return e.complexity.ClusterServiceClass.ClusterDocsTopic(childComplexity), true

	case "ClusterServicePlan.name":
		if e.complexity.ClusterServicePlan.Name == nil {
			break
		}

		return e.complexity.ClusterServicePlan.Name(childComplexity), true

	case "ClusterServicePlan.displayName":
		if e.complexity.ClusterServicePlan.DisplayName == nil {
			break
		}

		return e.complexity.ClusterServicePlan.DisplayName(childComplexity), true

	case "ClusterServicePlan.externalName":
		if e.complexity.ClusterServicePlan.ExternalName == nil {
			break
		}

		return e.complexity.ClusterServicePlan.ExternalName(childComplexity), true

	case "ClusterServicePlan.description":
		if e.complexity.ClusterServicePlan.Description == nil {
			break
		}

		return e.complexity.ClusterServicePlan.Description(childComplexity), true

	case "ClusterServicePlan.relatedClusterServiceClassName":
		if e.complexity.ClusterServicePlan.RelatedClusterServiceClassName == nil {
			break
		}

		return e.complexity.ClusterServicePlan.RelatedClusterServiceClassName(childComplexity), true

	case "ClusterServicePlan.instanceCreateParameterSchema":
		if e.complexity.ClusterServicePlan.InstanceCreateParameterSchema == nil {
			break
		}

		return e.complexity.ClusterServicePlan.InstanceCreateParameterSchema(childComplexity), true

	case "ClusterServicePlan.bindingCreateParameterSchema":
		if e.complexity.ClusterServicePlan.BindingCreateParameterSchema == nil {
			break
		}

		return e.complexity.ClusterServicePlan.BindingCreateParameterSchema(childComplexity), true

	case "ConfigMap.name":
		if e.complexity.ConfigMap.Name == nil {
			break
		}

		return e.complexity.ConfigMap.Name(childComplexity), true

	case "ConfigMap.namespace":
		if e.complexity.ConfigMap.Namespace == nil {
			break
		}

		return e.complexity.ConfigMap.Namespace(childComplexity), true

	case "ConfigMap.creationTimestamp":
		if e.complexity.ConfigMap.CreationTimestamp == nil {
			break
		}

		return e.complexity.ConfigMap.CreationTimestamp(childComplexity), true

	case "ConfigMap.labels":
		if e.complexity.ConfigMap.Labels == nil {
			break
		}

		return e.complexity.ConfigMap.Labels(childComplexity), true

	case "ConfigMap.json":
		if e.complexity.ConfigMap.Json == nil {
			break
		}

		return e.complexity.ConfigMap.Json(childComplexity), true

	case "ConfigMapEvent.type":
		if e.complexity.ConfigMapEvent.Type == nil {
			break
		}

		return e.complexity.ConfigMapEvent.Type(childComplexity), true

	case "ConfigMapEvent.configMap":
		if e.complexity.ConfigMapEvent.ConfigMap == nil {
			break
		}

		return e.complexity.ConfigMapEvent.ConfigMap(childComplexity), true

	case "ConnectorService.url":
		if e.complexity.ConnectorService.Url == nil {
			break
		}

		return e.complexity.ConnectorService.Url(childComplexity), true

	case "Container.name":
		if e.complexity.Container.Name == nil {
			break
		}

		return e.complexity.Container.Name(childComplexity), true

	case "Container.image":
		if e.complexity.Container.Image == nil {
			break
		}

		return e.complexity.Container.Image(childComplexity), true

	case "ContainerState.state":
		if e.complexity.ContainerState.State == nil {
			break
		}

		return e.complexity.ContainerState.State(childComplexity), true

	case "ContainerState.reason":
		if e.complexity.ContainerState.Reason == nil {
			break
		}

		return e.complexity.ContainerState.Reason(childComplexity), true

	case "ContainerState.message":
		if e.complexity.ContainerState.Message == nil {
			break
		}

		return e.complexity.ContainerState.Message(childComplexity), true

	case "CreateServiceBindingOutput.name":
		if e.complexity.CreateServiceBindingOutput.Name == nil {
			break
		}

		return e.complexity.CreateServiceBindingOutput.Name(childComplexity), true

	case "CreateServiceBindingOutput.serviceInstanceName":
		if e.complexity.CreateServiceBindingOutput.ServiceInstanceName == nil {
			break
		}

		return e.complexity.CreateServiceBindingOutput.ServiceInstanceName(childComplexity), true

	case "CreateServiceBindingOutput.namespace":
		if e.complexity.CreateServiceBindingOutput.Namespace == nil {
			break
		}

		return e.complexity.CreateServiceBindingOutput.Namespace(childComplexity), true

	case "DeleteApplicationOutput.name":
		if e.complexity.DeleteApplicationOutput.Name == nil {
			break
		}

		return e.complexity.DeleteApplicationOutput.Name(childComplexity), true

	case "DeleteServiceBindingOutput.name":
		if e.complexity.DeleteServiceBindingOutput.Name == nil {
			break
		}

		return e.complexity.DeleteServiceBindingOutput.Name(childComplexity), true

	case "DeleteServiceBindingOutput.namespace":
		if e.complexity.DeleteServiceBindingOutput.Namespace == nil {
			break
		}

		return e.complexity.DeleteServiceBindingOutput.Namespace(childComplexity), true

	case "DeleteServiceBindingUsageOutput.name":
		if e.complexity.DeleteServiceBindingUsageOutput.Name == nil {
			break
		}

		return e.complexity.DeleteServiceBindingUsageOutput.Name(childComplexity), true

	case "DeleteServiceBindingUsageOutput.namespace":
		if e.complexity.DeleteServiceBindingUsageOutput.Namespace == nil {
			break
		}

		return e.complexity.DeleteServiceBindingUsageOutput.Namespace(childComplexity), true

	case "Deployment.name":
		if e.complexity.Deployment.Name == nil {
			break
		}

		return e.complexity.Deployment.Name(childComplexity), true

	case "Deployment.namespace":
		if e.complexity.Deployment.Namespace == nil {
			break
		}

		return e.complexity.Deployment.Namespace(childComplexity), true

	case "Deployment.creationTimestamp":
		if e.complexity.Deployment.CreationTimestamp == nil {
			break
		}

		return e.complexity.Deployment.CreationTimestamp(childComplexity), true

	case "Deployment.status":
		if e.complexity.Deployment.Status == nil {
			break
		}

		return e.complexity.Deployment.Status(childComplexity), true

	case "Deployment.labels":
		if e.complexity.Deployment.Labels == nil {
			break
		}

		return e.complexity.Deployment.Labels(childComplexity), true

	case "Deployment.containers":
		if e.complexity.Deployment.Containers == nil {
			break
		}

		return e.complexity.Deployment.Containers(childComplexity), true

	case "Deployment.boundServiceInstanceNames":
		if e.complexity.Deployment.BoundServiceInstanceNames == nil {
			break
		}

		return e.complexity.Deployment.BoundServiceInstanceNames(childComplexity), true

	case "DeploymentCondition.status":
		if e.complexity.DeploymentCondition.Status == nil {
			break
		}

		return e.complexity.DeploymentCondition.Status(childComplexity), true

	case "DeploymentCondition.type":
		if e.complexity.DeploymentCondition.Type == nil {
			break
		}

		return e.complexity.DeploymentCondition.Type(childComplexity), true

	case "DeploymentCondition.lastTransitionTimestamp":
		if e.complexity.DeploymentCondition.LastTransitionTimestamp == nil {
			break
		}

		return e.complexity.DeploymentCondition.LastTransitionTimestamp(childComplexity), true

	case "DeploymentCondition.lastUpdateTimestamp":
		if e.complexity.DeploymentCondition.LastUpdateTimestamp == nil {
			break
		}

		return e.complexity.DeploymentCondition.LastUpdateTimestamp(childComplexity), true

	case "DeploymentCondition.message":
		if e.complexity.DeploymentCondition.Message == nil {
			break
		}

		return e.complexity.DeploymentCondition.Message(childComplexity), true

	case "DeploymentCondition.reason":
		if e.complexity.DeploymentCondition.Reason == nil {
			break
		}

		return e.complexity.DeploymentCondition.Reason(childComplexity), true

	case "DeploymentStatus.replicas":
		if e.complexity.DeploymentStatus.Replicas == nil {
			break
		}

		return e.complexity.DeploymentStatus.Replicas(childComplexity), true

	case "DeploymentStatus.updatedReplicas":
		if e.complexity.DeploymentStatus.UpdatedReplicas == nil {
			break
		}

		return e.complexity.DeploymentStatus.UpdatedReplicas(childComplexity), true

	case "DeploymentStatus.readyReplicas":
		if e.complexity.DeploymentStatus.ReadyReplicas == nil {
			break
		}

		return e.complexity.DeploymentStatus.ReadyReplicas(childComplexity), true

	case "DeploymentStatus.availableReplicas":
		if e.complexity.DeploymentStatus.AvailableReplicas == nil {
			break
		}

		return e.complexity.DeploymentStatus.AvailableReplicas(childComplexity), true

	case "DeploymentStatus.conditions":
		if e.complexity.DeploymentStatus.Conditions == nil {
			break
		}

		return e.complexity.DeploymentStatus.Conditions(childComplexity), true

	case "DocsTopic.name":
		if e.complexity.DocsTopic.Name == nil {
			break
		}

		return e.complexity.DocsTopic.Name(childComplexity), true

	case "DocsTopic.namespace":
		if e.complexity.DocsTopic.Namespace == nil {
			break
		}

		return e.complexity.DocsTopic.Namespace(childComplexity), true

	case "DocsTopic.groupName":
		if e.complexity.DocsTopic.GroupName == nil {
			break
		}

		return e.complexity.DocsTopic.GroupName(childComplexity), true

	case "DocsTopic.assets":
		if e.complexity.DocsTopic.Assets == nil {
			break
		}

		args, err := field_DocsTopic_assets_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DocsTopic.Assets(childComplexity, args["types"].([]string)), true

	case "DocsTopic.displayName":
		if e.complexity.DocsTopic.DisplayName == nil {
			break
		}

		return e.complexity.DocsTopic.DisplayName(childComplexity), true

	case "DocsTopic.description":
		if e.complexity.DocsTopic.Description == nil {
			break
		}

		return e.complexity.DocsTopic.Description(childComplexity), true

	case "DocsTopic.status":
		if e.complexity.DocsTopic.Status == nil {
			break
		}

		return e.complexity.DocsTopic.Status(childComplexity), true

	case "DocsTopicEvent.type":
		if e.complexity.DocsTopicEvent.Type == nil {
			break
		}

		return e.complexity.DocsTopicEvent.Type(childComplexity), true

	case "DocsTopicEvent.docsTopic":
		if e.complexity.DocsTopicEvent.DocsTopic == nil {
			break
		}

		return e.complexity.DocsTopicEvent.DocsTopic(childComplexity), true

	case "DocsTopicStatus.phase":
		if e.complexity.DocsTopicStatus.Phase == nil {
			break
		}

		return e.complexity.DocsTopicStatus.Phase(childComplexity), true

	case "DocsTopicStatus.reason":
		if e.complexity.DocsTopicStatus.Reason == nil {
			break
		}

		return e.complexity.DocsTopicStatus.Reason(childComplexity), true

	case "DocsTopicStatus.message":
		if e.complexity.DocsTopicStatus.Message == nil {
			break
		}

		return e.complexity.DocsTopicStatus.Message(childComplexity), true

	case "EnvPrefix.name":
		if e.complexity.EnvPrefix.Name == nil {
			break
		}

		return e.complexity.EnvPrefix.Name(childComplexity), true

	case "EventActivation.name":
		if e.complexity.EventActivation.Name == nil {
			break
		}

		return e.complexity.EventActivation.Name(childComplexity), true

	case "EventActivation.displayName":
		if e.complexity.EventActivation.DisplayName == nil {
			break
		}

		return e.complexity.EventActivation.DisplayName(childComplexity), true

	case "EventActivation.sourceId":
		if e.complexity.EventActivation.SourceId == nil {
			break
		}

		return e.complexity.EventActivation.SourceId(childComplexity), true

	case "EventActivation.events":
		if e.complexity.EventActivation.Events == nil {
			break
		}

		return e.complexity.EventActivation.Events(childComplexity), true

	case "EventActivationEvent.eventType":
		if e.complexity.EventActivationEvent.EventType == nil {
			break
		}

		return e.complexity.EventActivationEvent.EventType(childComplexity), true

	case "EventActivationEvent.version":
		if e.complexity.EventActivationEvent.Version == nil {
			break
		}

		return e.complexity.EventActivationEvent.Version(childComplexity), true

	case "EventActivationEvent.description":
		if e.complexity.EventActivationEvent.Description == nil {
			break
		}

		return e.complexity.EventActivationEvent.Description(childComplexity), true

	case "ExceededQuota.quotaName":
		if e.complexity.ExceededQuota.QuotaName == nil {
			break
		}

		return e.complexity.ExceededQuota.QuotaName(childComplexity), true

	case "ExceededQuota.resourceName":
		if e.complexity.ExceededQuota.ResourceName == nil {
			break
		}

		return e.complexity.ExceededQuota.ResourceName(childComplexity), true

	case "ExceededQuota.affectedResources":
		if e.complexity.ExceededQuota.AffectedResources == nil {
			break
		}

		return e.complexity.ExceededQuota.AffectedResources(childComplexity), true

	case "File.url":
		if e.complexity.File.Url == nil {
			break
		}

		return e.complexity.File.Url(childComplexity), true

	case "File.metadata":
		if e.complexity.File.Metadata == nil {
			break
		}

		return e.complexity.File.Metadata(childComplexity), true

	case "Function.name":
		if e.complexity.Function.Name == nil {
			break
		}

		return e.complexity.Function.Name(childComplexity), true

	case "Function.trigger":
		if e.complexity.Function.Trigger == nil {
			break
		}

		return e.complexity.Function.Trigger(childComplexity), true

	case "Function.creationTimestamp":
		if e.complexity.Function.CreationTimestamp == nil {
			break
		}

		return e.complexity.Function.CreationTimestamp(childComplexity), true

	case "Function.labels":
		if e.complexity.Function.Labels == nil {
			break
		}

		return e.complexity.Function.Labels(childComplexity), true

	case "Function.namespace":
		if e.complexity.Function.Namespace == nil {
			break
		}

		return e.complexity.Function.Namespace(childComplexity), true

	case "IDPPreset.name":
		if e.complexity.Idppreset.Name == nil {
			break
		}

		return e.complexity.Idppreset.Name(childComplexity), true

	case "IDPPreset.issuer":
		if e.complexity.Idppreset.Issuer == nil {
			break
		}

		return e.complexity.Idppreset.Issuer(childComplexity), true

	case "IDPPreset.jwksUri":
		if e.complexity.Idppreset.JwksUri == nil {
			break
		}

		return e.complexity.Idppreset.JwksUri(childComplexity), true

	case "LimitRange.name":
		if e.complexity.LimitRange.Name == nil {
			break
		}

		return e.complexity.LimitRange.Name(childComplexity), true

	case "LimitRange.limits":
		if e.complexity.LimitRange.Limits == nil {
			break
		}

		return e.complexity.LimitRange.Limits(childComplexity), true

	case "LimitRangeItem.limitType":
		if e.complexity.LimitRangeItem.LimitType == nil {
			break
		}

		return e.complexity.LimitRangeItem.LimitType(childComplexity), true

	case "LimitRangeItem.max":
		if e.complexity.LimitRangeItem.Max == nil {
			break
		}

		return e.complexity.LimitRangeItem.Max(childComplexity), true

	case "LimitRangeItem.default":
		if e.complexity.LimitRangeItem.Default == nil {
			break
		}

		return e.complexity.LimitRangeItem.Default(childComplexity), true

	case "LimitRangeItem.defaultRequest":
		if e.complexity.LimitRangeItem.DefaultRequest == nil {
			break
		}

		return e.complexity.LimitRangeItem.DefaultRequest(childComplexity), true

	case "LoadBalancerIngress.ip":
		if e.complexity.LoadBalancerIngress.Ip == nil {
			break
		}

		return e.complexity.LoadBalancerIngress.Ip(childComplexity), true

	case "LoadBalancerIngress.hostName":
		if e.complexity.LoadBalancerIngress.HostName == nil {
			break
		}

		return e.complexity.LoadBalancerIngress.HostName(childComplexity), true

	case "LoadBalancerStatus.ingress":
		if e.complexity.LoadBalancerStatus.Ingress == nil {
			break
		}

		return e.complexity.LoadBalancerStatus.Ingress(childComplexity), true

	case "LocalObjectReference.kind":
		if e.complexity.LocalObjectReference.Kind == nil {
			break
		}

		return e.complexity.LocalObjectReference.Kind(childComplexity), true

	case "LocalObjectReference.name":
		if e.complexity.LocalObjectReference.Name == nil {
			break
		}

		return e.complexity.LocalObjectReference.Name(childComplexity), true

	case "Mutation.createResource":
		if e.complexity.Mutation.CreateResource == nil {
			break
		}

		args, err := field_Mutation_createResource_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateResource(childComplexity, args["namespace"].(string), args["resource"].(JSON)), true

	case "Mutation.createServiceInstance":
		if e.complexity.Mutation.CreateServiceInstance == nil {
			break
		}

		args, err := field_Mutation_createServiceInstance_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateServiceInstance(childComplexity, args["namespace"].(string), args["params"].(ServiceInstanceCreateInput)), true

	case "Mutation.deleteServiceInstance":
		if e.complexity.Mutation.DeleteServiceInstance == nil {
			break
		}

		args, err := field_Mutation_deleteServiceInstance_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteServiceInstance(childComplexity, args["name"].(string), args["namespace"].(string)), true

	case "Mutation.createServiceBinding":
		if e.complexity.Mutation.CreateServiceBinding == nil {
			break
		}

		args, err := field_Mutation_createServiceBinding_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateServiceBinding(childComplexity, args["serviceBindingName"].(*string), args["serviceInstanceName"].(string), args["namespace"].(string), args["parameters"].(*JSON)), true

	case "Mutation.deleteServiceBinding":
		if e.complexity.Mutation.DeleteServiceBinding == nil {
			break
		}

		args, err := field_Mutation_deleteServiceBinding_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteServiceBinding(childComplexity, args["serviceBindingName"].(string), args["namespace"].(string)), true

	case "Mutation.createServiceBindingUsage":
		if e.complexity.Mutation.CreateServiceBindingUsage == nil {
			break
		}

		args, err := field_Mutation_createServiceBindingUsage_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateServiceBindingUsage(childComplexity, args["namespace"].(string), args["createServiceBindingUsageInput"].(*CreateServiceBindingUsageInput)), true

	case "Mutation.deleteServiceBindingUsage":
		if e.complexity.Mutation.DeleteServiceBindingUsage == nil {
			break
		}

		args, err := field_Mutation_deleteServiceBindingUsage_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteServiceBindingUsage(childComplexity, args["serviceBindingUsageName"].(string), args["namespace"].(string)), true

	case "Mutation.createAddonsConfiguration":
		if e.complexity.Mutation.CreateAddonsConfiguration == nil {
			break
		}

		args, err := field_Mutation_createAddonsConfiguration_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateAddonsConfiguration(childComplexity, args["name"].(string), args["urls"].([]string), args["labels"].(*Labels)), true

	case "Mutation.updateAddonsConfiguration":
		if e.complexity.Mutation.UpdateAddonsConfiguration == nil {
			break
		}

		args, err := field_Mutation_updateAddonsConfiguration_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateAddonsConfiguration(childComplexity, args["name"].(string), args["urls"].([]string), args["labels"].(*Labels)), true

	case "Mutation.deleteAddonsConfiguration":
		if e.complexity.Mutation.DeleteAddonsConfiguration == nil {
			break
		}

		args, err := field_Mutation_deleteAddonsConfiguration_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteAddonsConfiguration(childComplexity, args["name"].(string)), true

	case "Mutation.addAddonsConfigurationURLs":
		if e.complexity.Mutation.AddAddonsConfigurationUrls == nil {
			break
		}

		args, err := field_Mutation_addAddonsConfigurationURLs_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddAddonsConfigurationUrls(childComplexity, args["name"].(string), args["urls"].([]string)), true

	case "Mutation.removeAddonsConfigurationURLs":
		if e.complexity.Mutation.RemoveAddonsConfigurationUrls == nil {
			break
		}

		args, err := field_Mutation_removeAddonsConfigurationURLs_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemoveAddonsConfigurationUrls(childComplexity, args["name"].(string), args["urls"].([]string)), true

	case "Mutation.createApplication":
		if e.complexity.Mutation.CreateApplication == nil {
			break
		}

		args, err := field_Mutation_createApplication_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateApplication(childComplexity, args["name"].(string), args["description"].(*string), args["labels"].(*Labels)), true

	case "Mutation.updateApplication":
		if e.complexity.Mutation.UpdateApplication == nil {
			break
		}

		args, err := field_Mutation_updateApplication_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateApplication(childComplexity, args["name"].(string), args["description"].(*string), args["labels"].(*Labels)), true

	case "Mutation.deleteApplication":
		if e.complexity.Mutation.DeleteApplication == nil {
			break
		}

		args, err := field_Mutation_deleteApplication_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteApplication(childComplexity, args["name"].(string)), true

	case "Mutation.enableApplication":
		if e.complexity.Mutation.EnableApplication == nil {
			break
		}

		args, err := field_Mutation_enableApplication_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.EnableApplication(childComplexity, args["application"].(string), args["namespace"].(string)), true

	case "Mutation.disableApplication":
		if e.complexity.Mutation.DisableApplication == nil {
			break
		}

		args, err := field_Mutation_disableApplication_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DisableApplication(childComplexity, args["application"].(string), args["namespace"].(string)), true

	case "Mutation.updatePod":
		if e.complexity.Mutation.UpdatePod == nil {
			break
		}

		args, err := field_Mutation_updatePod_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdatePod(childComplexity, args["name"].(string), args["namespace"].(string), args["pod"].(JSON)), true

	case "Mutation.deletePod":
		if e.complexity.Mutation.DeletePod == nil {
			break
		}

		args, err := field_Mutation_deletePod_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeletePod(childComplexity, args["name"].(string), args["namespace"].(string)), true

	case "Mutation.updateSecret":
		if e.complexity.Mutation.UpdateSecret == nil {
			break
		}

		args, err := field_Mutation_updateSecret_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateSecret(childComplexity, args["name"].(string), args["namespace"].(string), args["secret"].(JSON)), true

	case "Mutation.deleteSecret":
		if e.complexity.Mutation.DeleteSecret == nil {
			break
		}

		args, err := field_Mutation_deleteSecret_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteSecret(childComplexity, args["name"].(string), args["namespace"].(string)), true

	case "Mutation.updateReplicaSet":
		if e.complexity.Mutation.UpdateReplicaSet == nil {
			break
		}

		args, err := field_Mutation_updateReplicaSet_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateReplicaSet(childComplexity, args["name"].(string), args["namespace"].(string), args["replicaSet"].(JSON)), true

	case "Mutation.deleteReplicaSet":
		if e.complexity.Mutation.DeleteReplicaSet == nil {
			break
		}

		args, err := field_Mutation_deleteReplicaSet_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteReplicaSet(childComplexity, args["name"].(string), args["namespace"].(string)), true

	case "Mutation.updateConfigMap":
		if e.complexity.Mutation.UpdateConfigMap == nil {
			break
		}

		args, err := field_Mutation_updateConfigMap_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateConfigMap(childComplexity, args["name"].(string), args["namespace"].(string), args["configMap"].(JSON)), true

	case "Mutation.deleteConfigMap":
		if e.complexity.Mutation.DeleteConfigMap == nil {
			break
		}

		args, err := field_Mutation_deleteConfigMap_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteConfigMap(childComplexity, args["name"].(string), args["namespace"].(string)), true

	case "Mutation.createIDPPreset":
		if e.complexity.Mutation.CreateIdppreset == nil {
			break
		}

		args, err := field_Mutation_createIDPPreset_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateIdppreset(childComplexity, args["name"].(string), args["issuer"].(string), args["jwksUri"].(string)), true

	case "Mutation.deleteIDPPreset":
		if e.complexity.Mutation.DeleteIdppreset == nil {
			break
		}

		args, err := field_Mutation_deleteIDPPreset_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteIdppreset(childComplexity, args["name"].(string)), true

	case "Mutation.updateService":
		if e.complexity.Mutation.UpdateService == nil {
			break
		}

		args, err := field_Mutation_updateService_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateService(childComplexity, args["name"].(string), args["namespace"].(string), args["service"].(JSON)), true

	case "Mutation.deleteService":
		if e.complexity.Mutation.DeleteService == nil {
			break
		}

		args, err := field_Mutation_deleteService_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteService(childComplexity, args["name"].(string), args["namespace"].(string)), true

	case "Namespace.name":
		if e.complexity.Namespace.Name == nil {
			break
		}

		return e.complexity.Namespace.Name(childComplexity), true

	case "Namespace.applications":
		if e.complexity.Namespace.Applications == nil {
			break
		}

		return e.complexity.Namespace.Applications(childComplexity), true

	case "Pod.name":
		if e.complexity.Pod.Name == nil {
			break
		}

		return e.complexity.Pod.Name(childComplexity), true

	case "Pod.nodeName":
		if e.complexity.Pod.NodeName == nil {
			break
		}

		return e.complexity.Pod.NodeName(childComplexity), true

	case "Pod.namespace":
		if e.complexity.Pod.Namespace == nil {
			break
		}

		return e.complexity.Pod.Namespace(childComplexity), true

	case "Pod.restartCount":
		if e.complexity.Pod.RestartCount == nil {
			break
		}

		return e.complexity.Pod.RestartCount(childComplexity), true

	case "Pod.creationTimestamp":
		if e.complexity.Pod.CreationTimestamp == nil {
			break
		}

		return e.complexity.Pod.CreationTimestamp(childComplexity), true

	case "Pod.labels":
		if e.complexity.Pod.Labels == nil {
			break
		}

		return e.complexity.Pod.Labels(childComplexity), true

	case "Pod.status":
		if e.complexity.Pod.Status == nil {
			break
		}

		return e.complexity.Pod.Status(childComplexity), true

	case "Pod.containerStates":
		if e.complexity.Pod.ContainerStates == nil {
			break
		}

		return e.complexity.Pod.ContainerStates(childComplexity), true

	case "Pod.json":
		if e.complexity.Pod.Json == nil {
			break
		}

		return e.complexity.Pod.Json(childComplexity), true

	case "PodEvent.type":
		if e.complexity.PodEvent.Type == nil {
			break
		}

		return e.complexity.PodEvent.Type(childComplexity), true

	case "PodEvent.pod":
		if e.complexity.PodEvent.Pod == nil {
			break
		}

		return e.complexity.PodEvent.Pod(childComplexity), true

	case "Query.clusterDocsTopics":
		if e.complexity.Query.ClusterDocsTopics == nil {
			break
		}

		args, err := field_Query_clusterDocsTopics_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ClusterDocsTopics(childComplexity, args["viewContext"].(*string), args["groupName"].(*string)), true

	case "Query.serviceInstance":
		if e.complexity.Query.ServiceInstance == nil {
			break
		}

		args, err := field_Query_serviceInstance_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ServiceInstance(childComplexity, args["name"].(string), args["namespace"].(string)), true

	case "Query.serviceInstances":
		if e.complexity.Query.ServiceInstances == nil {
			break
		}

		args, err := field_Query_serviceInstances_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ServiceInstances(childComplexity, args["namespace"].(string), args["first"].(*int), args["offset"].(*int), args["status"].(*InstanceStatusType)), true

	case "Query.clusterServiceClasses":
		if e.complexity.Query.ClusterServiceClasses == nil {
			break
		}

		args, err := field_Query_clusterServiceClasses_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ClusterServiceClasses(childComplexity, args["first"].(*int), args["offset"].(*int)), true

	case "Query.clusterServiceClass":
		if e.complexity.Query.ClusterServiceClass == nil {
			break
		}

		args, err := field_Query_clusterServiceClass_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ClusterServiceClass(childComplexity, args["name"].(string)), true

	case "Query.serviceClasses":
		if e.complexity.Query.ServiceClasses == nil {
			break
		}

		args, err := field_Query_serviceClasses_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ServiceClasses(childComplexity, args["namespace"].(string), args["first"].(*int), args["offset"].(*int)), true

	case "Query.serviceClass":
		if e.complexity.Query.ServiceClass == nil {
			break
		}

		args, err := field_Query_serviceClass_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ServiceClass(childComplexity, args["namespace"].(string), args["name"].(string)), true

	case "Query.clusterServiceBrokers":
		if e.complexity.Query.ClusterServiceBrokers == nil {
			break
		}

		args, err := field_Query_clusterServiceBrokers_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ClusterServiceBrokers(childComplexity, args["first"].(*int), args["offset"].(*int)), true

	case "Query.clusterServiceBroker":
		if e.complexity.Query.ClusterServiceBroker == nil {
			break
		}

		args, err := field_Query_clusterServiceBroker_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ClusterServiceBroker(childComplexity, args["name"].(string)), true

	case "Query.serviceBrokers":
		if e.complexity.Query.ServiceBrokers == nil {
			break
		}

		args, err := field_Query_serviceBrokers_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ServiceBrokers(childComplexity, args["namespace"].(string), args["first"].(*int), args["offset"].(*int)), true

	case "Query.serviceBroker":
		if e.complexity.Query.ServiceBroker == nil {
			break
		}

		args, err := field_Query_serviceBroker_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ServiceBroker(childComplexity, args["name"].(string), args["namespace"].(string)), true

	case "Query.serviceBindingUsage":
		if e.complexity.Query.ServiceBindingUsage == nil {
			break
		}

		args, err := field_Query_serviceBindingUsage_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ServiceBindingUsage(childComplexity, args["name"].(string), args["namespace"].(string)), true

	case "Query.serviceBinding":
		if e.complexity.Query.ServiceBinding == nil {
			break
		}

		args, err := field_Query_serviceBinding_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ServiceBinding(childComplexity, args["name"].(string), args["namespace"].(string)), true

	case "Query.usageKinds":
		if e.complexity.Query.UsageKinds == nil {
			break
		}

		args, err := field_Query_usageKinds_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UsageKinds(childComplexity, args["first"].(*int), args["offset"].(*int)), true

	case "Query.addonsConfigurations":
		if e.complexity.Query.AddonsConfigurations == nil {
			break
		}

		args, err := field_Query_addonsConfigurations_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AddonsConfigurations(childComplexity, args["first"].(*int), args["offset"].(*int)), true

	case "Query.bindableResources":
		if e.complexity.Query.BindableResources == nil {
			break
		}

		args, err := field_Query_bindableResources_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.BindableResources(childComplexity, args["namespace"].(string)), true

	case "Query.apis":
		if e.complexity.Query.Apis == nil {
			break
		}

		args, err := field_Query_apis_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Apis(childComplexity, args["namespace"].(string), args["serviceName"].(*string), args["hostname"].(*string)), true

	case "Query.application":
		if e.complexity.Query.Application == nil {
			break
		}

		args, err := field_Query_application_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Application(childComplexity, args["name"].(string)), true

	case "Query.applications":
		if e.complexity.Query.Applications == nil {
			break
		}

		args, err := field_Query_applications_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Applications(childComplexity, args["namespace"].(*string), args["first"].(*int), args["offset"].(*int)), true

	case "Query.connectorService":
		if e.complexity.Query.ConnectorService == nil {
			break
		}

		args, err := field_Query_connectorService_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ConnectorService(childComplexity, args["application"].(string)), true

	case "Query.namespaces":
		if e.complexity.Query.Namespaces == nil {
			break
		}

		args, err := field_Query_namespaces_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Namespaces(childComplexity, args["application"].(*string)), true

	case "Query.deployments":
		if e.complexity.Query.Deployments == nil {
			break
		}

		args, err := field_Query_deployments_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Deployments(childComplexity, args["namespace"].(string), args["excludeFunctions"].(*bool)), true

	case "Query.pod":
		if e.complexity.Query.Pod == nil {
			break
		}

		args, err := field_Query_pod_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Pod(childComplexity, args["name"].(string), args["namespace"].(string)), true

	case "Query.pods":
		if e.complexity.Query.Pods == nil {
			break
		}

		args, err := field_Query_pods_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Pods(childComplexity, args["namespace"].(string), args["first"].(*int), args["offset"].(*int)), true

	case "Query.service":
		if e.complexity.Query.Service == nil {
			break
		}

		args, err := field_Query_service_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Service(childComplexity, args["name"].(string), args["namespace"].(string)), true

	case "Query.services":
		if e.complexity.Query.Services == nil {
			break
		}

		args, err := field_Query_services_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Services(childComplexity, args["namespace"].(string), args["first"].(*int), args["offset"].(*int)), true

	case "Query.configMap":
		if e.complexity.Query.ConfigMap == nil {
			break
		}

		args, err := field_Query_configMap_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ConfigMap(childComplexity, args["name"].(string), args["namespace"].(string)), true

	case "Query.configMaps":
		if e.complexity.Query.ConfigMaps == nil {
			break
		}

		args, err := field_Query_configMaps_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ConfigMaps(childComplexity, args["namespace"].(string), args["first"].(*int), args["offset"].(*int)), true

	case "Query.replicaSet":
		if e.complexity.Query.ReplicaSet == nil {
			break
		}

		args, err := field_Query_replicaSet_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ReplicaSet(childComplexity, args["name"].(string), args["namespace"].(string)), true

	case "Query.replicaSets":
		if e.complexity.Query.ReplicaSets == nil {
			break
		}

		args, err := field_Query_replicaSets_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ReplicaSets(childComplexity, args["namespace"].(string), args["first"].(*int), args["offset"].(*int)), true

	case "Query.resourceQuotas":
		if e.complexity.Query.ResourceQuotas == nil {
			break
		}

		args, err := field_Query_resourceQuotas_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ResourceQuotas(childComplexity, args["namespace"].(string)), true

	case "Query.resourceQuotasStatus":
		if e.complexity.Query.ResourceQuotasStatus == nil {
			break
		}

		args, err := field_Query_resourceQuotasStatus_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ResourceQuotasStatus(childComplexity, args["namespace"].(string)), true

	case "Query.functions":
		if e.complexity.Query.Functions == nil {
			break
		}

		args, err := field_Query_functions_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Functions(childComplexity, args["namespace"].(string), args["first"].(*int), args["offset"].(*int)), true

	case "Query.content":
		if e.complexity.Query.Content == nil {
			break
		}

		args, err := field_Query_content_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Content(childComplexity, args["contentType"].(string), args["id"].(string)), true

	case "Query.topics":
		if e.complexity.Query.Topics == nil {
			break
		}

		args, err := field_Query_topics_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Topics(childComplexity, args["input"].([]InputTopic), args["internal"].(*bool)), true

	case "Query.eventActivations":
		if e.complexity.Query.EventActivations == nil {
			break
		}

		args, err := field_Query_eventActivations_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.EventActivations(childComplexity, args["namespace"].(string)), true

	case "Query.limitRanges":
		if e.complexity.Query.LimitRanges == nil {
			break
		}

		args, err := field_Query_limitRanges_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.LimitRanges(childComplexity, args["namespace"].(string)), true

	case "Query.backendModules":
		if e.complexity.Query.BackendModules == nil {
			break
		}

		return e.complexity.Query.BackendModules(childComplexity), true

	case "Query.secret":
		if e.complexity.Query.Secret == nil {
			break
		}

		args, err := field_Query_secret_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Secret(childComplexity, args["name"].(string), args["namespace"].(string)), true

	case "Query.secrets":
		if e.complexity.Query.Secrets == nil {
			break
		}

		args, err := field_Query_secrets_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Secrets(childComplexity, args["namespace"].(string), args["first"].(*int), args["offset"].(*int)), true

	case "Query.IDPPreset":
		if e.complexity.Query.Idppreset == nil {
			break
		}

		args, err := field_Query_IDPPreset_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Idppreset(childComplexity, args["name"].(string)), true

	case "Query.IDPPresets":
		if e.complexity.Query.Idppresets == nil {
			break
		}

		args, err := field_Query_IDPPresets_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Idppresets(childComplexity, args["first"].(*int), args["offset"].(*int)), true

	case "Query.selfSubjectRules":
		if e.complexity.Query.SelfSubjectRules == nil {
			break
		}

		args, err := field_Query_selfSubjectRules_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SelfSubjectRules(childComplexity, args["namespace"].(*string)), true

	case "ReplicaSet.name":
		if e.complexity.ReplicaSet.Name == nil {
			break
		}

		return e.complexity.ReplicaSet.Name(childComplexity), true

	case "ReplicaSet.pods":
		if e.complexity.ReplicaSet.Pods == nil {
			break
		}

		return e.complexity.ReplicaSet.Pods(childComplexity), true

	case "ReplicaSet.namespace":
		if e.complexity.ReplicaSet.Namespace == nil {
			break
		}

		return e.complexity.ReplicaSet.Namespace(childComplexity), true

	case "ReplicaSet.images":
		if e.complexity.ReplicaSet.Images == nil {
			break
		}

		return e.complexity.ReplicaSet.Images(childComplexity), true

	case "ReplicaSet.creationTimestamp":
		if e.complexity.ReplicaSet.CreationTimestamp == nil {
			break
		}

		return e.complexity.ReplicaSet.CreationTimestamp(childComplexity), true

	case "ReplicaSet.labels":
		if e.complexity.ReplicaSet.Labels == nil {
			break
		}

		return e.complexity.ReplicaSet.Labels(childComplexity), true

	case "ReplicaSet.json":
		if e.complexity.ReplicaSet.Json == nil {
			break
		}

		return e.complexity.ReplicaSet.Json(childComplexity), true

	case "ResourceQuota.name":
		if e.complexity.ResourceQuota.Name == nil {
			break
		}

		return e.complexity.ResourceQuota.Name(childComplexity), true

	case "ResourceQuota.pods":
		if e.complexity.ResourceQuota.Pods == nil {
			break
		}

		return e.complexity.ResourceQuota.Pods(childComplexity), true

	case "ResourceQuota.limits":
		if e.complexity.ResourceQuota.Limits == nil {
			break
		}

		return e.complexity.ResourceQuota.Limits(childComplexity), true

	case "ResourceQuota.requests":
		if e.complexity.ResourceQuota.Requests == nil {
			break
		}

		return e.complexity.ResourceQuota.Requests(childComplexity), true

	case "ResourceQuotasStatus.exceeded":
		if e.complexity.ResourceQuotasStatus.Exceeded == nil {
			break
		}

		return e.complexity.ResourceQuotasStatus.Exceeded(childComplexity), true

	case "ResourceQuotasStatus.exceededQuotas":
		if e.complexity.ResourceQuotasStatus.ExceededQuotas == nil {
			break
		}

		return e.complexity.ResourceQuotasStatus.ExceededQuotas(childComplexity), true

	case "ResourceRule.verbs":
		if e.complexity.ResourceRule.Verbs == nil {
			break
		}

		return e.complexity.ResourceRule.Verbs(childComplexity), true

	case "ResourceRule.apiGroups":
		if e.complexity.ResourceRule.ApiGroups == nil {
			break
		}

		return e.complexity.ResourceRule.ApiGroups(childComplexity), true

	case "ResourceRule.resources":
		if e.complexity.ResourceRule.Resources == nil {
			break
		}

		return e.complexity.ResourceRule.Resources(childComplexity), true

	case "ResourceType.memory":
		if e.complexity.ResourceType.Memory == nil {
			break
		}

		return e.complexity.ResourceType.Memory(childComplexity), true

	case "ResourceType.cpu":
		if e.complexity.ResourceType.Cpu == nil {
			break
		}

		return e.complexity.ResourceType.Cpu(childComplexity), true

	case "ResourceValues.memory":
		if e.complexity.ResourceValues.Memory == nil {
			break
		}

		return e.complexity.ResourceValues.Memory(childComplexity), true

	case "ResourceValues.cpu":
		if e.complexity.ResourceValues.Cpu == nil {
			break
		}

		return e.complexity.ResourceValues.Cpu(childComplexity), true

	case "Secret.name":
		if e.complexity.Secret.Name == nil {
			break
		}

		return e.complexity.Secret.Name(childComplexity), true

	case "Secret.namespace":
		if e.complexity.Secret.Namespace == nil {
			break
		}

		return e.complexity.Secret.Namespace(childComplexity), true

	case "Secret.data":
		if e.complexity.Secret.Data == nil {
			break
		}

		return e.complexity.Secret.Data(childComplexity), true

	case "Secret.type":
		if e.complexity.Secret.Type == nil {
			break
		}

		return e.complexity.Secret.Type(childComplexity), true

	case "Secret.creationTime":
		if e.complexity.Secret.CreationTime == nil {
			break
		}

		return e.complexity.Secret.CreationTime(childComplexity), true

	case "Secret.labels":
		if e.complexity.Secret.Labels == nil {
			break
		}

		return e.complexity.Secret.Labels(childComplexity), true

	case "Secret.annotations":
		if e.complexity.Secret.Annotations == nil {
			break
		}

		return e.complexity.Secret.Annotations(childComplexity), true

	case "Secret.json":
		if e.complexity.Secret.Json == nil {
			break
		}

		return e.complexity.Secret.Json(childComplexity), true

	case "SecretEvent.type":
		if e.complexity.SecretEvent.Type == nil {
			break
		}

		return e.complexity.SecretEvent.Type(childComplexity), true

	case "SecretEvent.secret":
		if e.complexity.SecretEvent.Secret == nil {
			break
		}

		return e.complexity.SecretEvent.Secret(childComplexity), true

	case "Section.name":
		if e.complexity.Section.Name == nil {
			break
		}

		return e.complexity.Section.Name(childComplexity), true

	case "Section.anchor":
		if e.complexity.Section.Anchor == nil {
			break
		}

		return e.complexity.Section.Anchor(childComplexity), true

	case "Section.titles":
		if e.complexity.Section.Titles == nil {
			break
		}

		return e.complexity.Section.Titles(childComplexity), true

	case "Section.topicType":
		if e.complexity.Section.TopicType == nil {
			break
		}

		return e.complexity.Section.TopicType(childComplexity), true

	case "Service.name":
		if e.complexity.Service.Name == nil {
			break
		}

		return e.complexity.Service.Name(childComplexity), true

	case "Service.clusterIP":
		if e.complexity.Service.ClusterIp == nil {
			break
		}

		return e.complexity.Service.ClusterIp(childComplexity), true

	case "Service.creationTimestamp":
		if e.complexity.Service.CreationTimestamp == nil {
			break
		}

		return e.complexity.Service.CreationTimestamp(childComplexity), true

	case "Service.labels":
		if e.complexity.Service.Labels == nil {
			break
		}

		return e.complexity.Service.Labels(childComplexity), true

	case "Service.ports":
		if e.complexity.Service.Ports == nil {
			break
		}

		return e.complexity.Service.Ports(childComplexity), true

	case "Service.status":
		if e.complexity.Service.Status == nil {
			break
		}

		return e.complexity.Service.Status(childComplexity), true

	case "Service.json":
		if e.complexity.Service.Json == nil {
			break
		}

		return e.complexity.Service.Json(childComplexity), true

	case "ServiceBinding.name":
		if e.complexity.ServiceBinding.Name == nil {
			break
		}

		return e.complexity.ServiceBinding.Name(childComplexity), true

	case "ServiceBinding.serviceInstanceName":
		if e.complexity.ServiceBinding.ServiceInstanceName == nil {
			break
		}

		return e.complexity.ServiceBinding.ServiceInstanceName(childComplexity), true

	case "ServiceBinding.namespace":
		if e.complexity.ServiceBinding.Namespace == nil {
			break
		}

		return e.complexity.ServiceBinding.Namespace(childComplexity), true

	case "ServiceBinding.secret":
		if e.complexity.ServiceBinding.Secret == nil {
			break
		}

		return e.complexity.ServiceBinding.Secret(childComplexity), true

	case "ServiceBinding.status":
		if e.complexity.ServiceBinding.Status == nil {
			break
		}

		return e.complexity.ServiceBinding.Status(childComplexity), true

	case "ServiceBinding.parameters":
		if e.complexity.ServiceBinding.Parameters == nil {
			break
		}

		return e.complexity.ServiceBinding.Parameters(childComplexity), true

	case "ServiceBindingEvent.type":
		if e.complexity.ServiceBindingEvent.Type == nil {
			break
		}

		return e.complexity.ServiceBindingEvent.Type(childComplexity), true

	case "ServiceBindingEvent.serviceBinding":
		if e.complexity.ServiceBindingEvent.ServiceBinding == nil {
			break
		}

		return e.complexity.ServiceBindingEvent.ServiceBinding(childComplexity), true

	case "ServiceBindingStatus.type":
		if e.complexity.ServiceBindingStatus.Type == nil {
			break
		}

		return e.complexity.ServiceBindingStatus.Type(childComplexity), true

	case "ServiceBindingStatus.reason":
		if e.complexity.ServiceBindingStatus.Reason == nil {
			break
		}

		return e.complexity.ServiceBindingStatus.Reason(childComplexity), true

	case "ServiceBindingStatus.message":
		if e.complexity.ServiceBindingStatus.Message == nil {
			break
		}

		return e.complexity.ServiceBindingStatus.Message(childComplexity), true

	case "ServiceBindingUsage.name":
		if e.complexity.ServiceBindingUsage.Name == nil {
			break
		}

		return e.complexity.ServiceBindingUsage.Name(childComplexity), true

	case "ServiceBindingUsage.namespace":
		if e.complexity.ServiceBindingUsage.Namespace == nil {
			break
		}

		return e.complexity.ServiceBindingUsage.Namespace(childComplexity), true

	case "ServiceBindingUsage.serviceBinding":
		if e.complexity.ServiceBindingUsage.ServiceBinding == nil {
			break
		}

		return e.complexity.ServiceBindingUsage.ServiceBinding(childComplexity), true

	case "ServiceBindingUsage.usedBy":
		if e.complexity.ServiceBindingUsage.UsedBy == nil {
			break
		}

		return e.complexity.ServiceBindingUsage.UsedBy(childComplexity), true

	case "ServiceBindingUsage.parameters":
		if e.complexity.ServiceBindingUsage.Parameters == nil {
			break
		}

		return e.complexity.ServiceBindingUsage.Parameters(childComplexity), true

	case "ServiceBindingUsage.status":
		if e.complexity.ServiceBindingUsage.Status == nil {
			break
		}

		return e.complexity.ServiceBindingUsage.Status(childComplexity), true

	case "ServiceBindingUsageEvent.type":
		if e.complexity.ServiceBindingUsageEvent.Type == nil {
			break
		}

		return e.complexity.ServiceBindingUsageEvent.Type(childComplexity), true

	case "ServiceBindingUsageEvent.serviceBindingUsage":
		if e.complexity.ServiceBindingUsageEvent.ServiceBindingUsage == nil {
			break
		}

		return e.complexity.ServiceBindingUsageEvent.ServiceBindingUsage(childComplexity), true

	case "ServiceBindingUsageParameters.envPrefix":
		if e.complexity.ServiceBindingUsageParameters.EnvPrefix == nil {
			break
		}

		return e.complexity.ServiceBindingUsageParameters.EnvPrefix(childComplexity), true

	case "ServiceBindingUsageStatus.type":
		if e.complexity.ServiceBindingUsageStatus.Type == nil {
			break
		}

		return e.complexity.ServiceBindingUsageStatus.Type(childComplexity), true

	case "ServiceBindingUsageStatus.reason":
		if e.complexity.ServiceBindingUsageStatus.Reason == nil {
			break
		}

		return e.complexity.ServiceBindingUsageStatus.Reason(childComplexity), true

	case "ServiceBindingUsageStatus.message":
		if e.complexity.ServiceBindingUsageStatus.Message == nil {
			break
		}

		return e.complexity.ServiceBindingUsageStatus.Message(childComplexity), true

	case "ServiceBindings.items":
		if e.complexity.ServiceBindings.Items == nil {
			break
		}

		return e.complexity.ServiceBindings.Items(childComplexity), true

	case "ServiceBindings.stats":
		if e.complexity.ServiceBindings.Stats == nil {
			break
		}

		return e.complexity.ServiceBindings.Stats(childComplexity), true

	case "ServiceBindingsStats.ready":
		if e.complexity.ServiceBindingsStats.Ready == nil {
			break
		}

		return e.complexity.ServiceBindingsStats.Ready(childComplexity), true

	case "ServiceBindingsStats.failed":
		if e.complexity.ServiceBindingsStats.Failed == nil {
			break
		}

		return e.complexity.ServiceBindingsStats.Failed(childComplexity), true

	case "ServiceBindingsStats.pending":
		if e.complexity.ServiceBindingsStats.Pending == nil {
			break
		}

		return e.complexity.ServiceBindingsStats.Pending(childComplexity), true

	case "ServiceBindingsStats.unknown":
		if e.complexity.ServiceBindingsStats.Unknown == nil {
			break
		}

		return e.complexity.ServiceBindingsStats.Unknown(childComplexity), true

	case "ServiceBroker.name":
		if e.complexity.ServiceBroker.Name == nil {
			break
		}

		return e.complexity.ServiceBroker.Name(childComplexity), true

	case "ServiceBroker.namespace":
		if e.complexity.ServiceBroker.Namespace == nil {
			break
		}

		return e.complexity.ServiceBroker.Namespace(childComplexity), true

	case "ServiceBroker.status":
		if e.complexity.ServiceBroker.Status == nil {
			break
		}

		return e.complexity.ServiceBroker.Status(childComplexity), true

	case "ServiceBroker.creationTimestamp":
		if e.complexity.ServiceBroker.CreationTimestamp == nil {
			break
		}

		return e.complexity.ServiceBroker.CreationTimestamp(childComplexity), true

	case "ServiceBroker.url":
		if e.complexity.ServiceBroker.Url == nil {
			break
		}

		return e.complexity.ServiceBroker.Url(childComplexity), true

	case "ServiceBroker.labels":
		if e.complexity.ServiceBroker.Labels == nil {
			break
		}

		return e.complexity.ServiceBroker.Labels(childComplexity), true

	case "ServiceBrokerEvent.type":
		if e.complexity.ServiceBrokerEvent.Type == nil {
			break
		}

		return e.complexity.ServiceBrokerEvent.Type(childComplexity), true

	case "ServiceBrokerEvent.serviceBroker":
		if e.complexity.ServiceBrokerEvent.ServiceBroker == nil {
			break
		}

		return e.complexity.ServiceBrokerEvent.ServiceBroker(childComplexity), true

	case "ServiceBrokerStatus.ready":
		if e.complexity.ServiceBrokerStatus.Ready == nil {
			break
		}

		return e.complexity.ServiceBrokerStatus.Ready(childComplexity), true

	case "ServiceBrokerStatus.reason":
		if e.complexity.ServiceBrokerStatus.Reason == nil {
			break
		}

		return e.complexity.ServiceBrokerStatus.Reason(childComplexity), true

	case "ServiceBrokerStatus.message":
		if e.complexity.ServiceBrokerStatus.Message == nil {
			break
		}

		return e.complexity.ServiceBrokerStatus.Message(childComplexity), true

	case "ServiceClass.name":
		if e.complexity.ServiceClass.Name == nil {
			break
		}

		return e.complexity.ServiceClass.Name(childComplexity), true

	case "ServiceClass.namespace":
		if e.complexity.ServiceClass.Namespace == nil {
			break
		}

		return e.complexity.ServiceClass.Namespace(childComplexity), true

	case "ServiceClass.externalName":
		if e.complexity.ServiceClass.ExternalName == nil {
			break
		}

		return e.complexity.ServiceClass.ExternalName(childComplexity), true

	case "ServiceClass.displayName":
		if e.complexity.ServiceClass.DisplayName == nil {
			break
		}

		return e.complexity.ServiceClass.DisplayName(childComplexity), true

	case "ServiceClass.creationTimestamp":
		if e.complexity.ServiceClass.CreationTimestamp == nil {
			break
		}

		return e.complexity.ServiceClass.CreationTimestamp(childComplexity), true

	case "ServiceClass.description":
		if e.complexity.ServiceClass.Description == nil {
			break
		}

		return e.complexity.ServiceClass.Description(childComplexity), true

	case "ServiceClass.longDescription":
		if e.complexity.ServiceClass.LongDescription == nil {
			break
		}

		return e.complexity.ServiceClass.LongDescription(childComplexity), true

	case "ServiceClass.imageUrl":
		if e.complexity.ServiceClass.ImageUrl == nil {
			break
		}

		return e.complexity.ServiceClass.ImageUrl(childComplexity), true

	case "ServiceClass.documentationUrl":
		if e.complexity.ServiceClass.DocumentationUrl == nil {
			break
		}

		return e.complexity.ServiceClass.DocumentationUrl(childComplexity), true

	case "ServiceClass.supportUrl":
		if e.complexity.ServiceClass.SupportUrl == nil {
			break
		}

		return e.complexity.ServiceClass.SupportUrl(childComplexity), true

	case "ServiceClass.providerDisplayName":
		if e.complexity.ServiceClass.ProviderDisplayName == nil {
			break
		}

		return e.complexity.ServiceClass.ProviderDisplayName(childComplexity), true

	case "ServiceClass.tags":
		if e.complexity.ServiceClass.Tags == nil {
			break
		}

		return e.complexity.ServiceClass.Tags(childComplexity), true

	case "ServiceClass.labels":
		if e.complexity.ServiceClass.Labels == nil {
			break
		}

		return e.complexity.ServiceClass.Labels(childComplexity), true

	case "ServiceClass.plans":
		if e.complexity.ServiceClass.Plans == nil {
			break
		}

		return e.complexity.ServiceClass.Plans(childComplexity), true

	case "ServiceClass.activated":
		if e.complexity.ServiceClass.Activated == nil {
			break
		}

		return e.complexity.ServiceClass.Activated(childComplexity), true

	case "ServiceClass.instances":
		if e.complexity.ServiceClass.Instances == nil {
			break
		}

		return e.complexity.ServiceClass.Instances(childComplexity), true

	case "ServiceClass.apiSpec":
		if e.complexity.ServiceClass.ApiSpec == nil {
			break
		}

		return e.complexity.ServiceClass.ApiSpec(childComplexity), true

	case "ServiceClass.openApiSpec":
		if e.complexity.ServiceClass.OpenApiSpec == nil {
			break
		}

		return e.complexity.ServiceClass.OpenApiSpec(childComplexity), true

	case "ServiceClass.odataSpec":
		if e.complexity.ServiceClass.OdataSpec == nil {
			break
		}

		return e.complexity.ServiceClass.OdataSpec(childComplexity), true

	case "ServiceClass.asyncApiSpec":
		if e.complexity.ServiceClass.AsyncApiSpec == nil {
			break
		}

		return e.complexity.ServiceClass.AsyncApiSpec(childComplexity), true

	case "ServiceClass.content":
		if e.complexity.ServiceClass.Content == nil {
			break
		}

		return e.complexity.ServiceClass.Content(childComplexity), true

	case "ServiceClass.clusterDocsTopic":
		if e.complexity.ServiceClass.ClusterDocsTopic == nil {
			break
		}

		return e.complexity.ServiceClass.ClusterDocsTopic(childComplexity), true

	case "ServiceClass.docsTopic":
		if e.complexity.ServiceClass.DocsTopic == nil {
			break
		}

		return e.complexity.ServiceClass.DocsTopic(childComplexity), true

	case "ServiceEvent.type":
		if e.complexity.ServiceEvent.Type == nil {
			break
		}

		return e.complexity.ServiceEvent.Type(childComplexity), true

	case "ServiceEvent.service":
		if e.complexity.ServiceEvent.Service == nil {
			break
		}

		return e.complexity.ServiceEvent.Service(childComplexity), true

	case "ServiceInstance.name":
		if e.complexity.ServiceInstance.Name == nil {
			break
		}

		return e.complexity.ServiceInstance.Name(childComplexity), true

	case "ServiceInstance.namespace":
		if e.complexity.ServiceInstance.Namespace == nil {
			break
		}

		return e.complexity.ServiceInstance.Namespace(childComplexity), true

	case "ServiceInstance.planSpec":
		if e.complexity.ServiceInstance.PlanSpec == nil {
			break
		}

		return e.complexity.ServiceInstance.PlanSpec(childComplexity), true

	case "ServiceInstance.creationTimestamp":
		if e.complexity.ServiceInstance.CreationTimestamp == nil {
			break
		}

		return e.complexity.ServiceInstance.CreationTimestamp(childComplexity), true

	case "ServiceInstance.labels":
		if e.complexity.ServiceInstance.Labels == nil {
			break
		}

		return e.complexity.ServiceInstance.Labels(childComplexity), true

	case "ServiceInstance.status":
		if e.complexity.ServiceInstance.Status == nil {
			break
		}

		return e.complexity.ServiceInstance.Status(childComplexity), true

	case "ServiceInstance.classReference":
		if e.complexity.ServiceInstance.ClassReference == nil {
			break
		}

		return e.complexity.ServiceInstance.ClassReference(childComplexity), true

	case "ServiceInstance.planReference":
		if e.complexity.ServiceInstance.PlanReference == nil {
			break
		}

		return e.complexity.ServiceInstance.PlanReference(childComplexity), true

	case "ServiceInstance.serviceClass":
		if e.complexity.ServiceInstance.ServiceClass == nil {
			break
		}

		return e.complexity.ServiceInstance.ServiceClass(childComplexity), true

	case "ServiceInstance.clusterServiceClass":
		if e.complexity.ServiceInstance.ClusterServiceClass == nil {
			break
		}

		return e.complexity.ServiceInstance.ClusterServiceClass(childComplexity), true

	case "ServiceInstance.servicePlan":
		if e.complexity.ServiceInstance.ServicePlan == nil {
			break
		}

		return e.complexity.ServiceInstance.ServicePlan(childComplexity), true

	case "ServiceInstance.clusterServicePlan":
		if e.complexity.ServiceInstance.ClusterServicePlan == nil {
			break
		}

		return e.complexity.ServiceInstance.ClusterServicePlan(childComplexity), true

	case "ServiceInstance.bindable":
		if e.complexity.ServiceInstance.Bindable == nil {
			break
		}

		return e.complexity.ServiceInstance.Bindable(childComplexity), true

	case "ServiceInstance.serviceBindings":
		if e.complexity.ServiceInstance.ServiceBindings == nil {
			break
		}

		return e.complexity.ServiceInstance.ServiceBindings(childComplexity), true

	case "ServiceInstance.serviceBindingUsages":
		if e.complexity.ServiceInstance.ServiceBindingUsages == nil {
			break
		}

		return e.complexity.ServiceInstance.ServiceBindingUsages(childComplexity), true

	case "ServiceInstanceEvent.type":
		if e.complexity.ServiceInstanceEvent.Type == nil {
			break
		}

		return e.complexity.ServiceInstanceEvent.Type(childComplexity), true

	case "ServiceInstanceEvent.serviceInstance":
		if e.complexity.ServiceInstanceEvent.ServiceInstance == nil {
			break
		}

		return e.complexity.ServiceInstanceEvent.ServiceInstance(childComplexity), true

	case "ServiceInstanceResourceRef.name":
		if e.complexity.ServiceInstanceResourceRef.Name == nil {
			break
		}

		return e.complexity.ServiceInstanceResourceRef.Name(childComplexity), true

	case "ServiceInstanceResourceRef.displayName":
		if e.complexity.ServiceInstanceResourceRef.DisplayName == nil {
			break
		}

		return e.complexity.ServiceInstanceResourceRef.DisplayName(childComplexity), true

	case "ServiceInstanceResourceRef.clusterWide":
		if e.complexity.ServiceInstanceResourceRef.ClusterWide == nil {
			break
		}

		return e.complexity.ServiceInstanceResourceRef.ClusterWide(childComplexity), true

	case "ServiceInstanceStatus.type":
		if e.complexity.ServiceInstanceStatus.Type == nil {
			break
		}

		return e.complexity.ServiceInstanceStatus.Type(childComplexity), true

	case "ServiceInstanceStatus.reason":
		if e.complexity.ServiceInstanceStatus.Reason == nil {
			break
		}

		return e.complexity.ServiceInstanceStatus.Reason(childComplexity), true

	case "ServiceInstanceStatus.message":
		if e.complexity.ServiceInstanceStatus.Message == nil {
			break
		}

		return e.complexity.ServiceInstanceStatus.Message(childComplexity), true

	case "ServicePlan.name":
		if e.complexity.ServicePlan.Name == nil {
			break
		}

		return e.complexity.ServicePlan.Name(childComplexity), true

	case "ServicePlan.namespace":
		if e.complexity.ServicePlan.Namespace == nil {
			break
		}

		return e.complexity.ServicePlan.Namespace(childComplexity), true

	case "ServicePlan.displayName":
		if e.complexity.ServicePlan.DisplayName == nil {
			break
		}

		return e.complexity.ServicePlan.DisplayName(childComplexity), true

	case "ServicePlan.externalName":
		if e.complexity.ServicePlan.ExternalName == nil {
			break
		}

		return e.complexity.ServicePlan.ExternalName(childComplexity), true

	case "ServicePlan.description":
		if e.complexity.ServicePlan.Description == nil {
			break
		}

		return e.complexity.ServicePlan.Description(childComplexity), true

	case "ServicePlan.relatedServiceClassName":
		if e.complexity.ServicePlan.RelatedServiceClassName == nil {
			break
		}

		return e.complexity.ServicePlan.RelatedServiceClassName(childComplexity), true

	case "ServicePlan.instanceCreateParameterSchema":
		if e.complexity.ServicePlan.InstanceCreateParameterSchema == nil {
			break
		}

		return e.complexity.ServicePlan.InstanceCreateParameterSchema(childComplexity), true

	case "ServicePlan.bindingCreateParameterSchema":
		if e.complexity.ServicePlan.BindingCreateParameterSchema == nil {
			break
		}

		return e.complexity.ServicePlan.BindingCreateParameterSchema(childComplexity), true

	case "ServicePort.name":
		if e.complexity.ServicePort.Name == nil {
			break
		}

		return e.complexity.ServicePort.Name(childComplexity), true

	case "ServicePort.serviceProtocol":
		if e.complexity.ServicePort.ServiceProtocol == nil {
			break
		}

		return e.complexity.ServicePort.ServiceProtocol(childComplexity), true

	case "ServicePort.port":
		if e.complexity.ServicePort.Port == nil {
			break
		}

		return e.complexity.ServicePort.Port(childComplexity), true

	case "ServicePort.nodePort":
		if e.complexity.ServicePort.NodePort == nil {
			break
		}

		return e.complexity.ServicePort.NodePort(childComplexity), true

	case "ServicePort.targetPort":
		if e.complexity.ServicePort.TargetPort == nil {
			break
		}

		return e.complexity.ServicePort.TargetPort(childComplexity), true

	case "ServiceStatus.loadBalancer":
		if e.complexity.ServiceStatus.LoadBalancer == nil {
			break
		}

		return e.complexity.ServiceStatus.LoadBalancer(childComplexity), true

	case "Subscription.clusterAssetEvent":
		if e.complexity.Subscription.ClusterAssetEvent == nil {
			break
		}

		return e.complexity.Subscription.ClusterAssetEvent(childComplexity), true

	case "Subscription.assetEvent":
		if e.complexity.Subscription.AssetEvent == nil {
			break
		}

		args, err := field_Subscription_assetEvent_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.AssetEvent(childComplexity, args["namespace"].(string)), true

	case "Subscription.clusterDocsTopicEvent":
		if e.complexity.Subscription.ClusterDocsTopicEvent == nil {
			break
		}

		return e.complexity.Subscription.ClusterDocsTopicEvent(childComplexity), true

	case "Subscription.docsTopicEvent":
		if e.complexity.Subscription.DocsTopicEvent == nil {
			break
		}

		args, err := field_Subscription_docsTopicEvent_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.DocsTopicEvent(childComplexity, args["namespace"].(string)), true

	case "Subscription.serviceInstanceEvent":
		if e.complexity.Subscription.ServiceInstanceEvent == nil {
			break
		}

		args, err := field_Subscription_serviceInstanceEvent_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.ServiceInstanceEvent(childComplexity, args["namespace"].(string)), true

	case "Subscription.serviceBindingEvent":
		if e.complexity.Subscription.ServiceBindingEvent == nil {
			break
		}

		args, err := field_Subscription_serviceBindingEvent_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.ServiceBindingEvent(childComplexity, args["namespace"].(string)), true

	case "Subscription.serviceBindingUsageEvent":
		if e.complexity.Subscription.ServiceBindingUsageEvent == nil {
			break
		}

		args, err := field_Subscription_serviceBindingUsageEvent_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.ServiceBindingUsageEvent(childComplexity, args["namespace"].(string)), true

	case "Subscription.serviceBrokerEvent":
		if e.complexity.Subscription.ServiceBrokerEvent == nil {
			break
		}

		args, err := field_Subscription_serviceBrokerEvent_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.ServiceBrokerEvent(childComplexity, args["namespace"].(string)), true

	case "Subscription.clusterServiceBrokerEvent":
		if e.complexity.Subscription.ClusterServiceBrokerEvent == nil {
			break
		}

		return e.complexity.Subscription.ClusterServiceBrokerEvent(childComplexity), true

	case "Subscription.applicationEvent":
		if e.complexity.Subscription.ApplicationEvent == nil {
			break
		}

		return e.complexity.Subscription.ApplicationEvent(childComplexity), true

	case "Subscription.podEvent":
		if e.complexity.Subscription.PodEvent == nil {
			break
		}

		args, err := field_Subscription_podEvent_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.PodEvent(childComplexity, args["namespace"].(string)), true

	case "Subscription.serviceEvent":
		if e.complexity.Subscription.ServiceEvent == nil {
			break
		}

		args, err := field_Subscription_serviceEvent_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.ServiceEvent(childComplexity, args["namespace"].(string)), true

	case "Subscription.configMapEvent":
		if e.complexity.Subscription.ConfigMapEvent == nil {
			break
		}

		args, err := field_Subscription_configMapEvent_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.ConfigMapEvent(childComplexity, args["namespace"].(string)), true

	case "Subscription.addonsConfigurationEvent":
		if e.complexity.Subscription.AddonsConfigurationEvent == nil {
			break
		}

		return e.complexity.Subscription.AddonsConfigurationEvent(childComplexity), true

	case "Title.name":
		if e.complexity.Title.Name == nil {
			break
		}

		return e.complexity.Title.Name(childComplexity), true

	case "Title.anchor":
		if e.complexity.Title.Anchor == nil {
			break
		}

		return e.complexity.Title.Anchor(childComplexity), true

	case "Title.titles":
		if e.complexity.Title.Titles == nil {
			break
		}

		return e.complexity.Title.Titles(childComplexity), true

	case "TopicEntry.contentType":
		if e.complexity.TopicEntry.ContentType == nil {
			break
		}

		return e.complexity.TopicEntry.ContentType(childComplexity), true

	case "TopicEntry.id":
		if e.complexity.TopicEntry.Id == nil {
			break
		}

		return e.complexity.TopicEntry.Id(childComplexity), true

	case "TopicEntry.sections":
		if e.complexity.TopicEntry.Sections == nil {
			break
		}

		return e.complexity.TopicEntry.Sections(childComplexity), true

	case "UsageKind.name":
		if e.complexity.UsageKind.Name == nil {
			break
		}

		return e.complexity.UsageKind.Name(childComplexity), true

	case "UsageKind.group":
		if e.complexity.UsageKind.Group == nil {
			break
		}

		return e.complexity.UsageKind.Group(childComplexity), true

	case "UsageKind.kind":
		if e.complexity.UsageKind.Kind == nil {
			break
		}

		return e.complexity.UsageKind.Kind(childComplexity), true

	case "UsageKind.version":
		if e.complexity.UsageKind.Version == nil {
			break
		}

		return e.complexity.UsageKind.Version(childComplexity), true

	case "UsageKind.displayName":
		if e.complexity.UsageKind.DisplayName == nil {
			break
		}

		return e.complexity.UsageKind.DisplayName(childComplexity), true

	case "UsageKindResource.name":
		if e.complexity.UsageKindResource.Name == nil {
			break
		}

		return e.complexity.UsageKindResource.Name(childComplexity), true

	case "UsageKindResource.namespace":
		if e.complexity.UsageKindResource.Namespace == nil {
			break
		}

		return e.complexity.UsageKindResource.Namespace(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Query(ctx context.Context, op *ast.OperationDefinition) *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e}

	buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
		data := ec._Query(ctx, op.SelectionSet)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)
		return buf.Bytes()
	})

	return &graphql.Response{
		Data:       buf,
		Errors:     ec.Errors,
		Extensions: ec.Extensions}
}

func (e *executableSchema) Mutation(ctx context.Context, op *ast.OperationDefinition) *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e}

	buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
		data := ec._Mutation(ctx, op.SelectionSet)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)
		return buf.Bytes()
	})

	return &graphql.Response{
		Data:       buf,
		Errors:     ec.Errors,
		Extensions: ec.Extensions,
	}
}

func (e *executableSchema) Subscription(ctx context.Context, op *ast.OperationDefinition) func() *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e}

	next := ec._Subscription(ctx, op.SelectionSet)
	if ec.Errors != nil {
		return graphql.OneShot(&graphql.Response{Data: []byte("null"), Errors: ec.Errors})
	}

	var buf bytes.Buffer
	return func() *graphql.Response {
		buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
			buf.Reset()
			data := next()

			if data == nil {
				return nil
			}
			data.MarshalGQL(&buf)
			return buf.Bytes()
		})

		if buf == nil {
			return nil
		}

		return &graphql.Response{
			Data:       buf,
			Errors:     ec.Errors,
			Extensions: ec.Extensions,
		}
	}
}

type executionContext struct {
	*graphql.RequestContext
	*executableSchema
}

var aPIImplementors = []string{"API"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _API(ctx context.Context, sel ast.SelectionSet, obj *API) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, aPIImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("API")
		case "name":
			out.Values[i] = ec._API_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "hostname":
			out.Values[i] = ec._API_hostname(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "service":
			out.Values[i] = ec._API_service(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "authenticationPolicies":
			out.Values[i] = ec._API_authenticationPolicies(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _API_name(ctx context.Context, field graphql.CollectedField, obj *API) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "API",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _API_hostname(ctx context.Context, field graphql.CollectedField, obj *API) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "API",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hostname, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _API_service(ctx context.Context, field graphql.CollectedField, obj *API) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "API",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Service, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ApiService)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ApiService(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _API_authenticationPolicies(ctx context.Context, field graphql.CollectedField, obj *API) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "API",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthenticationPolicies, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]AuthenticationPolicy)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._AuthenticationPolicy(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var addonsConfigurationImplementors = []string{"AddonsConfiguration"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _AddonsConfiguration(ctx context.Context, sel ast.SelectionSet, obj *AddonsConfiguration) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, addonsConfigurationImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AddonsConfiguration")
		case "name":
			out.Values[i] = ec._AddonsConfiguration_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "urls":
			out.Values[i] = ec._AddonsConfiguration_urls(ctx, field, obj)
		case "labels":
			out.Values[i] = ec._AddonsConfiguration_labels(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _AddonsConfiguration_name(ctx context.Context, field graphql.CollectedField, obj *AddonsConfiguration) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AddonsConfiguration",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _AddonsConfiguration_urls(ctx context.Context, field graphql.CollectedField, obj *AddonsConfiguration) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AddonsConfiguration",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Urls, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return graphql.MarshalString(res[idx1])
		}()
	}

	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _AddonsConfiguration_labels(ctx context.Context, field graphql.CollectedField, obj *AddonsConfiguration) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AddonsConfiguration",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Labels)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

var addonsConfigurationEventImplementors = []string{"AddonsConfigurationEvent"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _AddonsConfigurationEvent(ctx context.Context, sel ast.SelectionSet, obj *AddonsConfigurationEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, addonsConfigurationEventImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AddonsConfigurationEvent")
		case "type":
			out.Values[i] = ec._AddonsConfigurationEvent_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "addonsConfiguration":
			out.Values[i] = ec._AddonsConfigurationEvent_addonsConfiguration(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _AddonsConfigurationEvent_type(ctx context.Context, field graphql.CollectedField, obj *AddonsConfigurationEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AddonsConfigurationEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SubscriptionEventType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _AddonsConfigurationEvent_addonsConfiguration(ctx context.Context, field graphql.CollectedField, obj *AddonsConfigurationEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AddonsConfigurationEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AddonsConfiguration, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(AddonsConfiguration)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._AddonsConfiguration(ctx, field.Selections, &res)
}

var apiServiceImplementors = []string{"ApiService"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ApiService(ctx context.Context, sel ast.SelectionSet, obj *ApiService) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, apiServiceImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApiService")
		case "name":
			out.Values[i] = ec._ApiService_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "port":
			out.Values[i] = ec._ApiService_port(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ApiService_name(ctx context.Context, field graphql.CollectedField, obj *ApiService) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ApiService",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ApiService_port(ctx context.Context, field graphql.CollectedField, obj *ApiService) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ApiService",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Port, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

var applicationImplementors = []string{"Application"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Application(ctx context.Context, sel ast.SelectionSet, obj *Application) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, applicationImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Application")
		case "name":
			out.Values[i] = ec._Application_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec._Application_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "labels":
			out.Values[i] = ec._Application_labels(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "services":
			out.Values[i] = ec._Application_services(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "enabledInNamespaces":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Application_enabledInNamespaces(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "status":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Application_status(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Application_name(ctx context.Context, field graphql.CollectedField, obj *Application) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Application",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Application_description(ctx context.Context, field graphql.CollectedField, obj *Application) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Application",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Application_labels(ctx context.Context, field graphql.CollectedField, obj *Application) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Application",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Labels)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _Application_services(ctx context.Context, field graphql.CollectedField, obj *Application) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Application",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Services, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]ApplicationService)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._ApplicationService(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Application_enabledInNamespaces(ctx context.Context, field graphql.CollectedField, obj *Application) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Application",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Application().EnabledInNamespaces(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return graphql.MarshalString(res[idx1])
		}()
	}

	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Application_status(ctx context.Context, field graphql.CollectedField, obj *Application) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Application",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Application().Status(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ApplicationStatus)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

var applicationEntryImplementors = []string{"ApplicationEntry"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ApplicationEntry(ctx context.Context, sel ast.SelectionSet, obj *ApplicationEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, applicationEntryImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationEntry")
		case "type":
			out.Values[i] = ec._ApplicationEntry_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "gatewayUrl":
			out.Values[i] = ec._ApplicationEntry_gatewayUrl(ctx, field, obj)
		case "accessLabel":
			out.Values[i] = ec._ApplicationEntry_accessLabel(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ApplicationEntry_type(ctx context.Context, field graphql.CollectedField, obj *ApplicationEntry) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ApplicationEntry",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ApplicationEntry_gatewayUrl(ctx context.Context, field graphql.CollectedField, obj *ApplicationEntry) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ApplicationEntry",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GatewayURL, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ApplicationEntry_accessLabel(ctx context.Context, field graphql.CollectedField, obj *ApplicationEntry) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ApplicationEntry",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccessLabel, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var applicationEventImplementors = []string{"ApplicationEvent"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ApplicationEvent(ctx context.Context, sel ast.SelectionSet, obj *ApplicationEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, applicationEventImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationEvent")
		case "type":
			out.Values[i] = ec._ApplicationEvent_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "application":
			out.Values[i] = ec._ApplicationEvent_application(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ApplicationEvent_type(ctx context.Context, field graphql.CollectedField, obj *ApplicationEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ApplicationEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SubscriptionEventType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _ApplicationEvent_application(ctx context.Context, field graphql.CollectedField, obj *ApplicationEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ApplicationEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Application, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Application)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Application(ctx, field.Selections, &res)
}

var applicationMappingImplementors = []string{"ApplicationMapping"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ApplicationMapping(ctx context.Context, sel ast.SelectionSet, obj *ApplicationMapping) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, applicationMappingImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationMapping")
		case "namespace":
			out.Values[i] = ec._ApplicationMapping_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "application":
			out.Values[i] = ec._ApplicationMapping_application(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ApplicationMapping_namespace(ctx context.Context, field graphql.CollectedField, obj *ApplicationMapping) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ApplicationMapping",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ApplicationMapping_application(ctx context.Context, field graphql.CollectedField, obj *ApplicationMapping) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ApplicationMapping",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Application, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var applicationMutationOutputImplementors = []string{"ApplicationMutationOutput"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ApplicationMutationOutput(ctx context.Context, sel ast.SelectionSet, obj *ApplicationMutationOutput) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, applicationMutationOutputImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationMutationOutput")
		case "name":
			out.Values[i] = ec._ApplicationMutationOutput_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec._ApplicationMutationOutput_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "labels":
			out.Values[i] = ec._ApplicationMutationOutput_labels(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ApplicationMutationOutput_name(ctx context.Context, field graphql.CollectedField, obj *ApplicationMutationOutput) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ApplicationMutationOutput",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ApplicationMutationOutput_description(ctx context.Context, field graphql.CollectedField, obj *ApplicationMutationOutput) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ApplicationMutationOutput",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ApplicationMutationOutput_labels(ctx context.Context, field graphql.CollectedField, obj *ApplicationMutationOutput) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ApplicationMutationOutput",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Labels)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

var applicationServiceImplementors = []string{"ApplicationService"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ApplicationService(ctx context.Context, sel ast.SelectionSet, obj *ApplicationService) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, applicationServiceImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationService")
		case "id":
			out.Values[i] = ec._ApplicationService_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "displayName":
			out.Values[i] = ec._ApplicationService_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "longDescription":
			out.Values[i] = ec._ApplicationService_longDescription(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "providerDisplayName":
			out.Values[i] = ec._ApplicationService_providerDisplayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "tags":
			out.Values[i] = ec._ApplicationService_tags(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "entries":
			out.Values[i] = ec._ApplicationService_entries(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ApplicationService_id(ctx context.Context, field graphql.CollectedField, obj *ApplicationService) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ApplicationService",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ApplicationService_displayName(ctx context.Context, field graphql.CollectedField, obj *ApplicationService) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ApplicationService",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ApplicationService_longDescription(ctx context.Context, field graphql.CollectedField, obj *ApplicationService) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ApplicationService",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LongDescription, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ApplicationService_providerDisplayName(ctx context.Context, field graphql.CollectedField, obj *ApplicationService) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ApplicationService",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProviderDisplayName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ApplicationService_tags(ctx context.Context, field graphql.CollectedField, obj *ApplicationService) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ApplicationService",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tags, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return graphql.MarshalString(res[idx1])
		}()
	}

	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _ApplicationService_entries(ctx context.Context, field graphql.CollectedField, obj *ApplicationService) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ApplicationService",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Entries, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]ApplicationEntry)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._ApplicationEntry(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var assetImplementors = []string{"Asset"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Asset(ctx context.Context, sel ast.SelectionSet, obj *Asset) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, assetImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Asset")
		case "name":
			out.Values[i] = ec._Asset_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "namespace":
			out.Values[i] = ec._Asset_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "type":
			out.Values[i] = ec._Asset_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "files":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Asset_files(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "status":
			out.Values[i] = ec._Asset_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Asset_name(ctx context.Context, field graphql.CollectedField, obj *Asset) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Asset",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Asset_namespace(ctx context.Context, field graphql.CollectedField, obj *Asset) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Asset",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Asset_type(ctx context.Context, field graphql.CollectedField, obj *Asset) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Asset",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Asset_files(ctx context.Context, field graphql.CollectedField, obj *Asset) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Asset_files_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Asset",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Asset().Files(rctx, obj, args["filterExtensions"].([]string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]File)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._File(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Asset_status(ctx context.Context, field graphql.CollectedField, obj *Asset) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Asset",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(AssetStatus)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._AssetStatus(ctx, field.Selections, &res)
}

var assetEventImplementors = []string{"AssetEvent"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _AssetEvent(ctx context.Context, sel ast.SelectionSet, obj *AssetEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, assetEventImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AssetEvent")
		case "type":
			out.Values[i] = ec._AssetEvent_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "asset":
			out.Values[i] = ec._AssetEvent_asset(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _AssetEvent_type(ctx context.Context, field graphql.CollectedField, obj *AssetEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AssetEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SubscriptionEventType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _AssetEvent_asset(ctx context.Context, field graphql.CollectedField, obj *AssetEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AssetEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Asset, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Asset)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Asset(ctx, field.Selections, &res)
}

var assetStatusImplementors = []string{"AssetStatus"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _AssetStatus(ctx context.Context, sel ast.SelectionSet, obj *AssetStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, assetStatusImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AssetStatus")
		case "phase":
			out.Values[i] = ec._AssetStatus_phase(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "reason":
			out.Values[i] = ec._AssetStatus_reason(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "message":
			out.Values[i] = ec._AssetStatus_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _AssetStatus_phase(ctx context.Context, field graphql.CollectedField, obj *AssetStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AssetStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Phase, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(AssetPhaseType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _AssetStatus_reason(ctx context.Context, field graphql.CollectedField, obj *AssetStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AssetStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reason, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _AssetStatus_message(ctx context.Context, field graphql.CollectedField, obj *AssetStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AssetStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var authenticationPolicyImplementors = []string{"AuthenticationPolicy"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _AuthenticationPolicy(ctx context.Context, sel ast.SelectionSet, obj *AuthenticationPolicy) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, authenticationPolicyImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AuthenticationPolicy")
		case "type":
			out.Values[i] = ec._AuthenticationPolicy_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "issuer":
			out.Values[i] = ec._AuthenticationPolicy_issuer(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "jwksURI":
			out.Values[i] = ec._AuthenticationPolicy_jwksURI(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _AuthenticationPolicy_type(ctx context.Context, field graphql.CollectedField, obj *AuthenticationPolicy) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AuthenticationPolicy",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(AuthenticationPolicyType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _AuthenticationPolicy_issuer(ctx context.Context, field graphql.CollectedField, obj *AuthenticationPolicy) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AuthenticationPolicy",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Issuer, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _AuthenticationPolicy_jwksURI(ctx context.Context, field graphql.CollectedField, obj *AuthenticationPolicy) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AuthenticationPolicy",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JwksURI, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var backendModuleImplementors = []string{"BackendModule"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _BackendModule(ctx context.Context, sel ast.SelectionSet, obj *BackendModule) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, backendModuleImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BackendModule")
		case "name":
			out.Values[i] = ec._BackendModule_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _BackendModule_name(ctx context.Context, field graphql.CollectedField, obj *BackendModule) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "BackendModule",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var bindableResourcesOutputItemImplementors = []string{"BindableResourcesOutputItem"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _BindableResourcesOutputItem(ctx context.Context, sel ast.SelectionSet, obj *BindableResourcesOutputItem) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, bindableResourcesOutputItemImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BindableResourcesOutputItem")
		case "kind":
			out.Values[i] = ec._BindableResourcesOutputItem_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "displayName":
			out.Values[i] = ec._BindableResourcesOutputItem_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "resources":
			out.Values[i] = ec._BindableResourcesOutputItem_resources(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _BindableResourcesOutputItem_kind(ctx context.Context, field graphql.CollectedField, obj *BindableResourcesOutputItem) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "BindableResourcesOutputItem",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _BindableResourcesOutputItem_displayName(ctx context.Context, field graphql.CollectedField, obj *BindableResourcesOutputItem) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "BindableResourcesOutputItem",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _BindableResourcesOutputItem_resources(ctx context.Context, field graphql.CollectedField, obj *BindableResourcesOutputItem) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "BindableResourcesOutputItem",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Resources, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]UsageKindResource)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._UsageKindResource(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var clusterAssetImplementors = []string{"ClusterAsset"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ClusterAsset(ctx context.Context, sel ast.SelectionSet, obj *ClusterAsset) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, clusterAssetImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ClusterAsset")
		case "name":
			out.Values[i] = ec._ClusterAsset_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "type":
			out.Values[i] = ec._ClusterAsset_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "files":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ClusterAsset_files(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "status":
			out.Values[i] = ec._ClusterAsset_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ClusterAsset_name(ctx context.Context, field graphql.CollectedField, obj *ClusterAsset) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterAsset",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterAsset_type(ctx context.Context, field graphql.CollectedField, obj *ClusterAsset) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterAsset",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterAsset_files(ctx context.Context, field graphql.CollectedField, obj *ClusterAsset) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_ClusterAsset_files_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "ClusterAsset",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ClusterAsset().Files(rctx, obj, args["filterExtensions"].([]string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]File)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._File(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _ClusterAsset_status(ctx context.Context, field graphql.CollectedField, obj *ClusterAsset) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterAsset",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(AssetStatus)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._AssetStatus(ctx, field.Selections, &res)
}

var clusterAssetEventImplementors = []string{"ClusterAssetEvent"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ClusterAssetEvent(ctx context.Context, sel ast.SelectionSet, obj *ClusterAssetEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, clusterAssetEventImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ClusterAssetEvent")
		case "type":
			out.Values[i] = ec._ClusterAssetEvent_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "clusterAsset":
			out.Values[i] = ec._ClusterAssetEvent_clusterAsset(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ClusterAssetEvent_type(ctx context.Context, field graphql.CollectedField, obj *ClusterAssetEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterAssetEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SubscriptionEventType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _ClusterAssetEvent_clusterAsset(ctx context.Context, field graphql.CollectedField, obj *ClusterAssetEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterAssetEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClusterAsset, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ClusterAsset)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ClusterAsset(ctx, field.Selections, &res)
}

var clusterDocsTopicImplementors = []string{"ClusterDocsTopic"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ClusterDocsTopic(ctx context.Context, sel ast.SelectionSet, obj *ClusterDocsTopic) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, clusterDocsTopicImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ClusterDocsTopic")
		case "name":
			out.Values[i] = ec._ClusterDocsTopic_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "groupName":
			out.Values[i] = ec._ClusterDocsTopic_groupName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "assets":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ClusterDocsTopic_assets(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "displayName":
			out.Values[i] = ec._ClusterDocsTopic_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec._ClusterDocsTopic_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "status":
			out.Values[i] = ec._ClusterDocsTopic_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ClusterDocsTopic_name(ctx context.Context, field graphql.CollectedField, obj *ClusterDocsTopic) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterDocsTopic",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterDocsTopic_groupName(ctx context.Context, field graphql.CollectedField, obj *ClusterDocsTopic) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterDocsTopic",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GroupName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterDocsTopic_assets(ctx context.Context, field graphql.CollectedField, obj *ClusterDocsTopic) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_ClusterDocsTopic_assets_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "ClusterDocsTopic",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ClusterDocsTopic().Assets(rctx, obj, args["types"].([]string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]ClusterAsset)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._ClusterAsset(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _ClusterDocsTopic_displayName(ctx context.Context, field graphql.CollectedField, obj *ClusterDocsTopic) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterDocsTopic",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterDocsTopic_description(ctx context.Context, field graphql.CollectedField, obj *ClusterDocsTopic) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterDocsTopic",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterDocsTopic_status(ctx context.Context, field graphql.CollectedField, obj *ClusterDocsTopic) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterDocsTopic",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(DocsTopicStatus)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._DocsTopicStatus(ctx, field.Selections, &res)
}

var clusterDocsTopicEventImplementors = []string{"ClusterDocsTopicEvent"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ClusterDocsTopicEvent(ctx context.Context, sel ast.SelectionSet, obj *ClusterDocsTopicEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, clusterDocsTopicEventImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ClusterDocsTopicEvent")
		case "type":
			out.Values[i] = ec._ClusterDocsTopicEvent_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "clusterDocsTopic":
			out.Values[i] = ec._ClusterDocsTopicEvent_clusterDocsTopic(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ClusterDocsTopicEvent_type(ctx context.Context, field graphql.CollectedField, obj *ClusterDocsTopicEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterDocsTopicEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SubscriptionEventType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _ClusterDocsTopicEvent_clusterDocsTopic(ctx context.Context, field graphql.CollectedField, obj *ClusterDocsTopicEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterDocsTopicEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClusterDocsTopic, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ClusterDocsTopic)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ClusterDocsTopic(ctx, field.Selections, &res)
}

var clusterServiceBrokerImplementors = []string{"ClusterServiceBroker"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ClusterServiceBroker(ctx context.Context, sel ast.SelectionSet, obj *ClusterServiceBroker) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, clusterServiceBrokerImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ClusterServiceBroker")
		case "name":
			out.Values[i] = ec._ClusterServiceBroker_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "status":
			out.Values[i] = ec._ClusterServiceBroker_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "creationTimestamp":
			out.Values[i] = ec._ClusterServiceBroker_creationTimestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "url":
			out.Values[i] = ec._ClusterServiceBroker_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "labels":
			out.Values[i] = ec._ClusterServiceBroker_labels(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServiceBroker_name(ctx context.Context, field graphql.CollectedField, obj *ClusterServiceBroker) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServiceBroker",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServiceBroker_status(ctx context.Context, field graphql.CollectedField, obj *ClusterServiceBroker) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServiceBroker",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ServiceBrokerStatus)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ServiceBrokerStatus(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServiceBroker_creationTimestamp(ctx context.Context, field graphql.CollectedField, obj *ClusterServiceBroker) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServiceBroker",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTimestamp, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return MarshalTimestamp(res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServiceBroker_url(ctx context.Context, field graphql.CollectedField, obj *ClusterServiceBroker) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServiceBroker",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServiceBroker_labels(ctx context.Context, field graphql.CollectedField, obj *ClusterServiceBroker) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServiceBroker",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Labels)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

var clusterServiceBrokerEventImplementors = []string{"ClusterServiceBrokerEvent"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ClusterServiceBrokerEvent(ctx context.Context, sel ast.SelectionSet, obj *ClusterServiceBrokerEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, clusterServiceBrokerEventImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ClusterServiceBrokerEvent")
		case "type":
			out.Values[i] = ec._ClusterServiceBrokerEvent_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "clusterServiceBroker":
			out.Values[i] = ec._ClusterServiceBrokerEvent_clusterServiceBroker(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServiceBrokerEvent_type(ctx context.Context, field graphql.CollectedField, obj *ClusterServiceBrokerEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServiceBrokerEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SubscriptionEventType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServiceBrokerEvent_clusterServiceBroker(ctx context.Context, field graphql.CollectedField, obj *ClusterServiceBrokerEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServiceBrokerEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClusterServiceBroker, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ClusterServiceBroker)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ClusterServiceBroker(ctx, field.Selections, &res)
}

var clusterServiceClassImplementors = []string{"ClusterServiceClass"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ClusterServiceClass(ctx context.Context, sel ast.SelectionSet, obj *ClusterServiceClass) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, clusterServiceClassImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ClusterServiceClass")
		case "name":
			out.Values[i] = ec._ClusterServiceClass_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "externalName":
			out.Values[i] = ec._ClusterServiceClass_externalName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "displayName":
			out.Values[i] = ec._ClusterServiceClass_displayName(ctx, field, obj)
		case "creationTimestamp":
			out.Values[i] = ec._ClusterServiceClass_creationTimestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec._ClusterServiceClass_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "longDescription":
			out.Values[i] = ec._ClusterServiceClass_longDescription(ctx, field, obj)
		case "imageUrl":
			out.Values[i] = ec._ClusterServiceClass_imageUrl(ctx, field, obj)
		case "documentationUrl":
			out.Values[i] = ec._ClusterServiceClass_documentationUrl(ctx, field, obj)
		case "supportUrl":
			out.Values[i] = ec._ClusterServiceClass_supportUrl(ctx, field, obj)
		case "providerDisplayName":
			out.Values[i] = ec._ClusterServiceClass_providerDisplayName(ctx, field, obj)
		case "tags":
			out.Values[i] = ec._ClusterServiceClass_tags(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "labels":
			out.Values[i] = ec._ClusterServiceClass_labels(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "plans":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ClusterServiceClass_plans(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "activated":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ClusterServiceClass_activated(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "instances":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ClusterServiceClass_instances(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "apiSpec":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ClusterServiceClass_apiSpec(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "openApiSpec":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ClusterServiceClass_openApiSpec(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "odataSpec":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ClusterServiceClass_odataSpec(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "asyncApiSpec":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ClusterServiceClass_asyncApiSpec(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "content":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ClusterServiceClass_content(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "clusterDocsTopic":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ClusterServiceClass_clusterDocsTopic(ctx, field, obj)
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServiceClass_name(ctx context.Context, field graphql.CollectedField, obj *ClusterServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServiceClass_externalName(ctx context.Context, field graphql.CollectedField, obj *ClusterServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExternalName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServiceClass_displayName(ctx context.Context, field graphql.CollectedField, obj *ClusterServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServiceClass_creationTimestamp(ctx context.Context, field graphql.CollectedField, obj *ClusterServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTimestamp, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return MarshalTimestamp(res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServiceClass_description(ctx context.Context, field graphql.CollectedField, obj *ClusterServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServiceClass_longDescription(ctx context.Context, field graphql.CollectedField, obj *ClusterServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LongDescription, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServiceClass_imageUrl(ctx context.Context, field graphql.CollectedField, obj *ClusterServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImageURL, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServiceClass_documentationUrl(ctx context.Context, field graphql.CollectedField, obj *ClusterServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DocumentationURL, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServiceClass_supportUrl(ctx context.Context, field graphql.CollectedField, obj *ClusterServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SupportURL, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServiceClass_providerDisplayName(ctx context.Context, field graphql.CollectedField, obj *ClusterServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProviderDisplayName, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServiceClass_tags(ctx context.Context, field graphql.CollectedField, obj *ClusterServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tags, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return graphql.MarshalString(res[idx1])
		}()
	}

	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServiceClass_labels(ctx context.Context, field graphql.CollectedField, obj *ClusterServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Labels)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServiceClass_plans(ctx context.Context, field graphql.CollectedField, obj *ClusterServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ClusterServiceClass().Plans(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]ClusterServicePlan)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._ClusterServicePlan(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServiceClass_activated(ctx context.Context, field graphql.CollectedField, obj *ClusterServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_ClusterServiceClass_activated_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "ClusterServiceClass",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ClusterServiceClass().Activated(rctx, obj, args["namespace"].(*string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServiceClass_instances(ctx context.Context, field graphql.CollectedField, obj *ClusterServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_ClusterServiceClass_instances_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "ClusterServiceClass",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ClusterServiceClass().Instances(rctx, obj, args["namespace"].(*string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]ServiceInstance)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._ServiceInstance(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServiceClass_apiSpec(ctx context.Context, field graphql.CollectedField, obj *ClusterServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ClusterServiceClass().APISpec(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*JSON)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return *res
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServiceClass_openApiSpec(ctx context.Context, field graphql.CollectedField, obj *ClusterServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ClusterServiceClass().OpenAPISpec(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*JSON)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return *res
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServiceClass_odataSpec(ctx context.Context, field graphql.CollectedField, obj *ClusterServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ClusterServiceClass().OdataSpec(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServiceClass_asyncApiSpec(ctx context.Context, field graphql.CollectedField, obj *ClusterServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ClusterServiceClass().AsyncAPISpec(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*JSON)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return *res
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServiceClass_content(ctx context.Context, field graphql.CollectedField, obj *ClusterServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ClusterServiceClass().Content(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*JSON)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return *res
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServiceClass_clusterDocsTopic(ctx context.Context, field graphql.CollectedField, obj *ClusterServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ClusterServiceClass().ClusterDocsTopic(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ClusterDocsTopic)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ClusterDocsTopic(ctx, field.Selections, res)
}

var clusterServicePlanImplementors = []string{"ClusterServicePlan"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ClusterServicePlan(ctx context.Context, sel ast.SelectionSet, obj *ClusterServicePlan) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, clusterServicePlanImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ClusterServicePlan")
		case "name":
			out.Values[i] = ec._ClusterServicePlan_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "displayName":
			out.Values[i] = ec._ClusterServicePlan_displayName(ctx, field, obj)
		case "externalName":
			out.Values[i] = ec._ClusterServicePlan_externalName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec._ClusterServicePlan_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "relatedClusterServiceClassName":
			out.Values[i] = ec._ClusterServicePlan_relatedClusterServiceClassName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "instanceCreateParameterSchema":
			out.Values[i] = ec._ClusterServicePlan_instanceCreateParameterSchema(ctx, field, obj)
		case "bindingCreateParameterSchema":
			out.Values[i] = ec._ClusterServicePlan_bindingCreateParameterSchema(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServicePlan_name(ctx context.Context, field graphql.CollectedField, obj *ClusterServicePlan) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServicePlan",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServicePlan_displayName(ctx context.Context, field graphql.CollectedField, obj *ClusterServicePlan) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServicePlan",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServicePlan_externalName(ctx context.Context, field graphql.CollectedField, obj *ClusterServicePlan) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServicePlan",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExternalName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServicePlan_description(ctx context.Context, field graphql.CollectedField, obj *ClusterServicePlan) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServicePlan",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServicePlan_relatedClusterServiceClassName(ctx context.Context, field graphql.CollectedField, obj *ClusterServicePlan) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServicePlan",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RelatedClusterServiceClassName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServicePlan_instanceCreateParameterSchema(ctx context.Context, field graphql.CollectedField, obj *ClusterServicePlan) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServicePlan",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InstanceCreateParameterSchema, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*JSON)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return *res
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServicePlan_bindingCreateParameterSchema(ctx context.Context, field graphql.CollectedField, obj *ClusterServicePlan) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServicePlan",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BindingCreateParameterSchema, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*JSON)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return *res
}

var configMapImplementors = []string{"ConfigMap"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ConfigMap(ctx context.Context, sel ast.SelectionSet, obj *ConfigMap) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, configMapImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ConfigMap")
		case "name":
			out.Values[i] = ec._ConfigMap_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "namespace":
			out.Values[i] = ec._ConfigMap_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "creationTimestamp":
			out.Values[i] = ec._ConfigMap_creationTimestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "labels":
			out.Values[i] = ec._ConfigMap_labels(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "json":
			out.Values[i] = ec._ConfigMap_json(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ConfigMap_name(ctx context.Context, field graphql.CollectedField, obj *ConfigMap) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ConfigMap",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ConfigMap_namespace(ctx context.Context, field graphql.CollectedField, obj *ConfigMap) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ConfigMap",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ConfigMap_creationTimestamp(ctx context.Context, field graphql.CollectedField, obj *ConfigMap) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ConfigMap",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTimestamp, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return MarshalTimestamp(res)
}

// nolint: vetshadow
func (ec *executionContext) _ConfigMap_labels(ctx context.Context, field graphql.CollectedField, obj *ConfigMap) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ConfigMap",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Labels)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _ConfigMap_json(ctx context.Context, field graphql.CollectedField, obj *ConfigMap) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ConfigMap",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JSON, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(JSON)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

var configMapEventImplementors = []string{"ConfigMapEvent"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ConfigMapEvent(ctx context.Context, sel ast.SelectionSet, obj *ConfigMapEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, configMapEventImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ConfigMapEvent")
		case "type":
			out.Values[i] = ec._ConfigMapEvent_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "configMap":
			out.Values[i] = ec._ConfigMapEvent_configMap(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ConfigMapEvent_type(ctx context.Context, field graphql.CollectedField, obj *ConfigMapEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ConfigMapEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SubscriptionEventType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _ConfigMapEvent_configMap(ctx context.Context, field graphql.CollectedField, obj *ConfigMapEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ConfigMapEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConfigMap, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ConfigMap)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ConfigMap(ctx, field.Selections, &res)
}

var connectorServiceImplementors = []string{"ConnectorService"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ConnectorService(ctx context.Context, sel ast.SelectionSet, obj *ConnectorService) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, connectorServiceImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ConnectorService")
		case "url":
			out.Values[i] = ec._ConnectorService_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ConnectorService_url(ctx context.Context, field graphql.CollectedField, obj *ConnectorService) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ConnectorService",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var containerImplementors = []string{"Container"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Container(ctx context.Context, sel ast.SelectionSet, obj *Container) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, containerImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Container")
		case "name":
			out.Values[i] = ec._Container_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "image":
			out.Values[i] = ec._Container_image(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Container_name(ctx context.Context, field graphql.CollectedField, obj *Container) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Container",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Container_image(ctx context.Context, field graphql.CollectedField, obj *Container) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Container",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Image, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var containerStateImplementors = []string{"ContainerState"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ContainerState(ctx context.Context, sel ast.SelectionSet, obj *ContainerState) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, containerStateImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ContainerState")
		case "state":
			out.Values[i] = ec._ContainerState_state(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "reason":
			out.Values[i] = ec._ContainerState_reason(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "message":
			out.Values[i] = ec._ContainerState_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ContainerState_state(ctx context.Context, field graphql.CollectedField, obj *ContainerState) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ContainerState",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.State, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ContainerStateType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _ContainerState_reason(ctx context.Context, field graphql.CollectedField, obj *ContainerState) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ContainerState",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reason, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ContainerState_message(ctx context.Context, field graphql.CollectedField, obj *ContainerState) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ContainerState",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var createServiceBindingOutputImplementors = []string{"CreateServiceBindingOutput"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _CreateServiceBindingOutput(ctx context.Context, sel ast.SelectionSet, obj *CreateServiceBindingOutput) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, createServiceBindingOutputImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreateServiceBindingOutput")
		case "name":
			out.Values[i] = ec._CreateServiceBindingOutput_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "serviceInstanceName":
			out.Values[i] = ec._CreateServiceBindingOutput_serviceInstanceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "namespace":
			out.Values[i] = ec._CreateServiceBindingOutput_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _CreateServiceBindingOutput_name(ctx context.Context, field graphql.CollectedField, obj *CreateServiceBindingOutput) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "CreateServiceBindingOutput",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _CreateServiceBindingOutput_serviceInstanceName(ctx context.Context, field graphql.CollectedField, obj *CreateServiceBindingOutput) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "CreateServiceBindingOutput",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServiceInstanceName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _CreateServiceBindingOutput_namespace(ctx context.Context, field graphql.CollectedField, obj *CreateServiceBindingOutput) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "CreateServiceBindingOutput",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var deleteApplicationOutputImplementors = []string{"DeleteApplicationOutput"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _DeleteApplicationOutput(ctx context.Context, sel ast.SelectionSet, obj *DeleteApplicationOutput) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, deleteApplicationOutputImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeleteApplicationOutput")
		case "name":
			out.Values[i] = ec._DeleteApplicationOutput_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _DeleteApplicationOutput_name(ctx context.Context, field graphql.CollectedField, obj *DeleteApplicationOutput) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "DeleteApplicationOutput",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var deleteServiceBindingOutputImplementors = []string{"DeleteServiceBindingOutput"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _DeleteServiceBindingOutput(ctx context.Context, sel ast.SelectionSet, obj *DeleteServiceBindingOutput) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, deleteServiceBindingOutputImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeleteServiceBindingOutput")
		case "name":
			out.Values[i] = ec._DeleteServiceBindingOutput_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "namespace":
			out.Values[i] = ec._DeleteServiceBindingOutput_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _DeleteServiceBindingOutput_name(ctx context.Context, field graphql.CollectedField, obj *DeleteServiceBindingOutput) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "DeleteServiceBindingOutput",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _DeleteServiceBindingOutput_namespace(ctx context.Context, field graphql.CollectedField, obj *DeleteServiceBindingOutput) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "DeleteServiceBindingOutput",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var deleteServiceBindingUsageOutputImplementors = []string{"DeleteServiceBindingUsageOutput"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _DeleteServiceBindingUsageOutput(ctx context.Context, sel ast.SelectionSet, obj *DeleteServiceBindingUsageOutput) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, deleteServiceBindingUsageOutputImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeleteServiceBindingUsageOutput")
		case "name":
			out.Values[i] = ec._DeleteServiceBindingUsageOutput_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "namespace":
			out.Values[i] = ec._DeleteServiceBindingUsageOutput_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _DeleteServiceBindingUsageOutput_name(ctx context.Context, field graphql.CollectedField, obj *DeleteServiceBindingUsageOutput) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "DeleteServiceBindingUsageOutput",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _DeleteServiceBindingUsageOutput_namespace(ctx context.Context, field graphql.CollectedField, obj *DeleteServiceBindingUsageOutput) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "DeleteServiceBindingUsageOutput",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var deploymentImplementors = []string{"Deployment"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Deployment(ctx context.Context, sel ast.SelectionSet, obj *Deployment) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, deploymentImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Deployment")
		case "name":
			out.Values[i] = ec._Deployment_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "namespace":
			out.Values[i] = ec._Deployment_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "creationTimestamp":
			out.Values[i] = ec._Deployment_creationTimestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "status":
			out.Values[i] = ec._Deployment_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "labels":
			out.Values[i] = ec._Deployment_labels(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "containers":
			out.Values[i] = ec._Deployment_containers(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "boundServiceInstanceNames":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Deployment_boundServiceInstanceNames(ctx, field, obj)
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Deployment_name(ctx context.Context, field graphql.CollectedField, obj *Deployment) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Deployment",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Deployment_namespace(ctx context.Context, field graphql.CollectedField, obj *Deployment) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Deployment",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Deployment_creationTimestamp(ctx context.Context, field graphql.CollectedField, obj *Deployment) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Deployment",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTimestamp, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return MarshalTimestamp(res)
}

// nolint: vetshadow
func (ec *executionContext) _Deployment_status(ctx context.Context, field graphql.CollectedField, obj *Deployment) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Deployment",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(DeploymentStatus)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._DeploymentStatus(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Deployment_labels(ctx context.Context, field graphql.CollectedField, obj *Deployment) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Deployment",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Labels)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _Deployment_containers(ctx context.Context, field graphql.CollectedField, obj *Deployment) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Deployment",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Containers, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]Container)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Container(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Deployment_boundServiceInstanceNames(ctx context.Context, field graphql.CollectedField, obj *Deployment) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Deployment",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Deployment().BoundServiceInstanceNames(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return graphql.MarshalString(res[idx1])
		}()
	}

	return arr1
}

var deploymentConditionImplementors = []string{"DeploymentCondition"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _DeploymentCondition(ctx context.Context, sel ast.SelectionSet, obj *DeploymentCondition) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, deploymentConditionImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeploymentCondition")
		case "status":
			out.Values[i] = ec._DeploymentCondition_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "type":
			out.Values[i] = ec._DeploymentCondition_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "lastTransitionTimestamp":
			out.Values[i] = ec._DeploymentCondition_lastTransitionTimestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "lastUpdateTimestamp":
			out.Values[i] = ec._DeploymentCondition_lastUpdateTimestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "message":
			out.Values[i] = ec._DeploymentCondition_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "reason":
			out.Values[i] = ec._DeploymentCondition_reason(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _DeploymentCondition_status(ctx context.Context, field graphql.CollectedField, obj *DeploymentCondition) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "DeploymentCondition",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _DeploymentCondition_type(ctx context.Context, field graphql.CollectedField, obj *DeploymentCondition) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "DeploymentCondition",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _DeploymentCondition_lastTransitionTimestamp(ctx context.Context, field graphql.CollectedField, obj *DeploymentCondition) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "DeploymentCondition",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastTransitionTimestamp, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return MarshalTimestamp(res)
}

// nolint: vetshadow
func (ec *executionContext) _DeploymentCondition_lastUpdateTimestamp(ctx context.Context, field graphql.CollectedField, obj *DeploymentCondition) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "DeploymentCondition",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastUpdateTimestamp, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return MarshalTimestamp(res)
}

// nolint: vetshadow
func (ec *executionContext) _DeploymentCondition_message(ctx context.Context, field graphql.CollectedField, obj *DeploymentCondition) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "DeploymentCondition",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _DeploymentCondition_reason(ctx context.Context, field graphql.CollectedField, obj *DeploymentCondition) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "DeploymentCondition",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reason, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var deploymentStatusImplementors = []string{"DeploymentStatus"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _DeploymentStatus(ctx context.Context, sel ast.SelectionSet, obj *DeploymentStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, deploymentStatusImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeploymentStatus")
		case "replicas":
			out.Values[i] = ec._DeploymentStatus_replicas(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "updatedReplicas":
			out.Values[i] = ec._DeploymentStatus_updatedReplicas(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "readyReplicas":
			out.Values[i] = ec._DeploymentStatus_readyReplicas(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "availableReplicas":
			out.Values[i] = ec._DeploymentStatus_availableReplicas(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "conditions":
			out.Values[i] = ec._DeploymentStatus_conditions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _DeploymentStatus_replicas(ctx context.Context, field graphql.CollectedField, obj *DeploymentStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "DeploymentStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Replicas, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

// nolint: vetshadow
func (ec *executionContext) _DeploymentStatus_updatedReplicas(ctx context.Context, field graphql.CollectedField, obj *DeploymentStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "DeploymentStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedReplicas, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

// nolint: vetshadow
func (ec *executionContext) _DeploymentStatus_readyReplicas(ctx context.Context, field graphql.CollectedField, obj *DeploymentStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "DeploymentStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReadyReplicas, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

// nolint: vetshadow
func (ec *executionContext) _DeploymentStatus_availableReplicas(ctx context.Context, field graphql.CollectedField, obj *DeploymentStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "DeploymentStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AvailableReplicas, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

// nolint: vetshadow
func (ec *executionContext) _DeploymentStatus_conditions(ctx context.Context, field graphql.CollectedField, obj *DeploymentStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "DeploymentStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Conditions, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]DeploymentCondition)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._DeploymentCondition(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var docsTopicImplementors = []string{"DocsTopic"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _DocsTopic(ctx context.Context, sel ast.SelectionSet, obj *DocsTopic) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, docsTopicImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DocsTopic")
		case "name":
			out.Values[i] = ec._DocsTopic_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "namespace":
			out.Values[i] = ec._DocsTopic_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "groupName":
			out.Values[i] = ec._DocsTopic_groupName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "assets":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._DocsTopic_assets(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "displayName":
			out.Values[i] = ec._DocsTopic_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec._DocsTopic_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "status":
			out.Values[i] = ec._DocsTopic_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _DocsTopic_name(ctx context.Context, field graphql.CollectedField, obj *DocsTopic) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "DocsTopic",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _DocsTopic_namespace(ctx context.Context, field graphql.CollectedField, obj *DocsTopic) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "DocsTopic",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _DocsTopic_groupName(ctx context.Context, field graphql.CollectedField, obj *DocsTopic) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "DocsTopic",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GroupName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _DocsTopic_assets(ctx context.Context, field graphql.CollectedField, obj *DocsTopic) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_DocsTopic_assets_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "DocsTopic",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DocsTopic().Assets(rctx, obj, args["types"].([]string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]Asset)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Asset(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _DocsTopic_displayName(ctx context.Context, field graphql.CollectedField, obj *DocsTopic) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "DocsTopic",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _DocsTopic_description(ctx context.Context, field graphql.CollectedField, obj *DocsTopic) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "DocsTopic",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _DocsTopic_status(ctx context.Context, field graphql.CollectedField, obj *DocsTopic) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "DocsTopic",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(DocsTopicStatus)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._DocsTopicStatus(ctx, field.Selections, &res)
}

var docsTopicEventImplementors = []string{"DocsTopicEvent"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _DocsTopicEvent(ctx context.Context, sel ast.SelectionSet, obj *DocsTopicEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, docsTopicEventImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DocsTopicEvent")
		case "type":
			out.Values[i] = ec._DocsTopicEvent_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "docsTopic":
			out.Values[i] = ec._DocsTopicEvent_docsTopic(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _DocsTopicEvent_type(ctx context.Context, field graphql.CollectedField, obj *DocsTopicEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "DocsTopicEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SubscriptionEventType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _DocsTopicEvent_docsTopic(ctx context.Context, field graphql.CollectedField, obj *DocsTopicEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "DocsTopicEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DocsTopic, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(DocsTopic)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._DocsTopic(ctx, field.Selections, &res)
}

var docsTopicStatusImplementors = []string{"DocsTopicStatus"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _DocsTopicStatus(ctx context.Context, sel ast.SelectionSet, obj *DocsTopicStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, docsTopicStatusImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DocsTopicStatus")
		case "phase":
			out.Values[i] = ec._DocsTopicStatus_phase(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "reason":
			out.Values[i] = ec._DocsTopicStatus_reason(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "message":
			out.Values[i] = ec._DocsTopicStatus_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _DocsTopicStatus_phase(ctx context.Context, field graphql.CollectedField, obj *DocsTopicStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "DocsTopicStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Phase, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(DocsTopicPhaseType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _DocsTopicStatus_reason(ctx context.Context, field graphql.CollectedField, obj *DocsTopicStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "DocsTopicStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reason, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _DocsTopicStatus_message(ctx context.Context, field graphql.CollectedField, obj *DocsTopicStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "DocsTopicStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var envPrefixImplementors = []string{"EnvPrefix"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _EnvPrefix(ctx context.Context, sel ast.SelectionSet, obj *EnvPrefix) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, envPrefixImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EnvPrefix")
		case "name":
			out.Values[i] = ec._EnvPrefix_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _EnvPrefix_name(ctx context.Context, field graphql.CollectedField, obj *EnvPrefix) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "EnvPrefix",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var eventActivationImplementors = []string{"EventActivation"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _EventActivation(ctx context.Context, sel ast.SelectionSet, obj *EventActivation) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, eventActivationImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EventActivation")
		case "name":
			out.Values[i] = ec._EventActivation_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "displayName":
			out.Values[i] = ec._EventActivation_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "sourceId":
			out.Values[i] = ec._EventActivation_sourceId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "events":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._EventActivation_events(ctx, field, obj)
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _EventActivation_name(ctx context.Context, field graphql.CollectedField, obj *EventActivation) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "EventActivation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _EventActivation_displayName(ctx context.Context, field graphql.CollectedField, obj *EventActivation) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "EventActivation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _EventActivation_sourceId(ctx context.Context, field graphql.CollectedField, obj *EventActivation) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "EventActivation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SourceID, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _EventActivation_events(ctx context.Context, field graphql.CollectedField, obj *EventActivation) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "EventActivation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.EventActivation().Events(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]EventActivationEvent)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._EventActivationEvent(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var eventActivationEventImplementors = []string{"EventActivationEvent"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _EventActivationEvent(ctx context.Context, sel ast.SelectionSet, obj *EventActivationEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, eventActivationEventImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EventActivationEvent")
		case "eventType":
			out.Values[i] = ec._EventActivationEvent_eventType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "version":
			out.Values[i] = ec._EventActivationEvent_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec._EventActivationEvent_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _EventActivationEvent_eventType(ctx context.Context, field graphql.CollectedField, obj *EventActivationEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "EventActivationEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventType, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _EventActivationEvent_version(ctx context.Context, field graphql.CollectedField, obj *EventActivationEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "EventActivationEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _EventActivationEvent_description(ctx context.Context, field graphql.CollectedField, obj *EventActivationEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "EventActivationEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var exceededQuotaImplementors = []string{"ExceededQuota"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ExceededQuota(ctx context.Context, sel ast.SelectionSet, obj *ExceededQuota) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, exceededQuotaImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ExceededQuota")
		case "quotaName":
			out.Values[i] = ec._ExceededQuota_quotaName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "resourceName":
			out.Values[i] = ec._ExceededQuota_resourceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "affectedResources":
			out.Values[i] = ec._ExceededQuota_affectedResources(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ExceededQuota_quotaName(ctx context.Context, field graphql.CollectedField, obj *ExceededQuota) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ExceededQuota",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QuotaName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ExceededQuota_resourceName(ctx context.Context, field graphql.CollectedField, obj *ExceededQuota) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ExceededQuota",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ExceededQuota_affectedResources(ctx context.Context, field graphql.CollectedField, obj *ExceededQuota) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ExceededQuota",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AffectedResources, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return graphql.MarshalString(res[idx1])
		}()
	}

	return arr1
}

var fileImplementors = []string{"File"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _File(ctx context.Context, sel ast.SelectionSet, obj *File) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, fileImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("File")
		case "url":
			out.Values[i] = ec._File_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "metadata":
			out.Values[i] = ec._File_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _File_url(ctx context.Context, field graphql.CollectedField, obj *File) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "File",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _File_metadata(ctx context.Context, field graphql.CollectedField, obj *File) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "File",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metadata, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(JSON)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

var functionImplementors = []string{"Function"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Function(ctx context.Context, sel ast.SelectionSet, obj *Function) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, functionImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Function")
		case "name":
			out.Values[i] = ec._Function_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "trigger":
			out.Values[i] = ec._Function_trigger(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "creationTimestamp":
			out.Values[i] = ec._Function_creationTimestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "labels":
			out.Values[i] = ec._Function_labels(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "namespace":
			out.Values[i] = ec._Function_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Function_name(ctx context.Context, field graphql.CollectedField, obj *Function) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Function",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Function_trigger(ctx context.Context, field graphql.CollectedField, obj *Function) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Function",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Trigger, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Function_creationTimestamp(ctx context.Context, field graphql.CollectedField, obj *Function) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Function",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTimestamp, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return MarshalTimestamp(res)
}

// nolint: vetshadow
func (ec *executionContext) _Function_labels(ctx context.Context, field graphql.CollectedField, obj *Function) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Function",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Labels)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _Function_namespace(ctx context.Context, field graphql.CollectedField, obj *Function) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Function",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var iDPPresetImplementors = []string{"IDPPreset"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _IDPPreset(ctx context.Context, sel ast.SelectionSet, obj *IDPPreset) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, iDPPresetImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("IDPPreset")
		case "name":
			out.Values[i] = ec._IDPPreset_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "issuer":
			out.Values[i] = ec._IDPPreset_issuer(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "jwksUri":
			out.Values[i] = ec._IDPPreset_jwksUri(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _IDPPreset_name(ctx context.Context, field graphql.CollectedField, obj *IDPPreset) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "IDPPreset",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _IDPPreset_issuer(ctx context.Context, field graphql.CollectedField, obj *IDPPreset) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "IDPPreset",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Issuer, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _IDPPreset_jwksUri(ctx context.Context, field graphql.CollectedField, obj *IDPPreset) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "IDPPreset",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JwksURI, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var limitRangeImplementors = []string{"LimitRange"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _LimitRange(ctx context.Context, sel ast.SelectionSet, obj *LimitRange) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, limitRangeImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LimitRange")
		case "name":
			out.Values[i] = ec._LimitRange_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "limits":
			out.Values[i] = ec._LimitRange_limits(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _LimitRange_name(ctx context.Context, field graphql.CollectedField, obj *LimitRange) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "LimitRange",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _LimitRange_limits(ctx context.Context, field graphql.CollectedField, obj *LimitRange) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "LimitRange",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Limits, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]LimitRangeItem)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._LimitRangeItem(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var limitRangeItemImplementors = []string{"LimitRangeItem"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _LimitRangeItem(ctx context.Context, sel ast.SelectionSet, obj *LimitRangeItem) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, limitRangeItemImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LimitRangeItem")
		case "limitType":
			out.Values[i] = ec._LimitRangeItem_limitType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "max":
			out.Values[i] = ec._LimitRangeItem_max(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "default":
			out.Values[i] = ec._LimitRangeItem_default(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "defaultRequest":
			out.Values[i] = ec._LimitRangeItem_defaultRequest(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _LimitRangeItem_limitType(ctx context.Context, field graphql.CollectedField, obj *LimitRangeItem) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "LimitRangeItem",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LimitType, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(LimitType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _LimitRangeItem_max(ctx context.Context, field graphql.CollectedField, obj *LimitRangeItem) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "LimitRangeItem",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Max, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ResourceType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ResourceType(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _LimitRangeItem_default(ctx context.Context, field graphql.CollectedField, obj *LimitRangeItem) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "LimitRangeItem",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Default, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ResourceType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ResourceType(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _LimitRangeItem_defaultRequest(ctx context.Context, field graphql.CollectedField, obj *LimitRangeItem) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "LimitRangeItem",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultRequest, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ResourceType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ResourceType(ctx, field.Selections, &res)
}

var loadBalancerIngressImplementors = []string{"LoadBalancerIngress"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _LoadBalancerIngress(ctx context.Context, sel ast.SelectionSet, obj *LoadBalancerIngress) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, loadBalancerIngressImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LoadBalancerIngress")
		case "ip":
			out.Values[i] = ec._LoadBalancerIngress_ip(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "hostName":
			out.Values[i] = ec._LoadBalancerIngress_hostName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _LoadBalancerIngress_ip(ctx context.Context, field graphql.CollectedField, obj *LoadBalancerIngress) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "LoadBalancerIngress",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IP, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _LoadBalancerIngress_hostName(ctx context.Context, field graphql.CollectedField, obj *LoadBalancerIngress) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "LoadBalancerIngress",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HostName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var loadBalancerStatusImplementors = []string{"LoadBalancerStatus"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _LoadBalancerStatus(ctx context.Context, sel ast.SelectionSet, obj *LoadBalancerStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, loadBalancerStatusImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LoadBalancerStatus")
		case "ingress":
			out.Values[i] = ec._LoadBalancerStatus_ingress(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _LoadBalancerStatus_ingress(ctx context.Context, field graphql.CollectedField, obj *LoadBalancerStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "LoadBalancerStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ingress, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]LoadBalancerIngress)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._LoadBalancerIngress(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var localObjectReferenceImplementors = []string{"LocalObjectReference"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _LocalObjectReference(ctx context.Context, sel ast.SelectionSet, obj *LocalObjectReference) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, localObjectReferenceImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LocalObjectReference")
		case "kind":
			out.Values[i] = ec._LocalObjectReference_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "name":
			out.Values[i] = ec._LocalObjectReference_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _LocalObjectReference_kind(ctx context.Context, field graphql.CollectedField, obj *LocalObjectReference) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "LocalObjectReference",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _LocalObjectReference_name(ctx context.Context, field graphql.CollectedField, obj *LocalObjectReference) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "LocalObjectReference",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var mutationImplementors = []string{"Mutation"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, mutationImplementors)

	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Mutation",
	})

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "createResource":
			out.Values[i] = ec._Mutation_createResource(ctx, field)
		case "createServiceInstance":
			out.Values[i] = ec._Mutation_createServiceInstance(ctx, field)
		case "deleteServiceInstance":
			out.Values[i] = ec._Mutation_deleteServiceInstance(ctx, field)
		case "createServiceBinding":
			out.Values[i] = ec._Mutation_createServiceBinding(ctx, field)
		case "deleteServiceBinding":
			out.Values[i] = ec._Mutation_deleteServiceBinding(ctx, field)
		case "createServiceBindingUsage":
			out.Values[i] = ec._Mutation_createServiceBindingUsage(ctx, field)
		case "deleteServiceBindingUsage":
			out.Values[i] = ec._Mutation_deleteServiceBindingUsage(ctx, field)
		case "createAddonsConfiguration":
			out.Values[i] = ec._Mutation_createAddonsConfiguration(ctx, field)
		case "updateAddonsConfiguration":
			out.Values[i] = ec._Mutation_updateAddonsConfiguration(ctx, field)
		case "deleteAddonsConfiguration":
			out.Values[i] = ec._Mutation_deleteAddonsConfiguration(ctx, field)
		case "addAddonsConfigurationURLs":
			out.Values[i] = ec._Mutation_addAddonsConfigurationURLs(ctx, field)
		case "removeAddonsConfigurationURLs":
			out.Values[i] = ec._Mutation_removeAddonsConfigurationURLs(ctx, field)
		case "createApplication":
			out.Values[i] = ec._Mutation_createApplication(ctx, field)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "updateApplication":
			out.Values[i] = ec._Mutation_updateApplication(ctx, field)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "deleteApplication":
			out.Values[i] = ec._Mutation_deleteApplication(ctx, field)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "enableApplication":
			out.Values[i] = ec._Mutation_enableApplication(ctx, field)
		case "disableApplication":
			out.Values[i] = ec._Mutation_disableApplication(ctx, field)
		case "updatePod":
			out.Values[i] = ec._Mutation_updatePod(ctx, field)
		case "deletePod":
			out.Values[i] = ec._Mutation_deletePod(ctx, field)
		case "updateSecret":
			out.Values[i] = ec._Mutation_updateSecret(ctx, field)
		case "deleteSecret":
			out.Values[i] = ec._Mutation_deleteSecret(ctx, field)
		case "updateReplicaSet":
			out.Values[i] = ec._Mutation_updateReplicaSet(ctx, field)
		case "deleteReplicaSet":
			out.Values[i] = ec._Mutation_deleteReplicaSet(ctx, field)
		case "updateConfigMap":
			out.Values[i] = ec._Mutation_updateConfigMap(ctx, field)
		case "deleteConfigMap":
			out.Values[i] = ec._Mutation_deleteConfigMap(ctx, field)
		case "createIDPPreset":
			out.Values[i] = ec._Mutation_createIDPPreset(ctx, field)
		case "deleteIDPPreset":
			out.Values[i] = ec._Mutation_deleteIDPPreset(ctx, field)
		case "updateService":
			out.Values[i] = ec._Mutation_updateService(ctx, field)
		case "deleteService":
			out.Values[i] = ec._Mutation_deleteService(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_createResource(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_createResource_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateResource(rctx, args["namespace"].(string), args["resource"].(JSON))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*JSON)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return *res
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_createServiceInstance(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_createServiceInstance_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateServiceInstance(rctx, args["namespace"].(string), args["params"].(ServiceInstanceCreateInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ServiceInstance)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ServiceInstance(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_deleteServiceInstance(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_deleteServiceInstance_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteServiceInstance(rctx, args["name"].(string), args["namespace"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ServiceInstance)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ServiceInstance(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_createServiceBinding(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_createServiceBinding_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateServiceBinding(rctx, args["serviceBindingName"].(*string), args["serviceInstanceName"].(string), args["namespace"].(string), args["parameters"].(*JSON))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*CreateServiceBindingOutput)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._CreateServiceBindingOutput(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_deleteServiceBinding(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_deleteServiceBinding_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteServiceBinding(rctx, args["serviceBindingName"].(string), args["namespace"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*DeleteServiceBindingOutput)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._DeleteServiceBindingOutput(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_createServiceBindingUsage(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_createServiceBindingUsage_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateServiceBindingUsage(rctx, args["namespace"].(string), args["createServiceBindingUsageInput"].(*CreateServiceBindingUsageInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ServiceBindingUsage)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ServiceBindingUsage(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_deleteServiceBindingUsage(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_deleteServiceBindingUsage_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteServiceBindingUsage(rctx, args["serviceBindingUsageName"].(string), args["namespace"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*DeleteServiceBindingUsageOutput)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._DeleteServiceBindingUsageOutput(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_createAddonsConfiguration(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_createAddonsConfiguration_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateAddonsConfiguration(rctx, args["name"].(string), args["urls"].([]string), args["labels"].(*Labels))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*AddonsConfiguration)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._AddonsConfiguration(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_updateAddonsConfiguration(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_updateAddonsConfiguration_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateAddonsConfiguration(rctx, args["name"].(string), args["urls"].([]string), args["labels"].(*Labels))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*AddonsConfiguration)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._AddonsConfiguration(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_deleteAddonsConfiguration(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_deleteAddonsConfiguration_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteAddonsConfiguration(rctx, args["name"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*AddonsConfiguration)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._AddonsConfiguration(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_addAddonsConfigurationURLs(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_addAddonsConfigurationURLs_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AddAddonsConfigurationURLs(rctx, args["name"].(string), args["urls"].([]string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*AddonsConfiguration)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._AddonsConfiguration(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_removeAddonsConfigurationURLs(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_removeAddonsConfigurationURLs_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RemoveAddonsConfigurationURLs(rctx, args["name"].(string), args["urls"].([]string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*AddonsConfiguration)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._AddonsConfiguration(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_createApplication(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_createApplication_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateApplication(rctx, args["name"].(string), args["description"].(*string), args["labels"].(*Labels))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ApplicationMutationOutput)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ApplicationMutationOutput(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_updateApplication(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_updateApplication_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateApplication(rctx, args["name"].(string), args["description"].(*string), args["labels"].(*Labels))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ApplicationMutationOutput)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ApplicationMutationOutput(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_deleteApplication(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_deleteApplication_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteApplication(rctx, args["name"].(string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(DeleteApplicationOutput)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._DeleteApplicationOutput(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_enableApplication(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_enableApplication_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().EnableApplication(rctx, args["application"].(string), args["namespace"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ApplicationMapping)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ApplicationMapping(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_disableApplication(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_disableApplication_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DisableApplication(rctx, args["application"].(string), args["namespace"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ApplicationMapping)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ApplicationMapping(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_updatePod(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_updatePod_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdatePod(rctx, args["name"].(string), args["namespace"].(string), args["pod"].(JSON))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Pod)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Pod(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_deletePod(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_deletePod_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeletePod(rctx, args["name"].(string), args["namespace"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Pod)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Pod(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_updateSecret(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_updateSecret_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateSecret(rctx, args["name"].(string), args["namespace"].(string), args["secret"].(JSON))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Secret)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Secret(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_deleteSecret(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_deleteSecret_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteSecret(rctx, args["name"].(string), args["namespace"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Secret)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Secret(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_updateReplicaSet(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_updateReplicaSet_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateReplicaSet(rctx, args["name"].(string), args["namespace"].(string), args["replicaSet"].(JSON))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ReplicaSet)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ReplicaSet(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_deleteReplicaSet(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_deleteReplicaSet_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteReplicaSet(rctx, args["name"].(string), args["namespace"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ReplicaSet)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ReplicaSet(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_updateConfigMap(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_updateConfigMap_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateConfigMap(rctx, args["name"].(string), args["namespace"].(string), args["configMap"].(JSON))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ConfigMap)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ConfigMap(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_deleteConfigMap(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_deleteConfigMap_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteConfigMap(rctx, args["name"].(string), args["namespace"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ConfigMap)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ConfigMap(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_createIDPPreset(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_createIDPPreset_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateIDPPreset(rctx, args["name"].(string), args["issuer"].(string), args["jwksUri"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*IDPPreset)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._IDPPreset(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_deleteIDPPreset(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_deleteIDPPreset_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteIDPPreset(rctx, args["name"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*IDPPreset)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._IDPPreset(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_updateService(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_updateService_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateService(rctx, args["name"].(string), args["namespace"].(string), args["service"].(JSON))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Service)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Service(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_deleteService(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_deleteService_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteService(rctx, args["name"].(string), args["namespace"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Service)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Service(ctx, field.Selections, res)
}

var namespaceImplementors = []string{"Namespace"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Namespace(ctx context.Context, sel ast.SelectionSet, obj *Namespace) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, namespaceImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Namespace")
		case "name":
			out.Values[i] = ec._Namespace_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "applications":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Namespace_applications(ctx, field, obj)
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Namespace_name(ctx context.Context, field graphql.CollectedField, obj *Namespace) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Namespace",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Namespace_applications(ctx context.Context, field graphql.CollectedField, obj *Namespace) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Namespace",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Namespace().Applications(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return graphql.MarshalString(res[idx1])
		}()
	}

	return arr1
}

var podImplementors = []string{"Pod"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Pod(ctx context.Context, sel ast.SelectionSet, obj *Pod) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, podImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Pod")
		case "name":
			out.Values[i] = ec._Pod_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "nodeName":
			out.Values[i] = ec._Pod_nodeName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "namespace":
			out.Values[i] = ec._Pod_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "restartCount":
			out.Values[i] = ec._Pod_restartCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "creationTimestamp":
			out.Values[i] = ec._Pod_creationTimestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "labels":
			out.Values[i] = ec._Pod_labels(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "status":
			out.Values[i] = ec._Pod_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "containerStates":
			out.Values[i] = ec._Pod_containerStates(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "json":
			out.Values[i] = ec._Pod_json(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Pod_name(ctx context.Context, field graphql.CollectedField, obj *Pod) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Pod",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Pod_nodeName(ctx context.Context, field graphql.CollectedField, obj *Pod) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Pod",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NodeName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Pod_namespace(ctx context.Context, field graphql.CollectedField, obj *Pod) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Pod",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Pod_restartCount(ctx context.Context, field graphql.CollectedField, obj *Pod) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Pod",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RestartCount, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

// nolint: vetshadow
func (ec *executionContext) _Pod_creationTimestamp(ctx context.Context, field graphql.CollectedField, obj *Pod) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Pod",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTimestamp, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return MarshalTimestamp(res)
}

// nolint: vetshadow
func (ec *executionContext) _Pod_labels(ctx context.Context, field graphql.CollectedField, obj *Pod) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Pod",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Labels)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _Pod_status(ctx context.Context, field graphql.CollectedField, obj *Pod) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Pod",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(PodStatusType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _Pod_containerStates(ctx context.Context, field graphql.CollectedField, obj *Pod) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Pod",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContainerStates, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]ContainerState)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._ContainerState(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Pod_json(ctx context.Context, field graphql.CollectedField, obj *Pod) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Pod",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JSON, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(JSON)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

var podEventImplementors = []string{"PodEvent"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _PodEvent(ctx context.Context, sel ast.SelectionSet, obj *PodEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, podEventImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PodEvent")
		case "type":
			out.Values[i] = ec._PodEvent_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "pod":
			out.Values[i] = ec._PodEvent_pod(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _PodEvent_type(ctx context.Context, field graphql.CollectedField, obj *PodEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "PodEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SubscriptionEventType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _PodEvent_pod(ctx context.Context, field graphql.CollectedField, obj *PodEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "PodEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Pod, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Pod)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Pod(ctx, field.Selections, &res)
}

var queryImplementors = []string{"Query"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, queryImplementors)

	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Query",
	})

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "clusterDocsTopics":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_clusterDocsTopics(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "serviceInstance":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_serviceInstance(ctx, field)
				wg.Done()
			}(i, field)
		case "serviceInstances":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_serviceInstances(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "clusterServiceClasses":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_clusterServiceClasses(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "clusterServiceClass":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_clusterServiceClass(ctx, field)
				wg.Done()
			}(i, field)
		case "serviceClasses":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_serviceClasses(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "serviceClass":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_serviceClass(ctx, field)
				wg.Done()
			}(i, field)
		case "clusterServiceBrokers":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_clusterServiceBrokers(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "clusterServiceBroker":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_clusterServiceBroker(ctx, field)
				wg.Done()
			}(i, field)
		case "serviceBrokers":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_serviceBrokers(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "serviceBroker":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_serviceBroker(ctx, field)
				wg.Done()
			}(i, field)
		case "serviceBindingUsage":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_serviceBindingUsage(ctx, field)
				wg.Done()
			}(i, field)
		case "serviceBinding":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_serviceBinding(ctx, field)
				wg.Done()
			}(i, field)
		case "usageKinds":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_usageKinds(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "addonsConfigurations":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_addonsConfigurations(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "bindableResources":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_bindableResources(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "apis":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_apis(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "application":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_application(ctx, field)
				wg.Done()
			}(i, field)
		case "applications":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_applications(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "connectorService":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_connectorService(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "namespaces":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_namespaces(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "deployments":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_deployments(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "pod":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_pod(ctx, field)
				wg.Done()
			}(i, field)
		case "pods":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_pods(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "service":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_service(ctx, field)
				wg.Done()
			}(i, field)
		case "services":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_services(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "configMap":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_configMap(ctx, field)
				wg.Done()
			}(i, field)
		case "configMaps":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_configMaps(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "replicaSet":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_replicaSet(ctx, field)
				wg.Done()
			}(i, field)
		case "replicaSets":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_replicaSets(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "resourceQuotas":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_resourceQuotas(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "resourceQuotasStatus":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_resourceQuotasStatus(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "functions":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_functions(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "content":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_content(ctx, field)
				wg.Done()
			}(i, field)
		case "topics":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_topics(ctx, field)
				wg.Done()
			}(i, field)
		case "eventActivations":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_eventActivations(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "limitRanges":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_limitRanges(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "backendModules":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_backendModules(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "secret":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_secret(ctx, field)
				wg.Done()
			}(i, field)
		case "secrets":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_secrets(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "IDPPreset":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_IDPPreset(ctx, field)
				wg.Done()
			}(i, field)
		case "IDPPresets":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_IDPPresets(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "selfSubjectRules":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_selfSubjectRules(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "__type":
			out.Values[i] = ec._Query___type(ctx, field)
		case "__schema":
			out.Values[i] = ec._Query___schema(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Query_clusterDocsTopics(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_clusterDocsTopics_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ClusterDocsTopics(rctx, args["viewContext"].(*string), args["groupName"].(*string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]ClusterDocsTopic)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._ClusterDocsTopic(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_serviceInstance(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_serviceInstance_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ServiceInstance(rctx, args["name"].(string), args["namespace"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ServiceInstance)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ServiceInstance(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_serviceInstances(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_serviceInstances_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ServiceInstances(rctx, args["namespace"].(string), args["first"].(*int), args["offset"].(*int), args["status"].(*InstanceStatusType))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]ServiceInstance)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._ServiceInstance(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_clusterServiceClasses(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_clusterServiceClasses_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ClusterServiceClasses(rctx, args["first"].(*int), args["offset"].(*int))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]ClusterServiceClass)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._ClusterServiceClass(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_clusterServiceClass(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_clusterServiceClass_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ClusterServiceClass(rctx, args["name"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ClusterServiceClass)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ClusterServiceClass(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_serviceClasses(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_serviceClasses_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ServiceClasses(rctx, args["namespace"].(string), args["first"].(*int), args["offset"].(*int))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]ServiceClass)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._ServiceClass(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_serviceClass(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_serviceClass_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ServiceClass(rctx, args["namespace"].(string), args["name"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ServiceClass)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ServiceClass(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_clusterServiceBrokers(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_clusterServiceBrokers_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ClusterServiceBrokers(rctx, args["first"].(*int), args["offset"].(*int))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]ClusterServiceBroker)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._ClusterServiceBroker(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_clusterServiceBroker(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_clusterServiceBroker_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ClusterServiceBroker(rctx, args["name"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ClusterServiceBroker)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ClusterServiceBroker(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_serviceBrokers(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_serviceBrokers_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ServiceBrokers(rctx, args["namespace"].(string), args["first"].(*int), args["offset"].(*int))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]ServiceBroker)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._ServiceBroker(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_serviceBroker(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_serviceBroker_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ServiceBroker(rctx, args["name"].(string), args["namespace"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ServiceBroker)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ServiceBroker(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_serviceBindingUsage(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_serviceBindingUsage_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ServiceBindingUsage(rctx, args["name"].(string), args["namespace"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ServiceBindingUsage)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ServiceBindingUsage(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_serviceBinding(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_serviceBinding_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ServiceBinding(rctx, args["name"].(string), args["namespace"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ServiceBinding)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ServiceBinding(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_usageKinds(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_usageKinds_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UsageKinds(rctx, args["first"].(*int), args["offset"].(*int))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]UsageKind)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._UsageKind(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_addonsConfigurations(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_addonsConfigurations_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AddonsConfigurations(rctx, args["first"].(*int), args["offset"].(*int))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]AddonsConfiguration)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._AddonsConfiguration(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_bindableResources(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_bindableResources_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().BindableResources(rctx, args["namespace"].(string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]BindableResourcesOutputItem)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._BindableResourcesOutputItem(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_apis(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_apis_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Apis(rctx, args["namespace"].(string), args["serviceName"].(*string), args["hostname"].(*string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]API)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._API(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_application(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_application_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Application(rctx, args["name"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Application)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Application(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_applications(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_applications_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Applications(rctx, args["namespace"].(*string), args["first"].(*int), args["offset"].(*int))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]Application)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Application(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_connectorService(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_connectorService_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ConnectorService(rctx, args["application"].(string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ConnectorService)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ConnectorService(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_namespaces(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_namespaces_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Namespaces(rctx, args["application"].(*string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]Namespace)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Namespace(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_deployments(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_deployments_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Deployments(rctx, args["namespace"].(string), args["excludeFunctions"].(*bool))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]Deployment)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Deployment(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_pod(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_pod_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Pod(rctx, args["name"].(string), args["namespace"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Pod)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Pod(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_pods(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_pods_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Pods(rctx, args["namespace"].(string), args["first"].(*int), args["offset"].(*int))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]Pod)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Pod(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_service(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_service_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Service(rctx, args["name"].(string), args["namespace"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Service)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Service(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_services(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_services_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Services(rctx, args["namespace"].(string), args["first"].(*int), args["offset"].(*int))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]Service)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Service(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_configMap(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_configMap_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ConfigMap(rctx, args["name"].(string), args["namespace"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ConfigMap)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ConfigMap(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_configMaps(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_configMaps_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ConfigMaps(rctx, args["namespace"].(string), args["first"].(*int), args["offset"].(*int))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]ConfigMap)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._ConfigMap(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_replicaSet(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_replicaSet_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ReplicaSet(rctx, args["name"].(string), args["namespace"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ReplicaSet)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ReplicaSet(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_replicaSets(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_replicaSets_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ReplicaSets(rctx, args["namespace"].(string), args["first"].(*int), args["offset"].(*int))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]ReplicaSet)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._ReplicaSet(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_resourceQuotas(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_resourceQuotas_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ResourceQuotas(rctx, args["namespace"].(string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]ResourceQuota)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._ResourceQuota(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_resourceQuotasStatus(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_resourceQuotasStatus_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ResourceQuotasStatus(rctx, args["namespace"].(string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ResourceQuotasStatus)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ResourceQuotasStatus(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_functions(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_functions_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Functions(rctx, args["namespace"].(string), args["first"].(*int), args["offset"].(*int))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]Function)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Function(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_content(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_content_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Content(rctx, args["contentType"].(string), args["id"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*JSON)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return *res
}

// nolint: vetshadow
func (ec *executionContext) _Query_topics(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_topics_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Topics(rctx, args["input"].([]InputTopic), args["internal"].(*bool))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]TopicEntry)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._TopicEntry(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_eventActivations(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_eventActivations_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().EventActivations(rctx, args["namespace"].(string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]EventActivation)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._EventActivation(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_limitRanges(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_limitRanges_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().LimitRanges(rctx, args["namespace"].(string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]LimitRange)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._LimitRange(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_backendModules(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().BackendModules(rctx)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]BackendModule)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._BackendModule(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_secret(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_secret_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Secret(rctx, args["name"].(string), args["namespace"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Secret)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Secret(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_secrets(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_secrets_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Secrets(rctx, args["namespace"].(string), args["first"].(*int), args["offset"].(*int))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]Secret)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Secret(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_IDPPreset(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_IDPPreset_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().IDPPreset(rctx, args["name"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*IDPPreset)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._IDPPreset(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_IDPPresets(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_IDPPresets_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().IDPPresets(rctx, args["first"].(*int), args["offset"].(*int))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]IDPPreset)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._IDPPreset(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_selfSubjectRules(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_selfSubjectRules_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().SelfSubjectRules(rctx, args["namespace"].(*string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]ResourceRule)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._ResourceRule(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query___type_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(args["name"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec.___Schema(ctx, field.Selections, res)
}

var replicaSetImplementors = []string{"ReplicaSet"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ReplicaSet(ctx context.Context, sel ast.SelectionSet, obj *ReplicaSet) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, replicaSetImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ReplicaSet")
		case "name":
			out.Values[i] = ec._ReplicaSet_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "pods":
			out.Values[i] = ec._ReplicaSet_pods(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "namespace":
			out.Values[i] = ec._ReplicaSet_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "images":
			out.Values[i] = ec._ReplicaSet_images(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "creationTimestamp":
			out.Values[i] = ec._ReplicaSet_creationTimestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "labels":
			out.Values[i] = ec._ReplicaSet_labels(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "json":
			out.Values[i] = ec._ReplicaSet_json(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ReplicaSet_name(ctx context.Context, field graphql.CollectedField, obj *ReplicaSet) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ReplicaSet",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ReplicaSet_pods(ctx context.Context, field graphql.CollectedField, obj *ReplicaSet) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ReplicaSet",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Pods, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ReplicaSet_namespace(ctx context.Context, field graphql.CollectedField, obj *ReplicaSet) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ReplicaSet",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ReplicaSet_images(ctx context.Context, field graphql.CollectedField, obj *ReplicaSet) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ReplicaSet",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Images, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return graphql.MarshalString(res[idx1])
		}()
	}

	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _ReplicaSet_creationTimestamp(ctx context.Context, field graphql.CollectedField, obj *ReplicaSet) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ReplicaSet",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTimestamp, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return MarshalTimestamp(res)
}

// nolint: vetshadow
func (ec *executionContext) _ReplicaSet_labels(ctx context.Context, field graphql.CollectedField, obj *ReplicaSet) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ReplicaSet",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Labels)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _ReplicaSet_json(ctx context.Context, field graphql.CollectedField, obj *ReplicaSet) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ReplicaSet",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JSON, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(JSON)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

var resourceQuotaImplementors = []string{"ResourceQuota"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ResourceQuota(ctx context.Context, sel ast.SelectionSet, obj *ResourceQuota) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, resourceQuotaImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ResourceQuota")
		case "name":
			out.Values[i] = ec._ResourceQuota_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "pods":
			out.Values[i] = ec._ResourceQuota_pods(ctx, field, obj)
		case "limits":
			out.Values[i] = ec._ResourceQuota_limits(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "requests":
			out.Values[i] = ec._ResourceQuota_requests(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ResourceQuota_name(ctx context.Context, field graphql.CollectedField, obj *ResourceQuota) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ResourceQuota",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ResourceQuota_pods(ctx context.Context, field graphql.CollectedField, obj *ResourceQuota) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ResourceQuota",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Pods, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ResourceQuota_limits(ctx context.Context, field graphql.CollectedField, obj *ResourceQuota) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ResourceQuota",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Limits, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ResourceValues)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ResourceValues(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _ResourceQuota_requests(ctx context.Context, field graphql.CollectedField, obj *ResourceQuota) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ResourceQuota",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Requests, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ResourceValues)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ResourceValues(ctx, field.Selections, &res)
}

var resourceQuotasStatusImplementors = []string{"ResourceQuotasStatus"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ResourceQuotasStatus(ctx context.Context, sel ast.SelectionSet, obj *ResourceQuotasStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, resourceQuotasStatusImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ResourceQuotasStatus")
		case "exceeded":
			out.Values[i] = ec._ResourceQuotasStatus_exceeded(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "exceededQuotas":
			out.Values[i] = ec._ResourceQuotasStatus_exceededQuotas(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ResourceQuotasStatus_exceeded(ctx context.Context, field graphql.CollectedField, obj *ResourceQuotasStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ResourceQuotasStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Exceeded, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) _ResourceQuotasStatus_exceededQuotas(ctx context.Context, field graphql.CollectedField, obj *ResourceQuotasStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ResourceQuotasStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExceededQuotas, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]ExceededQuota)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._ExceededQuota(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var resourceRuleImplementors = []string{"ResourceRule"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ResourceRule(ctx context.Context, sel ast.SelectionSet, obj *ResourceRule) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, resourceRuleImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ResourceRule")
		case "verbs":
			out.Values[i] = ec._ResourceRule_verbs(ctx, field, obj)
		case "apiGroups":
			out.Values[i] = ec._ResourceRule_apiGroups(ctx, field, obj)
		case "resources":
			out.Values[i] = ec._ResourceRule_resources(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ResourceRule_verbs(ctx context.Context, field graphql.CollectedField, obj *ResourceRule) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ResourceRule",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Verbs, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return graphql.MarshalString(res[idx1])
		}()
	}

	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _ResourceRule_apiGroups(ctx context.Context, field graphql.CollectedField, obj *ResourceRule) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ResourceRule",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.APIGroups, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return graphql.MarshalString(res[idx1])
		}()
	}

	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _ResourceRule_resources(ctx context.Context, field graphql.CollectedField, obj *ResourceRule) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ResourceRule",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Resources, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return graphql.MarshalString(res[idx1])
		}()
	}

	return arr1
}

var resourceTypeImplementors = []string{"ResourceType"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ResourceType(ctx context.Context, sel ast.SelectionSet, obj *ResourceType) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, resourceTypeImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ResourceType")
		case "memory":
			out.Values[i] = ec._ResourceType_memory(ctx, field, obj)
		case "cpu":
			out.Values[i] = ec._ResourceType_cpu(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ResourceType_memory(ctx context.Context, field graphql.CollectedField, obj *ResourceType) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ResourceType",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Memory, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ResourceType_cpu(ctx context.Context, field graphql.CollectedField, obj *ResourceType) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ResourceType",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CPU, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var resourceValuesImplementors = []string{"ResourceValues"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ResourceValues(ctx context.Context, sel ast.SelectionSet, obj *ResourceValues) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, resourceValuesImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ResourceValues")
		case "memory":
			out.Values[i] = ec._ResourceValues_memory(ctx, field, obj)
		case "cpu":
			out.Values[i] = ec._ResourceValues_cpu(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ResourceValues_memory(ctx context.Context, field graphql.CollectedField, obj *ResourceValues) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ResourceValues",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Memory, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ResourceValues_cpu(ctx context.Context, field graphql.CollectedField, obj *ResourceValues) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ResourceValues",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CPU, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var secretImplementors = []string{"Secret"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Secret(ctx context.Context, sel ast.SelectionSet, obj *Secret) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, secretImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Secret")
		case "name":
			out.Values[i] = ec._Secret_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "namespace":
			out.Values[i] = ec._Secret_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "data":
			out.Values[i] = ec._Secret_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "type":
			out.Values[i] = ec._Secret_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "creationTime":
			out.Values[i] = ec._Secret_creationTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "labels":
			out.Values[i] = ec._Secret_labels(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "annotations":
			out.Values[i] = ec._Secret_annotations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "json":
			out.Values[i] = ec._Secret_json(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Secret_name(ctx context.Context, field graphql.CollectedField, obj *Secret) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Secret",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Secret_namespace(ctx context.Context, field graphql.CollectedField, obj *Secret) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Secret",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Secret_data(ctx context.Context, field graphql.CollectedField, obj *Secret) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Secret",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(JSON)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _Secret_type(ctx context.Context, field graphql.CollectedField, obj *Secret) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Secret",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Secret_creationTime(ctx context.Context, field graphql.CollectedField, obj *Secret) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Secret",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTime, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return MarshalTimestamp(res)
}

// nolint: vetshadow
func (ec *executionContext) _Secret_labels(ctx context.Context, field graphql.CollectedField, obj *Secret) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Secret",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(JSON)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _Secret_annotations(ctx context.Context, field graphql.CollectedField, obj *Secret) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Secret",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Annotations, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(JSON)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _Secret_json(ctx context.Context, field graphql.CollectedField, obj *Secret) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Secret",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JSON, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(JSON)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

var secretEventImplementors = []string{"SecretEvent"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _SecretEvent(ctx context.Context, sel ast.SelectionSet, obj *SecretEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, secretEventImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SecretEvent")
		case "type":
			out.Values[i] = ec._SecretEvent_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "secret":
			out.Values[i] = ec._SecretEvent_secret(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _SecretEvent_type(ctx context.Context, field graphql.CollectedField, obj *SecretEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "SecretEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SubscriptionEventType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _SecretEvent_secret(ctx context.Context, field graphql.CollectedField, obj *SecretEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "SecretEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Secret, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Secret)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Secret(ctx, field.Selections, &res)
}

var sectionImplementors = []string{"Section"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Section(ctx context.Context, sel ast.SelectionSet, obj *Section) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, sectionImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Section")
		case "name":
			out.Values[i] = ec._Section_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "anchor":
			out.Values[i] = ec._Section_anchor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "titles":
			out.Values[i] = ec._Section_titles(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "topicType":
			out.Values[i] = ec._Section_topicType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Section_name(ctx context.Context, field graphql.CollectedField, obj *Section) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Section",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Section_anchor(ctx context.Context, field graphql.CollectedField, obj *Section) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Section",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Anchor, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Section_titles(ctx context.Context, field graphql.CollectedField, obj *Section) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Section",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Titles, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]Title)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Title(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Section_topicType(ctx context.Context, field graphql.CollectedField, obj *Section) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Section",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TopicType, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var serviceImplementors = []string{"Service"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Service(ctx context.Context, sel ast.SelectionSet, obj *Service) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, serviceImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Service")
		case "name":
			out.Values[i] = ec._Service_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "clusterIP":
			out.Values[i] = ec._Service_clusterIP(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "creationTimestamp":
			out.Values[i] = ec._Service_creationTimestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "labels":
			out.Values[i] = ec._Service_labels(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "ports":
			out.Values[i] = ec._Service_ports(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "status":
			out.Values[i] = ec._Service_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "json":
			out.Values[i] = ec._Service_json(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Service_name(ctx context.Context, field graphql.CollectedField, obj *Service) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Service",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Service_clusterIP(ctx context.Context, field graphql.CollectedField, obj *Service) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Service",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClusterIP, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Service_creationTimestamp(ctx context.Context, field graphql.CollectedField, obj *Service) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Service",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTimestamp, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return MarshalTimestamp(res)
}

// nolint: vetshadow
func (ec *executionContext) _Service_labels(ctx context.Context, field graphql.CollectedField, obj *Service) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Service",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Labels)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _Service_ports(ctx context.Context, field graphql.CollectedField, obj *Service) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Service",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ports, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]ServicePort)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._ServicePort(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Service_status(ctx context.Context, field graphql.CollectedField, obj *Service) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Service",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ServiceStatus)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ServiceStatus(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Service_json(ctx context.Context, field graphql.CollectedField, obj *Service) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Service",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JSON, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(JSON)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

var serviceBindingImplementors = []string{"ServiceBinding"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ServiceBinding(ctx context.Context, sel ast.SelectionSet, obj *ServiceBinding) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, serviceBindingImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceBinding")
		case "name":
			out.Values[i] = ec._ServiceBinding_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "serviceInstanceName":
			out.Values[i] = ec._ServiceBinding_serviceInstanceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "namespace":
			out.Values[i] = ec._ServiceBinding_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "secret":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ServiceBinding_secret(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "status":
			out.Values[i] = ec._ServiceBinding_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "parameters":
			out.Values[i] = ec._ServiceBinding_parameters(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBinding_name(ctx context.Context, field graphql.CollectedField, obj *ServiceBinding) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBinding",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBinding_serviceInstanceName(ctx context.Context, field graphql.CollectedField, obj *ServiceBinding) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBinding",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServiceInstanceName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBinding_namespace(ctx context.Context, field graphql.CollectedField, obj *ServiceBinding) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBinding",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBinding_secret(ctx context.Context, field graphql.CollectedField, obj *ServiceBinding) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBinding",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ServiceBinding().Secret(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Secret)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Secret(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBinding_status(ctx context.Context, field graphql.CollectedField, obj *ServiceBinding) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBinding",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ServiceBindingStatus)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ServiceBindingStatus(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBinding_parameters(ctx context.Context, field graphql.CollectedField, obj *ServiceBinding) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBinding",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Parameters, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(JSON)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

var serviceBindingEventImplementors = []string{"ServiceBindingEvent"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ServiceBindingEvent(ctx context.Context, sel ast.SelectionSet, obj *ServiceBindingEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, serviceBindingEventImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceBindingEvent")
		case "type":
			out.Values[i] = ec._ServiceBindingEvent_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "serviceBinding":
			out.Values[i] = ec._ServiceBindingEvent_serviceBinding(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBindingEvent_type(ctx context.Context, field graphql.CollectedField, obj *ServiceBindingEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBindingEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SubscriptionEventType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBindingEvent_serviceBinding(ctx context.Context, field graphql.CollectedField, obj *ServiceBindingEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBindingEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServiceBinding, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ServiceBinding)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ServiceBinding(ctx, field.Selections, &res)
}

var serviceBindingStatusImplementors = []string{"ServiceBindingStatus"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ServiceBindingStatus(ctx context.Context, sel ast.SelectionSet, obj *ServiceBindingStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, serviceBindingStatusImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceBindingStatus")
		case "type":
			out.Values[i] = ec._ServiceBindingStatus_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "reason":
			out.Values[i] = ec._ServiceBindingStatus_reason(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "message":
			out.Values[i] = ec._ServiceBindingStatus_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBindingStatus_type(ctx context.Context, field graphql.CollectedField, obj *ServiceBindingStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBindingStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ServiceBindingStatusType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBindingStatus_reason(ctx context.Context, field graphql.CollectedField, obj *ServiceBindingStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBindingStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reason, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBindingStatus_message(ctx context.Context, field graphql.CollectedField, obj *ServiceBindingStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBindingStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var serviceBindingUsageImplementors = []string{"ServiceBindingUsage"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ServiceBindingUsage(ctx context.Context, sel ast.SelectionSet, obj *ServiceBindingUsage) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, serviceBindingUsageImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceBindingUsage")
		case "name":
			out.Values[i] = ec._ServiceBindingUsage_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "namespace":
			out.Values[i] = ec._ServiceBindingUsage_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "serviceBinding":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ServiceBindingUsage_serviceBinding(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "usedBy":
			out.Values[i] = ec._ServiceBindingUsage_usedBy(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "parameters":
			out.Values[i] = ec._ServiceBindingUsage_parameters(ctx, field, obj)
		case "status":
			out.Values[i] = ec._ServiceBindingUsage_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBindingUsage_name(ctx context.Context, field graphql.CollectedField, obj *ServiceBindingUsage) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBindingUsage",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBindingUsage_namespace(ctx context.Context, field graphql.CollectedField, obj *ServiceBindingUsage) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBindingUsage",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBindingUsage_serviceBinding(ctx context.Context, field graphql.CollectedField, obj *ServiceBindingUsage) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBindingUsage",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ServiceBindingUsage().ServiceBinding(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ServiceBinding)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ServiceBinding(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBindingUsage_usedBy(ctx context.Context, field graphql.CollectedField, obj *ServiceBindingUsage) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBindingUsage",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UsedBy, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(LocalObjectReference)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._LocalObjectReference(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBindingUsage_parameters(ctx context.Context, field graphql.CollectedField, obj *ServiceBindingUsage) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBindingUsage",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Parameters, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ServiceBindingUsageParameters)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ServiceBindingUsageParameters(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBindingUsage_status(ctx context.Context, field graphql.CollectedField, obj *ServiceBindingUsage) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBindingUsage",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ServiceBindingUsageStatus)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ServiceBindingUsageStatus(ctx, field.Selections, &res)
}

var serviceBindingUsageEventImplementors = []string{"ServiceBindingUsageEvent"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ServiceBindingUsageEvent(ctx context.Context, sel ast.SelectionSet, obj *ServiceBindingUsageEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, serviceBindingUsageEventImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceBindingUsageEvent")
		case "type":
			out.Values[i] = ec._ServiceBindingUsageEvent_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "serviceBindingUsage":
			out.Values[i] = ec._ServiceBindingUsageEvent_serviceBindingUsage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBindingUsageEvent_type(ctx context.Context, field graphql.CollectedField, obj *ServiceBindingUsageEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBindingUsageEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SubscriptionEventType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBindingUsageEvent_serviceBindingUsage(ctx context.Context, field graphql.CollectedField, obj *ServiceBindingUsageEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBindingUsageEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServiceBindingUsage, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ServiceBindingUsage)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ServiceBindingUsage(ctx, field.Selections, &res)
}

var serviceBindingUsageParametersImplementors = []string{"ServiceBindingUsageParameters"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ServiceBindingUsageParameters(ctx context.Context, sel ast.SelectionSet, obj *ServiceBindingUsageParameters) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, serviceBindingUsageParametersImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceBindingUsageParameters")
		case "envPrefix":
			out.Values[i] = ec._ServiceBindingUsageParameters_envPrefix(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBindingUsageParameters_envPrefix(ctx context.Context, field graphql.CollectedField, obj *ServiceBindingUsageParameters) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBindingUsageParameters",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnvPrefix, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*EnvPrefix)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._EnvPrefix(ctx, field.Selections, res)
}

var serviceBindingUsageStatusImplementors = []string{"ServiceBindingUsageStatus"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ServiceBindingUsageStatus(ctx context.Context, sel ast.SelectionSet, obj *ServiceBindingUsageStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, serviceBindingUsageStatusImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceBindingUsageStatus")
		case "type":
			out.Values[i] = ec._ServiceBindingUsageStatus_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "reason":
			out.Values[i] = ec._ServiceBindingUsageStatus_reason(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "message":
			out.Values[i] = ec._ServiceBindingUsageStatus_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBindingUsageStatus_type(ctx context.Context, field graphql.CollectedField, obj *ServiceBindingUsageStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBindingUsageStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ServiceBindingUsageStatusType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBindingUsageStatus_reason(ctx context.Context, field graphql.CollectedField, obj *ServiceBindingUsageStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBindingUsageStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reason, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBindingUsageStatus_message(ctx context.Context, field graphql.CollectedField, obj *ServiceBindingUsageStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBindingUsageStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var serviceBindingsImplementors = []string{"ServiceBindings"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ServiceBindings(ctx context.Context, sel ast.SelectionSet, obj *ServiceBindings) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, serviceBindingsImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceBindings")
		case "items":
			out.Values[i] = ec._ServiceBindings_items(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "stats":
			out.Values[i] = ec._ServiceBindings_stats(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBindings_items(ctx context.Context, field graphql.CollectedField, obj *ServiceBindings) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBindings",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Items, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]ServiceBinding)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._ServiceBinding(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBindings_stats(ctx context.Context, field graphql.CollectedField, obj *ServiceBindings) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBindings",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Stats, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ServiceBindingsStats)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ServiceBindingsStats(ctx, field.Selections, &res)
}

var serviceBindingsStatsImplementors = []string{"ServiceBindingsStats"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ServiceBindingsStats(ctx context.Context, sel ast.SelectionSet, obj *ServiceBindingsStats) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, serviceBindingsStatsImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceBindingsStats")
		case "ready":
			out.Values[i] = ec._ServiceBindingsStats_ready(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "failed":
			out.Values[i] = ec._ServiceBindingsStats_failed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "pending":
			out.Values[i] = ec._ServiceBindingsStats_pending(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "unknown":
			out.Values[i] = ec._ServiceBindingsStats_unknown(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBindingsStats_ready(ctx context.Context, field graphql.CollectedField, obj *ServiceBindingsStats) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBindingsStats",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ready, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBindingsStats_failed(ctx context.Context, field graphql.CollectedField, obj *ServiceBindingsStats) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBindingsStats",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Failed, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBindingsStats_pending(ctx context.Context, field graphql.CollectedField, obj *ServiceBindingsStats) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBindingsStats",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Pending, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBindingsStats_unknown(ctx context.Context, field graphql.CollectedField, obj *ServiceBindingsStats) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBindingsStats",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Unknown, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

var serviceBrokerImplementors = []string{"ServiceBroker"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ServiceBroker(ctx context.Context, sel ast.SelectionSet, obj *ServiceBroker) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, serviceBrokerImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceBroker")
		case "name":
			out.Values[i] = ec._ServiceBroker_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "namespace":
			out.Values[i] = ec._ServiceBroker_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "status":
			out.Values[i] = ec._ServiceBroker_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "creationTimestamp":
			out.Values[i] = ec._ServiceBroker_creationTimestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "url":
			out.Values[i] = ec._ServiceBroker_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "labels":
			out.Values[i] = ec._ServiceBroker_labels(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBroker_name(ctx context.Context, field graphql.CollectedField, obj *ServiceBroker) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBroker",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBroker_namespace(ctx context.Context, field graphql.CollectedField, obj *ServiceBroker) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBroker",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBroker_status(ctx context.Context, field graphql.CollectedField, obj *ServiceBroker) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBroker",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ServiceBrokerStatus)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ServiceBrokerStatus(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBroker_creationTimestamp(ctx context.Context, field graphql.CollectedField, obj *ServiceBroker) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBroker",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTimestamp, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return MarshalTimestamp(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBroker_url(ctx context.Context, field graphql.CollectedField, obj *ServiceBroker) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBroker",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBroker_labels(ctx context.Context, field graphql.CollectedField, obj *ServiceBroker) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBroker",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Labels)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

var serviceBrokerEventImplementors = []string{"ServiceBrokerEvent"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ServiceBrokerEvent(ctx context.Context, sel ast.SelectionSet, obj *ServiceBrokerEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, serviceBrokerEventImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceBrokerEvent")
		case "type":
			out.Values[i] = ec._ServiceBrokerEvent_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "serviceBroker":
			out.Values[i] = ec._ServiceBrokerEvent_serviceBroker(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBrokerEvent_type(ctx context.Context, field graphql.CollectedField, obj *ServiceBrokerEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBrokerEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SubscriptionEventType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBrokerEvent_serviceBroker(ctx context.Context, field graphql.CollectedField, obj *ServiceBrokerEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBrokerEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServiceBroker, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ServiceBroker)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ServiceBroker(ctx, field.Selections, &res)
}

var serviceBrokerStatusImplementors = []string{"ServiceBrokerStatus"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ServiceBrokerStatus(ctx context.Context, sel ast.SelectionSet, obj *ServiceBrokerStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, serviceBrokerStatusImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceBrokerStatus")
		case "ready":
			out.Values[i] = ec._ServiceBrokerStatus_ready(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "reason":
			out.Values[i] = ec._ServiceBrokerStatus_reason(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "message":
			out.Values[i] = ec._ServiceBrokerStatus_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBrokerStatus_ready(ctx context.Context, field graphql.CollectedField, obj *ServiceBrokerStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBrokerStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ready, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBrokerStatus_reason(ctx context.Context, field graphql.CollectedField, obj *ServiceBrokerStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBrokerStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reason, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBrokerStatus_message(ctx context.Context, field graphql.CollectedField, obj *ServiceBrokerStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBrokerStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var serviceClassImplementors = []string{"ServiceClass"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ServiceClass(ctx context.Context, sel ast.SelectionSet, obj *ServiceClass) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, serviceClassImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceClass")
		case "name":
			out.Values[i] = ec._ServiceClass_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "namespace":
			out.Values[i] = ec._ServiceClass_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "externalName":
			out.Values[i] = ec._ServiceClass_externalName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "displayName":
			out.Values[i] = ec._ServiceClass_displayName(ctx, field, obj)
		case "creationTimestamp":
			out.Values[i] = ec._ServiceClass_creationTimestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec._ServiceClass_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "longDescription":
			out.Values[i] = ec._ServiceClass_longDescription(ctx, field, obj)
		case "imageUrl":
			out.Values[i] = ec._ServiceClass_imageUrl(ctx, field, obj)
		case "documentationUrl":
			out.Values[i] = ec._ServiceClass_documentationUrl(ctx, field, obj)
		case "supportUrl":
			out.Values[i] = ec._ServiceClass_supportUrl(ctx, field, obj)
		case "providerDisplayName":
			out.Values[i] = ec._ServiceClass_providerDisplayName(ctx, field, obj)
		case "tags":
			out.Values[i] = ec._ServiceClass_tags(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "labels":
			out.Values[i] = ec._ServiceClass_labels(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "plans":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ServiceClass_plans(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "activated":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ServiceClass_activated(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "instances":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ServiceClass_instances(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "apiSpec":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ServiceClass_apiSpec(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "openApiSpec":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ServiceClass_openApiSpec(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "odataSpec":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ServiceClass_odataSpec(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "asyncApiSpec":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ServiceClass_asyncApiSpec(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "content":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ServiceClass_content(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "clusterDocsTopic":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ServiceClass_clusterDocsTopic(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "docsTopic":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ServiceClass_docsTopic(ctx, field, obj)
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ServiceClass_name(ctx context.Context, field graphql.CollectedField, obj *ServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceClass_namespace(ctx context.Context, field graphql.CollectedField, obj *ServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceClass_externalName(ctx context.Context, field graphql.CollectedField, obj *ServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExternalName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceClass_displayName(ctx context.Context, field graphql.CollectedField, obj *ServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceClass_creationTimestamp(ctx context.Context, field graphql.CollectedField, obj *ServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTimestamp, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return MarshalTimestamp(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceClass_description(ctx context.Context, field graphql.CollectedField, obj *ServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceClass_longDescription(ctx context.Context, field graphql.CollectedField, obj *ServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LongDescription, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceClass_imageUrl(ctx context.Context, field graphql.CollectedField, obj *ServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImageURL, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceClass_documentationUrl(ctx context.Context, field graphql.CollectedField, obj *ServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DocumentationURL, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceClass_supportUrl(ctx context.Context, field graphql.CollectedField, obj *ServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SupportURL, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceClass_providerDisplayName(ctx context.Context, field graphql.CollectedField, obj *ServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProviderDisplayName, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceClass_tags(ctx context.Context, field graphql.CollectedField, obj *ServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tags, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return graphql.MarshalString(res[idx1])
		}()
	}

	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _ServiceClass_labels(ctx context.Context, field graphql.CollectedField, obj *ServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Labels)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _ServiceClass_plans(ctx context.Context, field graphql.CollectedField, obj *ServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ServiceClass().Plans(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]ServicePlan)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._ServicePlan(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _ServiceClass_activated(ctx context.Context, field graphql.CollectedField, obj *ServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ServiceClass().Activated(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceClass_instances(ctx context.Context, field graphql.CollectedField, obj *ServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ServiceClass().Instances(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]ServiceInstance)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._ServiceInstance(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _ServiceClass_apiSpec(ctx context.Context, field graphql.CollectedField, obj *ServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ServiceClass().APISpec(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*JSON)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return *res
}

// nolint: vetshadow
func (ec *executionContext) _ServiceClass_openApiSpec(ctx context.Context, field graphql.CollectedField, obj *ServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ServiceClass().OpenAPISpec(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*JSON)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return *res
}

// nolint: vetshadow
func (ec *executionContext) _ServiceClass_odataSpec(ctx context.Context, field graphql.CollectedField, obj *ServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ServiceClass().OdataSpec(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceClass_asyncApiSpec(ctx context.Context, field graphql.CollectedField, obj *ServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ServiceClass().AsyncAPISpec(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*JSON)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return *res
}

// nolint: vetshadow
func (ec *executionContext) _ServiceClass_content(ctx context.Context, field graphql.CollectedField, obj *ServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ServiceClass().Content(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*JSON)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return *res
}

// nolint: vetshadow
func (ec *executionContext) _ServiceClass_clusterDocsTopic(ctx context.Context, field graphql.CollectedField, obj *ServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ServiceClass().ClusterDocsTopic(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ClusterDocsTopic)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ClusterDocsTopic(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceClass_docsTopic(ctx context.Context, field graphql.CollectedField, obj *ServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ServiceClass().DocsTopic(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*DocsTopic)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._DocsTopic(ctx, field.Selections, res)
}

var serviceEventImplementors = []string{"ServiceEvent"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ServiceEvent(ctx context.Context, sel ast.SelectionSet, obj *ServiceEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, serviceEventImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceEvent")
		case "type":
			out.Values[i] = ec._ServiceEvent_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "service":
			out.Values[i] = ec._ServiceEvent_service(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ServiceEvent_type(ctx context.Context, field graphql.CollectedField, obj *ServiceEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SubscriptionEventType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _ServiceEvent_service(ctx context.Context, field graphql.CollectedField, obj *ServiceEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Service, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Service)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Service(ctx, field.Selections, &res)
}

var serviceInstanceImplementors = []string{"ServiceInstance"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ServiceInstance(ctx context.Context, sel ast.SelectionSet, obj *ServiceInstance) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, serviceInstanceImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceInstance")
		case "name":
			out.Values[i] = ec._ServiceInstance_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "namespace":
			out.Values[i] = ec._ServiceInstance_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "planSpec":
			out.Values[i] = ec._ServiceInstance_planSpec(ctx, field, obj)
		case "creationTimestamp":
			out.Values[i] = ec._ServiceInstance_creationTimestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "labels":
			out.Values[i] = ec._ServiceInstance_labels(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "status":
			out.Values[i] = ec._ServiceInstance_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "classReference":
			out.Values[i] = ec._ServiceInstance_classReference(ctx, field, obj)
		case "planReference":
			out.Values[i] = ec._ServiceInstance_planReference(ctx, field, obj)
		case "serviceClass":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ServiceInstance_serviceClass(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "clusterServiceClass":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ServiceInstance_clusterServiceClass(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "servicePlan":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ServiceInstance_servicePlan(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "clusterServicePlan":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ServiceInstance_clusterServicePlan(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "bindable":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ServiceInstance_bindable(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "serviceBindings":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ServiceInstance_serviceBindings(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "serviceBindingUsages":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ServiceInstance_serviceBindingUsages(ctx, field, obj)
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ServiceInstance_name(ctx context.Context, field graphql.CollectedField, obj *ServiceInstance) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceInstance",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceInstance_namespace(ctx context.Context, field graphql.CollectedField, obj *ServiceInstance) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceInstance",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceInstance_planSpec(ctx context.Context, field graphql.CollectedField, obj *ServiceInstance) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceInstance",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PlanSpec, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*JSON)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return *res
}

// nolint: vetshadow
func (ec *executionContext) _ServiceInstance_creationTimestamp(ctx context.Context, field graphql.CollectedField, obj *ServiceInstance) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceInstance",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTimestamp, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return MarshalTimestamp(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceInstance_labels(ctx context.Context, field graphql.CollectedField, obj *ServiceInstance) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceInstance",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return graphql.MarshalString(res[idx1])
		}()
	}

	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _ServiceInstance_status(ctx context.Context, field graphql.CollectedField, obj *ServiceInstance) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceInstance",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ServiceInstanceStatus)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ServiceInstanceStatus(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceInstance_classReference(ctx context.Context, field graphql.CollectedField, obj *ServiceInstance) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceInstance",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClassReference, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ServiceInstanceResourceRef)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ServiceInstanceResourceRef(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceInstance_planReference(ctx context.Context, field graphql.CollectedField, obj *ServiceInstance) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceInstance",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PlanReference, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ServiceInstanceResourceRef)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ServiceInstanceResourceRef(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceInstance_serviceClass(ctx context.Context, field graphql.CollectedField, obj *ServiceInstance) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceInstance",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ServiceInstance().ServiceClass(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ServiceClass)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ServiceClass(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceInstance_clusterServiceClass(ctx context.Context, field graphql.CollectedField, obj *ServiceInstance) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceInstance",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ServiceInstance().ClusterServiceClass(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ClusterServiceClass)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ClusterServiceClass(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceInstance_servicePlan(ctx context.Context, field graphql.CollectedField, obj *ServiceInstance) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceInstance",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ServiceInstance().ServicePlan(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ServicePlan)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ServicePlan(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceInstance_clusterServicePlan(ctx context.Context, field graphql.CollectedField, obj *ServiceInstance) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceInstance",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ServiceInstance().ClusterServicePlan(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ClusterServicePlan)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ClusterServicePlan(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceInstance_bindable(ctx context.Context, field graphql.CollectedField, obj *ServiceInstance) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceInstance",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ServiceInstance().Bindable(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceInstance_serviceBindings(ctx context.Context, field graphql.CollectedField, obj *ServiceInstance) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceInstance",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ServiceInstance().ServiceBindings(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ServiceBindings)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ServiceBindings(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceInstance_serviceBindingUsages(ctx context.Context, field graphql.CollectedField, obj *ServiceInstance) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceInstance",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ServiceInstance().ServiceBindingUsages(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]ServiceBindingUsage)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._ServiceBindingUsage(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var serviceInstanceEventImplementors = []string{"ServiceInstanceEvent"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ServiceInstanceEvent(ctx context.Context, sel ast.SelectionSet, obj *ServiceInstanceEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, serviceInstanceEventImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceInstanceEvent")
		case "type":
			out.Values[i] = ec._ServiceInstanceEvent_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "serviceInstance":
			out.Values[i] = ec._ServiceInstanceEvent_serviceInstance(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ServiceInstanceEvent_type(ctx context.Context, field graphql.CollectedField, obj *ServiceInstanceEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceInstanceEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SubscriptionEventType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _ServiceInstanceEvent_serviceInstance(ctx context.Context, field graphql.CollectedField, obj *ServiceInstanceEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceInstanceEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServiceInstance, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ServiceInstance)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ServiceInstance(ctx, field.Selections, &res)
}

var serviceInstanceResourceRefImplementors = []string{"ServiceInstanceResourceRef"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ServiceInstanceResourceRef(ctx context.Context, sel ast.SelectionSet, obj *ServiceInstanceResourceRef) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, serviceInstanceResourceRefImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceInstanceResourceRef")
		case "name":
			out.Values[i] = ec._ServiceInstanceResourceRef_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "displayName":
			out.Values[i] = ec._ServiceInstanceResourceRef_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "clusterWide":
			out.Values[i] = ec._ServiceInstanceResourceRef_clusterWide(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ServiceInstanceResourceRef_name(ctx context.Context, field graphql.CollectedField, obj *ServiceInstanceResourceRef) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceInstanceResourceRef",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceInstanceResourceRef_displayName(ctx context.Context, field graphql.CollectedField, obj *ServiceInstanceResourceRef) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceInstanceResourceRef",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceInstanceResourceRef_clusterWide(ctx context.Context, field graphql.CollectedField, obj *ServiceInstanceResourceRef) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceInstanceResourceRef",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClusterWide, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

var serviceInstanceStatusImplementors = []string{"ServiceInstanceStatus"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ServiceInstanceStatus(ctx context.Context, sel ast.SelectionSet, obj *ServiceInstanceStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, serviceInstanceStatusImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceInstanceStatus")
		case "type":
			out.Values[i] = ec._ServiceInstanceStatus_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "reason":
			out.Values[i] = ec._ServiceInstanceStatus_reason(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "message":
			out.Values[i] = ec._ServiceInstanceStatus_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ServiceInstanceStatus_type(ctx context.Context, field graphql.CollectedField, obj *ServiceInstanceStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceInstanceStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(InstanceStatusType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _ServiceInstanceStatus_reason(ctx context.Context, field graphql.CollectedField, obj *ServiceInstanceStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceInstanceStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reason, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceInstanceStatus_message(ctx context.Context, field graphql.CollectedField, obj *ServiceInstanceStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceInstanceStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var servicePlanImplementors = []string{"ServicePlan"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ServicePlan(ctx context.Context, sel ast.SelectionSet, obj *ServicePlan) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, servicePlanImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServicePlan")
		case "name":
			out.Values[i] = ec._ServicePlan_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "namespace":
			out.Values[i] = ec._ServicePlan_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "displayName":
			out.Values[i] = ec._ServicePlan_displayName(ctx, field, obj)
		case "externalName":
			out.Values[i] = ec._ServicePlan_externalName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec._ServicePlan_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "relatedServiceClassName":
			out.Values[i] = ec._ServicePlan_relatedServiceClassName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "instanceCreateParameterSchema":
			out.Values[i] = ec._ServicePlan_instanceCreateParameterSchema(ctx, field, obj)
		case "bindingCreateParameterSchema":
			out.Values[i] = ec._ServicePlan_bindingCreateParameterSchema(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ServicePlan_name(ctx context.Context, field graphql.CollectedField, obj *ServicePlan) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServicePlan",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServicePlan_namespace(ctx context.Context, field graphql.CollectedField, obj *ServicePlan) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServicePlan",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServicePlan_displayName(ctx context.Context, field graphql.CollectedField, obj *ServicePlan) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServicePlan",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ServicePlan_externalName(ctx context.Context, field graphql.CollectedField, obj *ServicePlan) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServicePlan",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExternalName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServicePlan_description(ctx context.Context, field graphql.CollectedField, obj *ServicePlan) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServicePlan",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServicePlan_relatedServiceClassName(ctx context.Context, field graphql.CollectedField, obj *ServicePlan) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServicePlan",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RelatedServiceClassName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServicePlan_instanceCreateParameterSchema(ctx context.Context, field graphql.CollectedField, obj *ServicePlan) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServicePlan",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InstanceCreateParameterSchema, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*JSON)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return *res
}

// nolint: vetshadow
func (ec *executionContext) _ServicePlan_bindingCreateParameterSchema(ctx context.Context, field graphql.CollectedField, obj *ServicePlan) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServicePlan",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BindingCreateParameterSchema, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*JSON)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return *res
}

var servicePortImplementors = []string{"ServicePort"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ServicePort(ctx context.Context, sel ast.SelectionSet, obj *ServicePort) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, servicePortImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServicePort")
		case "name":
			out.Values[i] = ec._ServicePort_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "serviceProtocol":
			out.Values[i] = ec._ServicePort_serviceProtocol(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "port":
			out.Values[i] = ec._ServicePort_port(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "nodePort":
			out.Values[i] = ec._ServicePort_nodePort(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "targetPort":
			out.Values[i] = ec._ServicePort_targetPort(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ServicePort_name(ctx context.Context, field graphql.CollectedField, obj *ServicePort) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServicePort",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServicePort_serviceProtocol(ctx context.Context, field graphql.CollectedField, obj *ServicePort) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServicePort",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServiceProtocol, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ServiceProtocol)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _ServicePort_port(ctx context.Context, field graphql.CollectedField, obj *ServicePort) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServicePort",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Port, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServicePort_nodePort(ctx context.Context, field graphql.CollectedField, obj *ServicePort) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServicePort",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NodePort, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServicePort_targetPort(ctx context.Context, field graphql.CollectedField, obj *ServicePort) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServicePort",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TargetPort, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

var serviceStatusImplementors = []string{"ServiceStatus"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ServiceStatus(ctx context.Context, sel ast.SelectionSet, obj *ServiceStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, serviceStatusImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceStatus")
		case "loadBalancer":
			out.Values[i] = ec._ServiceStatus_loadBalancer(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ServiceStatus_loadBalancer(ctx context.Context, field graphql.CollectedField, obj *ServiceStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LoadBalancer, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(LoadBalancerStatus)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._LoadBalancerStatus(ctx, field.Selections, &res)
}

var subscriptionImplementors = []string{"Subscription"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Subscription(ctx context.Context, sel ast.SelectionSet) func() graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, subscriptionImplementors)
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Subscription",
	})
	if len(fields) != 1 {
		ec.Errorf(ctx, "must subscribe to exactly one stream")
		return nil
	}

	switch fields[0].Name {
	case "clusterAssetEvent":
		return ec._Subscription_clusterAssetEvent(ctx, fields[0])
	case "assetEvent":
		return ec._Subscription_assetEvent(ctx, fields[0])
	case "clusterDocsTopicEvent":
		return ec._Subscription_clusterDocsTopicEvent(ctx, fields[0])
	case "docsTopicEvent":
		return ec._Subscription_docsTopicEvent(ctx, fields[0])
	case "serviceInstanceEvent":
		return ec._Subscription_serviceInstanceEvent(ctx, fields[0])
	case "serviceBindingEvent":
		return ec._Subscription_serviceBindingEvent(ctx, fields[0])
	case "serviceBindingUsageEvent":
		return ec._Subscription_serviceBindingUsageEvent(ctx, fields[0])
	case "serviceBrokerEvent":
		return ec._Subscription_serviceBrokerEvent(ctx, fields[0])
	case "clusterServiceBrokerEvent":
		return ec._Subscription_clusterServiceBrokerEvent(ctx, fields[0])
	case "applicationEvent":
		return ec._Subscription_applicationEvent(ctx, fields[0])
	case "podEvent":
		return ec._Subscription_podEvent(ctx, fields[0])
	case "serviceEvent":
		return ec._Subscription_serviceEvent(ctx, fields[0])
	case "configMapEvent":
		return ec._Subscription_configMapEvent(ctx, fields[0])
	case "addonsConfigurationEvent":
		return ec._Subscription_addonsConfigurationEvent(ctx, fields[0])
	default:
		panic("unknown field " + strconv.Quote(fields[0].Name))
	}
}

func (ec *executionContext) _Subscription_clusterAssetEvent(ctx context.Context, field graphql.CollectedField) func() graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Field: field,
	})
	// FIXME: subscriptions are missing request middleware stack https://github.com/99designs/gqlgen/issues/259
	//          and Tracer stack
	rctx := ctx
	results, err := ec.resolvers.Subscription().ClusterAssetEvent(rctx)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-results
		if !ok {
			return nil
		}
		var out graphql.OrderedMap
		out.Add(field.Alias, func() graphql.Marshaler {
			return ec._ClusterAssetEvent(ctx, field.Selections, &res)
		}())
		return &out
	}
}

func (ec *executionContext) _Subscription_assetEvent(ctx context.Context, field graphql.CollectedField) func() graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Subscription_assetEvent_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Field: field,
	})
	// FIXME: subscriptions are missing request middleware stack https://github.com/99designs/gqlgen/issues/259
	//          and Tracer stack
	rctx := ctx
	results, err := ec.resolvers.Subscription().AssetEvent(rctx, args["namespace"].(string))
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-results
		if !ok {
			return nil
		}
		var out graphql.OrderedMap
		out.Add(field.Alias, func() graphql.Marshaler {
			return ec._AssetEvent(ctx, field.Selections, &res)
		}())
		return &out
	}
}

func (ec *executionContext) _Subscription_clusterDocsTopicEvent(ctx context.Context, field graphql.CollectedField) func() graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Field: field,
	})
	// FIXME: subscriptions are missing request middleware stack https://github.com/99designs/gqlgen/issues/259
	//          and Tracer stack
	rctx := ctx
	results, err := ec.resolvers.Subscription().ClusterDocsTopicEvent(rctx)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-results
		if !ok {
			return nil
		}
		var out graphql.OrderedMap
		out.Add(field.Alias, func() graphql.Marshaler {
			return ec._ClusterDocsTopicEvent(ctx, field.Selections, &res)
		}())
		return &out
	}
}

func (ec *executionContext) _Subscription_docsTopicEvent(ctx context.Context, field graphql.CollectedField) func() graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Subscription_docsTopicEvent_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Field: field,
	})
	// FIXME: subscriptions are missing request middleware stack https://github.com/99designs/gqlgen/issues/259
	//          and Tracer stack
	rctx := ctx
	results, err := ec.resolvers.Subscription().DocsTopicEvent(rctx, args["namespace"].(string))
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-results
		if !ok {
			return nil
		}
		var out graphql.OrderedMap
		out.Add(field.Alias, func() graphql.Marshaler {
			return ec._DocsTopicEvent(ctx, field.Selections, &res)
		}())
		return &out
	}
}

func (ec *executionContext) _Subscription_serviceInstanceEvent(ctx context.Context, field graphql.CollectedField) func() graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Subscription_serviceInstanceEvent_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Field: field,
	})
	// FIXME: subscriptions are missing request middleware stack https://github.com/99designs/gqlgen/issues/259
	//          and Tracer stack
	rctx := ctx
	results, err := ec.resolvers.Subscription().ServiceInstanceEvent(rctx, args["namespace"].(string))
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-results
		if !ok {
			return nil
		}
		var out graphql.OrderedMap
		out.Add(field.Alias, func() graphql.Marshaler {
			return ec._ServiceInstanceEvent(ctx, field.Selections, &res)
		}())
		return &out
	}
}

func (ec *executionContext) _Subscription_serviceBindingEvent(ctx context.Context, field graphql.CollectedField) func() graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Subscription_serviceBindingEvent_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Field: field,
	})
	// FIXME: subscriptions are missing request middleware stack https://github.com/99designs/gqlgen/issues/259
	//          and Tracer stack
	rctx := ctx
	results, err := ec.resolvers.Subscription().ServiceBindingEvent(rctx, args["namespace"].(string))
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-results
		if !ok {
			return nil
		}
		var out graphql.OrderedMap
		out.Add(field.Alias, func() graphql.Marshaler {
			return ec._ServiceBindingEvent(ctx, field.Selections, &res)
		}())
		return &out
	}
}

func (ec *executionContext) _Subscription_serviceBindingUsageEvent(ctx context.Context, field graphql.CollectedField) func() graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Subscription_serviceBindingUsageEvent_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Field: field,
	})
	// FIXME: subscriptions are missing request middleware stack https://github.com/99designs/gqlgen/issues/259
	//          and Tracer stack
	rctx := ctx
	results, err := ec.resolvers.Subscription().ServiceBindingUsageEvent(rctx, args["namespace"].(string))
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-results
		if !ok {
			return nil
		}
		var out graphql.OrderedMap
		out.Add(field.Alias, func() graphql.Marshaler {
			return ec._ServiceBindingUsageEvent(ctx, field.Selections, &res)
		}())
		return &out
	}
}

func (ec *executionContext) _Subscription_serviceBrokerEvent(ctx context.Context, field graphql.CollectedField) func() graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Subscription_serviceBrokerEvent_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Field: field,
	})
	// FIXME: subscriptions are missing request middleware stack https://github.com/99designs/gqlgen/issues/259
	//          and Tracer stack
	rctx := ctx
	results, err := ec.resolvers.Subscription().ServiceBrokerEvent(rctx, args["namespace"].(string))
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-results
		if !ok {
			return nil
		}
		var out graphql.OrderedMap
		out.Add(field.Alias, func() graphql.Marshaler {
			return ec._ServiceBrokerEvent(ctx, field.Selections, &res)
		}())
		return &out
	}
}

func (ec *executionContext) _Subscription_clusterServiceBrokerEvent(ctx context.Context, field graphql.CollectedField) func() graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Field: field,
	})
	// FIXME: subscriptions are missing request middleware stack https://github.com/99designs/gqlgen/issues/259
	//          and Tracer stack
	rctx := ctx
	results, err := ec.resolvers.Subscription().ClusterServiceBrokerEvent(rctx)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-results
		if !ok {
			return nil
		}
		var out graphql.OrderedMap
		out.Add(field.Alias, func() graphql.Marshaler {
			return ec._ClusterServiceBrokerEvent(ctx, field.Selections, &res)
		}())
		return &out
	}
}

func (ec *executionContext) _Subscription_applicationEvent(ctx context.Context, field graphql.CollectedField) func() graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Field: field,
	})
	// FIXME: subscriptions are missing request middleware stack https://github.com/99designs/gqlgen/issues/259
	//          and Tracer stack
	rctx := ctx
	results, err := ec.resolvers.Subscription().ApplicationEvent(rctx)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-results
		if !ok {
			return nil
		}
		var out graphql.OrderedMap
		out.Add(field.Alias, func() graphql.Marshaler {
			return ec._ApplicationEvent(ctx, field.Selections, &res)
		}())
		return &out
	}
}

func (ec *executionContext) _Subscription_podEvent(ctx context.Context, field graphql.CollectedField) func() graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Subscription_podEvent_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Field: field,
	})
	// FIXME: subscriptions are missing request middleware stack https://github.com/99designs/gqlgen/issues/259
	//          and Tracer stack
	rctx := ctx
	results, err := ec.resolvers.Subscription().PodEvent(rctx, args["namespace"].(string))
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-results
		if !ok {
			return nil
		}
		var out graphql.OrderedMap
		out.Add(field.Alias, func() graphql.Marshaler {
			return ec._PodEvent(ctx, field.Selections, &res)
		}())
		return &out
	}
}

func (ec *executionContext) _Subscription_serviceEvent(ctx context.Context, field graphql.CollectedField) func() graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Subscription_serviceEvent_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Field: field,
	})
	// FIXME: subscriptions are missing request middleware stack https://github.com/99designs/gqlgen/issues/259
	//          and Tracer stack
	rctx := ctx
	results, err := ec.resolvers.Subscription().ServiceEvent(rctx, args["namespace"].(string))
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-results
		if !ok {
			return nil
		}
		var out graphql.OrderedMap
		out.Add(field.Alias, func() graphql.Marshaler {
			return ec._ServiceEvent(ctx, field.Selections, &res)
		}())
		return &out
	}
}

func (ec *executionContext) _Subscription_configMapEvent(ctx context.Context, field graphql.CollectedField) func() graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Subscription_configMapEvent_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Field: field,
	})
	// FIXME: subscriptions are missing request middleware stack https://github.com/99designs/gqlgen/issues/259
	//          and Tracer stack
	rctx := ctx
	results, err := ec.resolvers.Subscription().ConfigMapEvent(rctx, args["namespace"].(string))
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-results
		if !ok {
			return nil
		}
		var out graphql.OrderedMap
		out.Add(field.Alias, func() graphql.Marshaler {
			return ec._ConfigMapEvent(ctx, field.Selections, &res)
		}())
		return &out
	}
}

func (ec *executionContext) _Subscription_addonsConfigurationEvent(ctx context.Context, field graphql.CollectedField) func() graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Field: field,
	})
	// FIXME: subscriptions are missing request middleware stack https://github.com/99designs/gqlgen/issues/259
	//          and Tracer stack
	rctx := ctx
	results, err := ec.resolvers.Subscription().AddonsConfigurationEvent(rctx)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-results
		if !ok {
			return nil
		}
		var out graphql.OrderedMap
		out.Add(field.Alias, func() graphql.Marshaler {
			return ec._AddonsConfigurationEvent(ctx, field.Selections, &res)
		}())
		return &out
	}
}

var titleImplementors = []string{"Title"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Title(ctx context.Context, sel ast.SelectionSet, obj *Title) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, titleImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Title")
		case "name":
			out.Values[i] = ec._Title_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "anchor":
			out.Values[i] = ec._Title_anchor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "titles":
			out.Values[i] = ec._Title_titles(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Title_name(ctx context.Context, field graphql.CollectedField, obj *Title) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Title",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Title_anchor(ctx context.Context, field graphql.CollectedField, obj *Title) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Title",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Anchor, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Title_titles(ctx context.Context, field graphql.CollectedField, obj *Title) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Title",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Titles, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]Title)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Title(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var topicEntryImplementors = []string{"TopicEntry"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _TopicEntry(ctx context.Context, sel ast.SelectionSet, obj *TopicEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, topicEntryImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TopicEntry")
		case "contentType":
			out.Values[i] = ec._TopicEntry_contentType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "id":
			out.Values[i] = ec._TopicEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "sections":
			out.Values[i] = ec._TopicEntry_sections(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _TopicEntry_contentType(ctx context.Context, field graphql.CollectedField, obj *TopicEntry) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "TopicEntry",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContentType, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _TopicEntry_id(ctx context.Context, field graphql.CollectedField, obj *TopicEntry) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "TopicEntry",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _TopicEntry_sections(ctx context.Context, field graphql.CollectedField, obj *TopicEntry) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "TopicEntry",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sections, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]Section)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Section(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var usageKindImplementors = []string{"UsageKind"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _UsageKind(ctx context.Context, sel ast.SelectionSet, obj *UsageKind) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, usageKindImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UsageKind")
		case "name":
			out.Values[i] = ec._UsageKind_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "group":
			out.Values[i] = ec._UsageKind_group(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "kind":
			out.Values[i] = ec._UsageKind_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "version":
			out.Values[i] = ec._UsageKind_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "displayName":
			out.Values[i] = ec._UsageKind_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _UsageKind_name(ctx context.Context, field graphql.CollectedField, obj *UsageKind) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "UsageKind",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _UsageKind_group(ctx context.Context, field graphql.CollectedField, obj *UsageKind) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "UsageKind",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Group, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _UsageKind_kind(ctx context.Context, field graphql.CollectedField, obj *UsageKind) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "UsageKind",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _UsageKind_version(ctx context.Context, field graphql.CollectedField, obj *UsageKind) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "UsageKind",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _UsageKind_displayName(ctx context.Context, field graphql.CollectedField, obj *UsageKind) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "UsageKind",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var usageKindResourceImplementors = []string{"UsageKindResource"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _UsageKindResource(ctx context.Context, sel ast.SelectionSet, obj *UsageKindResource) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, usageKindResourceImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UsageKindResource")
		case "name":
			out.Values[i] = ec._UsageKindResource_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "namespace":
			out.Values[i] = ec._UsageKindResource_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _UsageKindResource_name(ctx context.Context, field graphql.CollectedField, obj *UsageKindResource) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "UsageKindResource",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _UsageKindResource_namespace(ctx context.Context, field graphql.CollectedField, obj *UsageKindResource) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "UsageKindResource",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var __DirectiveImplementors = []string{"__Directive"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __DirectiveImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Directive",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Directive",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Directive",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return graphql.MarshalString(res[idx1])
		}()
	}

	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Directive",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___InputValue(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var __EnumValueImplementors = []string{"__EnumValue"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __EnumValueImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__EnumValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__EnumValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__EnumValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__EnumValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var __FieldImplementors = []string{"__Field"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __FieldImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___InputValue(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var __InputValueImplementors = []string{"__InputValue"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __InputValueImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__InputValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__InputValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__InputValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__InputValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var __SchemaImplementors = []string{"__Schema"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __SchemaImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___Type(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___Directive(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var __TypeImplementors = []string{"__Type"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __TypeImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field___Type_fields_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(args["includeDeprecated"].(bool)), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___Field(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___Type(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___Type(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field___Type_enumValues_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(args["includeDeprecated"].(bool)), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___EnumValue(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___InputValue(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

func UnmarshalCreateServiceBindingUsageInput(v interface{}) (CreateServiceBindingUsageInput, error) {
	var it CreateServiceBindingUsageInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Name = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "serviceBindingRef":
			var err error
			it.ServiceBindingRef, err = UnmarshalServiceBindingRefInput(v)
			if err != nil {
				return it, err
			}
		case "usedBy":
			var err error
			it.UsedBy, err = UnmarshalLocalObjectReferenceInput(v)
			if err != nil {
				return it, err
			}
		case "parameters":
			var err error
			var ptr1 ServiceBindingUsageParametersInput
			if v != nil {
				ptr1, err = UnmarshalServiceBindingUsageParametersInput(v)
				it.Parameters = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalEnvPrefixInput(v interface{}) (EnvPrefixInput, error) {
	var it EnvPrefixInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputTopic(v interface{}) (InputTopic, error) {
	var it InputTopic
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error
			it.Type, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalLocalObjectReferenceInput(v interface{}) (LocalObjectReferenceInput, error) {
	var it LocalObjectReferenceInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "kind":
			var err error
			it.Kind, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalResourceAttributes(v interface{}) (ResourceAttributes, error) {
	var it ResourceAttributes
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "verb":
			var err error
			it.Verb, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "apiGroup":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.APIGroup = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "apiVersion":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.APIVersion = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "resource":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Resource = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "resourceArg":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.ResourceArg = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "subresource":
			var err error
			it.Subresource, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "nameArg":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.NameArg = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "namespaceArg":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.NamespaceArg = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "isChildResolver":
			var err error
			it.IsChildResolver, err = graphql.UnmarshalBoolean(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalServiceBindingRefInput(v interface{}) (ServiceBindingRefInput, error) {
	var it ServiceBindingRefInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalServiceBindingUsageParametersInput(v interface{}) (ServiceBindingUsageParametersInput, error) {
	var it ServiceBindingUsageParametersInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "envPrefix":
			var err error
			var ptr1 EnvPrefixInput
			if v != nil {
				ptr1, err = UnmarshalEnvPrefixInput(v)
				it.EnvPrefix = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalServiceInstanceCreateInput(v interface{}) (ServiceInstanceCreateInput, error) {
	var it ServiceInstanceCreateInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "classRef":
			var err error
			it.ClassRef, err = UnmarshalServiceInstanceCreateInputResourceRef(v)
			if err != nil {
				return it, err
			}
		case "planRef":
			var err error
			it.PlanRef, err = UnmarshalServiceInstanceCreateInputResourceRef(v)
			if err != nil {
				return it, err
			}
		case "labels":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Labels = make([]string, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Labels[idx1], err = graphql.UnmarshalString(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		case "parameterSchema":
			var err error
			var ptr1 JSON
			if v != nil {
				err = (&ptr1).UnmarshalGQL(v)
				it.ParameterSchema = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalServiceInstanceCreateInputResourceRef(v interface{}) (ServiceInstanceCreateInputResourceRef, error) {
	var it ServiceInstanceCreateInputResourceRef
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "externalName":
			var err error
			it.ExternalName, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "clusterWide":
			var err error
			it.ClusterWide, err = graphql.UnmarshalBoolean(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) FieldMiddleware(ctx context.Context, obj interface{}, next graphql.Resolver) (ret interface{}) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	rctx := graphql.GetResolverContext(ctx)
	for _, d := range rctx.Field.Definition.Directives {
		switch d.Name {
		case "HasAccess":
			if ec.directives.HasAccess != nil {
				rawArgs := d.ArgumentMap(ec.Variables)
				args, err := dir_HasAccess_args(rawArgs)
				if err != nil {
					ec.Error(ctx, err)
					return nil
				}
				n := next
				next = func(ctx context.Context) (interface{}, error) {
					return ec.directives.HasAccess(ctx, obj, n, args["attributes"].(ResourceAttributes))
				}
			}
		}
	}
	res, err := ec.ResolverMiddleware(ctx, next)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return res
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var parsedSchema = gqlparser.MustLoadSchema(
	&ast.Source{Name: "schema.graphql", Input: `# Scalars

scalar JSON

scalar Labels

scalar Timestamp

# Directives

directive @HasAccess(attributes: ResourceAttributes!) on FIELD_DEFINITION

input ResourceAttributes {
    verb: String!
    apiGroup: String
    apiVersion: String
    resource: String
    resourceArg: String
    subresource: String! = ""
    nameArg: String
    namespaceArg: String
    isChildResolver: Boolean! = false
}

# Asset Store

type File {
    url: String!
    metadata: JSON!
}

type Asset {
    name: String!
    namespace: String!
    type: String!
    files(filterExtensions: [String!]): [File!]!
    status: AssetStatus!
}

type AssetEvent {
    type: SubscriptionEventType!
    asset: Asset!
}

type ClusterAsset {
    name: String!
    type: String!
    files(filterExtensions: [String!]): [File!]!
    status: AssetStatus!
}

type ClusterAssetEvent {
    type: SubscriptionEventType!
    clusterAsset: ClusterAsset!
}

type AssetStatus {
    phase: AssetPhaseType!
    reason: String!
    message: String!
}

enum AssetPhaseType {
    READY
    PENDING
    FAILED
}

# CMS

type DocsTopic {
    name: String!
    namespace: String!
    groupName: String!
    assets(types: [String!]): [Asset!]!
    displayName: String!
    description: String!
    status: DocsTopicStatus!
}

type DocsTopicEvent {
    type: SubscriptionEventType!
    docsTopic: DocsTopic!
}

type ClusterDocsTopic {
    name: String!
    groupName: String!
    assets(types: [String!]): [ClusterAsset!]!
    displayName: String!
    description: String!
    status: DocsTopicStatus!
}

type ClusterDocsTopicEvent {
    type: SubscriptionEventType!
    clusterDocsTopic: ClusterDocsTopic!
}

type DocsTopicStatus {
    phase: DocsTopicPhaseType!
    reason: String!
    message: String!
}

enum DocsTopicPhaseType {
    READY
    PENDING
    FAILED
}

# Content

type Title {
    name: String!
    anchor: String!
    titles: [Title!]
}

type Section {
    name: String!
    anchor: String!
    titles: [Title!]!
    topicType: String!
}

type TopicEntry {
    contentType: String!
    id: String!
    sections: [Section!]!
}

# Service Catalog

type AddonsConfiguration {
    name: String!
    urls: [String!]
    labels: Labels!
}

type AddonsConfigurationEvent {
    type: SubscriptionEventType!
    addonsConfiguration: AddonsConfiguration!
}

type ServiceInstance {
    name: String!
    namespace: String!
    planSpec: JSON
    creationTimestamp: Timestamp!
    labels: [String!]!
    status: ServiceInstanceStatus!
    classReference: ServiceInstanceResourceRef
    planReference: ServiceInstanceResourceRef
    serviceClass: ServiceClass
    clusterServiceClass: ClusterServiceClass
    servicePlan: ServicePlan
    clusterServicePlan: ClusterServicePlan
    bindable: Boolean!
    serviceBindings: ServiceBindings

    # Depends on servicecatalogaddons domain
    serviceBindingUsages: [ServiceBindingUsage!]
}

type ServiceInstanceResourceRef {
    name: String!
    displayName: String!
    clusterWide: Boolean!
}

type ServiceInstanceStatus {
    type: InstanceStatusType!
    reason: String!
    message: String!
}

enum InstanceStatusType {
    RUNNING
    PROVISIONING
    DEPROVISIONING
    PENDING
    FAILED
}

type ServiceInstanceEvent {
    type: SubscriptionEventType!
    serviceInstance: ServiceInstance!
}

type ServiceBrokerEvent {
    type: SubscriptionEventType!
    serviceBroker: ServiceBroker!
}

type ClusterServiceBrokerEvent {
    type: SubscriptionEventType!
    clusterServiceBroker: ClusterServiceBroker!
}

enum SubscriptionEventType {
    ADD
    UPDATE
    DELETE
}

input ServiceInstanceCreateInput {
    name: String!
    classRef: ServiceInstanceCreateInputResourceRef!
    planRef: ServiceInstanceCreateInputResourceRef!
    labels: [String!]!
    parameterSchema: JSON
}

input ServiceInstanceCreateInputResourceRef {
    externalName: String!
    clusterWide: Boolean!
}

type ServiceClass {
    name: String!
    namespace: String!
    externalName: String!
    displayName: String
    creationTimestamp: Timestamp!
    description: String!
    longDescription: String
    imageUrl: String
    documentationUrl: String
    supportUrl: String
    providerDisplayName: String
    tags: [String!]!
    labels: Labels!
    plans: [ServicePlan!]!
    activated: Boolean!
    instances: [ServiceInstance!]!
    apiSpec: JSON @deprecated(reason: "No longer supported")
    openApiSpec: JSON @deprecated(reason: "No longer supported")
    odataSpec: String @deprecated(reason: "No longer supported")
    asyncApiSpec: JSON @deprecated(reason: "No longer supported")
    content: JSON @deprecated(reason: "No longer supported")

    # Depends on cms domain
    clusterDocsTopic: ClusterDocsTopic
    docsTopic: DocsTopic
}

type ClusterServiceClass {
    name: String!
    externalName: String!
    displayName: String
    creationTimestamp: Timestamp!
    description: String!
    longDescription: String
    imageUrl: String
    documentationUrl: String
    supportUrl: String
    providerDisplayName: String
    tags: [String!]!
    labels: Labels!
    plans: [ClusterServicePlan!]!
    activated(namespace: String): Boolean!
    instances(namespace: String): [ServiceInstance!]!
    apiSpec: JSON @deprecated(reason: "No longer supported")
    openApiSpec: JSON @deprecated(reason: "No longer supported")
    odataSpec: String @deprecated(reason: "No longer supported")
    asyncApiSpec: JSON @deprecated(reason: "No longer supported")
    content: JSON @deprecated(reason: "No longer supported")

    # Depends on cms domain
    clusterDocsTopic: ClusterDocsTopic
}

type ServicePlan {
    name: String!
    namespace: String!
    displayName: String
    externalName: String!
    description: String!
    relatedServiceClassName: String!
    instanceCreateParameterSchema: JSON
    bindingCreateParameterSchema: JSON
}

type ClusterServicePlan {
    name: String!
    displayName: String
    externalName: String!
    description: String!
    relatedClusterServiceClassName: String!
    instanceCreateParameterSchema: JSON
    bindingCreateParameterSchema: JSON
}

type ServiceBroker {
    name: String!
    namespace: String!
    status: ServiceBrokerStatus!
    creationTimestamp: Timestamp!
    url: String!
    labels: Labels!
}

type ClusterServiceBroker {
    name: String!
    status: ServiceBrokerStatus!
    creationTimestamp: Timestamp!
    url: String!
    labels: Labels!
}

type ServiceBrokerStatus {
    ready: Boolean!
    reason: String!
    message: String!
}

type ServiceBindings {
    items: [ServiceBinding!]!
    stats: ServiceBindingsStats!
}

type ServiceBindingsStats {
    ready: Int!
    failed: Int!
    pending: Int!
    unknown: Int!
}

type ServiceBinding {
    name: String!
    serviceInstanceName: String!
    namespace: String!
    secret: Secret
    status: ServiceBindingStatus!
    parameters: JSON
}

type ServiceBindingStatus {
    type: ServiceBindingStatusType!
    reason: String!
    message: String!
}

enum ServiceBindingStatusType {
    READY
    PENDING
    FAILED
    UNKNOWN
}

type ServiceBindingEvent {
    type: SubscriptionEventType!
    serviceBinding: ServiceBinding!
}

# We cannot use ServiceBinding as a result of create action
# because secret at the moment of mutation execution is not available.
type CreateServiceBindingOutput {
    name: String!
    serviceInstanceName: String!
    namespace: String!
}

type Secret {
    name: String!
    namespace: String!
    data: JSON!
    type: String!
    creationTime: Timestamp!
    labels: JSON!
    annotations: JSON!
    json: JSON!
}

type DeleteServiceBindingOutput {
    name: String!
    namespace: String!
}

type DeleteServiceBindingUsageOutput {
    name: String!
    namespace: String!
}

type ServiceBindingUsage {
    name: String!
    namespace: String!
    serviceBinding: ServiceBinding
    usedBy: LocalObjectReference!
    parameters: ServiceBindingUsageParameters
    status: ServiceBindingUsageStatus!
}

type ServiceBindingUsageEvent {
    type: SubscriptionEventType!
    serviceBindingUsage: ServiceBindingUsage!
}

type ServiceBindingUsageStatus {
    type: ServiceBindingUsageStatusType!
    reason: String!
    message: String!
}

enum ServiceBindingUsageStatusType {
    READY
    PENDING
    FAILED
    UNKNOWN
}

type LocalObjectReference {
    kind: String!
    name: String!
}

type ServiceBindingUsageParameters {
    envPrefix: EnvPrefix
}

type EnvPrefix {
    name: String!
}

type LimitRange {
    name: String!
    limits: [LimitRangeItem!]!
}

type LimitRangeItem {
    limitType: LimitType!
    max: ResourceType!
    default: ResourceType!
    defaultRequest: ResourceType!
}

enum LimitType {
    Container
    Pod
}

type ResourceType {
    memory: String
    cpu: String
}

input CreateServiceBindingUsageInput {
    name: String
    serviceBindingRef: ServiceBindingRefInput!
    usedBy: LocalObjectReferenceInput!
    parameters: ServiceBindingUsageParametersInput
}

input ServiceBindingRefInput {
    name: String!
}

input LocalObjectReferenceInput {
    kind: String!
    name: String!
}

input ServiceBindingUsageParametersInput {
    envPrefix: EnvPrefixInput
}

input EnvPrefixInput {
    name: String!
}

type Container {
    name: String!
    image: String!
}

type DeploymentStatus {
    replicas: Int!
    updatedReplicas: Int!
    readyReplicas: Int!
    availableReplicas: Int!
    conditions: [DeploymentCondition!]!
}

type DeploymentCondition {
    status: String!
    type: String!
    lastTransitionTimestamp: Timestamp!
    lastUpdateTimestamp: Timestamp!
    message: String!
    reason: String!
}

type Deployment {
    name: String!
    namespace: String!
    creationTimestamp: Timestamp!
    status: DeploymentStatus!
    labels: Labels!
    containers: [Container!]!

    # Depends on servicecatalog and servicecatalogaddons modules
    boundServiceInstanceNames: [String!]
}

enum ServiceProtocol {
    TCP
    UDP
    UNKNOWN
}

type ServicePort {
    name: String!
    serviceProtocol: ServiceProtocol!
    port: Int!
    nodePort: Int!
    targetPort: Int!
}

type LoadBalancerIngress {
    ip: String!
    hostName: String!
}

type LoadBalancerStatus {
    ingress: [LoadBalancerIngress!]!
}

type ServiceStatus {
    loadBalancer: LoadBalancerStatus!
}

type Service {
    name: String!
    clusterIP: String!
    creationTimestamp: Timestamp!
    labels: Labels!
    ports: [ServicePort!]!
    status: ServiceStatus!
    json: JSON!
}

type Pod {
    name: String!
    nodeName: String!
    namespace: String!
    restartCount: Int!
    creationTimestamp: Timestamp!
    labels: Labels!
    status: PodStatusType!
    containerStates: [ContainerState!]!
    json: JSON!
}

type ReplicaSet {
    name: String!
    pods: String!
    namespace: String!
    images: [String!]!
    creationTimestamp: Timestamp!
    labels: Labels!
    json: JSON!
}

enum PodStatusType {
    PENDING
    RUNNING
    SUCCEEDED
    FAILED
    UNKNOWN
}

type PodEvent {
    type: SubscriptionEventType!
    pod: Pod!
}

type ServiceEvent {
    type: SubscriptionEventType!
    service: Service!
}

type SecretEvent {
    type: SubscriptionEventType!
    secret: Secret!
}

type ContainerState {
    state: ContainerStateType!
    reason: String!
    message: String!
}

enum ContainerStateType {
    WAITING
    RUNNING
    TERMINATED
}

type ResourceValues {
    memory: String
    cpu: String
}

type ResourceQuota {
    name: String!
    pods: String
    limits: ResourceValues!
    requests: ResourceValues!
}

type ResourceQuotasStatus {
    exceeded: Boolean!
    exceededQuotas: [ExceededQuota!]!
}

type ExceededQuota {
    quotaName: String!
    resourceName: String!
    affectedResources: [String!]!
}

# Applications

type Namespace {
    name: String!

    # Depends on application module
    applications: [String!]
}

type Application {
    name: String!
    description: String!
    labels: Labels!
    services: [ApplicationService!]!
    enabledInNamespaces: [String!]!
    status: ApplicationStatus!
}

type ConnectorService {
    url: String!
}

type ApplicationMapping {
    namespace: String!
    application: String!
}

type ApplicationService {
    id: String!
    displayName: String!
    longDescription: String!
    providerDisplayName: String!
    tags: [String!]!
    entries: [ApplicationEntry!]!
}

type ApplicationEntry {
    type: String!
    gatewayUrl: String
    accessLabel: String
}

enum ApplicationStatus {
    SERVING
    NOT_SERVING
    GATEWAY_NOT_CONFIGURED
}

type ApplicationEvent {
    type: SubscriptionEventType!
    application: Application!
}

type ApplicationMutationOutput {
    name: String!
    description: String!
    labels: Labels!
}

type DeleteApplicationOutput {
    name: String!
}

type EventActivationEvent {
    eventType: String!
    version: String!
    description: String!
}

type EventActivation {
    name: String!
    displayName: String!
    sourceId: String!
    events: [EventActivationEvent!] # content module
}

type UsageKind {
    name: String!
    group: String!
    kind: String!
    version: String!
    displayName: String!
}

type UsageKindResource {
    name: String!
    namespace: String!
}

type BindableResourcesOutputItem {
    kind: String!
    displayName: String!
    resources: [UsageKindResource!]!
}

# IDP PRESETS

type IDPPreset {
    name: String!
    issuer: String!
    jwksUri: String!
}

# Kubeless

type Function {
    name: String!
    trigger: String!
    creationTimestamp: Timestamp!
    labels: Labels!
    namespace: String!
}

input InputTopic {
    id: String!
    type: String!
}

# API controller

type ApiService {
    name: String!
    port: Int!
}

enum AuthenticationPolicyType {
    JWT
}

type AuthenticationPolicy  {
    type: AuthenticationPolicyType!
    issuer: String!
    jwksURI: String!
}

type API {
    name: String!
    hostname: String!
    service: ApiService!
    authenticationPolicies: [AuthenticationPolicy!]!
}

# Backend Module
type BackendModule {
    name: String!
}

# Config Maps

type ConfigMap {
    name: String!
    namespace: String!
    creationTimestamp: Timestamp!
    labels: Labels!
    json: JSON!
}

type ConfigMapEvent {
    type: SubscriptionEventType!
    configMap: ConfigMap!
}

# SelfSubjectRules

type ResourceRule {
    verbs: [String!]
    apiGroups: [String!]
    resources: [String!]
}

# Queries

type Query {
    clusterDocsTopics(viewContext: String, groupName: String): [ClusterDocsTopic!]! @HasAccess(attributes: {resource: "clusterdocstopics", verb: "get", apiGroup: "cms.kyma-project.io", apiVersion: "v1alpha1"})

    serviceInstance(name: String!, namespace: String!): ServiceInstance @HasAccess(attributes: {resource: "serviceinstances", verb: "get", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace", nameArg: "name"})
    serviceInstances(namespace: String!, first: Int, offset: Int, status: InstanceStatusType): [ServiceInstance!]! @HasAccess(attributes: {resource: "serviceinstances", verb: "list", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace"})

    clusterServiceClasses(first: Int, offset: Int): [ClusterServiceClass!]! @HasAccess(attributes: {resource: "clusterserviceclasses", verb: "list", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1"})
    clusterServiceClass(name: String!): ClusterServiceClass @HasAccess(attributes: {resource: "clusterserviceclasses", verb: "get", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", nameArg: "name"})
    serviceClasses(namespace: String!, first: Int, offset: Int): [ServiceClass!]! @HasAccess(attributes: {resource: "serviceclasses", verb: "list", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace"})
    serviceClass(namespace: String!, name: String!): ServiceClass @HasAccess(attributes: {resource: "serviceclasses", verb: "get", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace", nameArg: "name"})

    clusterServiceBrokers(first: Int, offset: Int): [ClusterServiceBroker!]! @HasAccess(attributes: {resource: "clusterservicebrokers", verb: "list", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1"})
    clusterServiceBroker(name: String!): ClusterServiceBroker @HasAccess(attributes: {resource: "clusterservicebrokers", verb: "get", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", nameArg: "name"})
    serviceBrokers(namespace: String!, first: Int, offset: Int): [ServiceBroker!]! @HasAccess(attributes: {resource: "servicebrokers", verb: "list", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace"})
    serviceBroker(name: String!, namespace: String!): ServiceBroker @HasAccess(attributes: {resource: "servicebrokers", verb: "get", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace", nameArg: "name"})

    serviceBindingUsage(name: String!, namespace: String!): ServiceBindingUsage @HasAccess(attributes: {resource: "servicebindingusages", verb: "get", apiGroup: "servicecatalog.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace", nameArg: "name"})
    serviceBinding(name: String!, namespace: String!): ServiceBinding @HasAccess(attributes: {resource: "servicebindings", verb: "get", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace", nameArg: "name"})
    usageKinds(first: Int, offset: Int): [UsageKind!]! @HasAccess(attributes: {resource: "usagekinds", verb: "list", apiGroup: "servicecatalog.kyma-project.io", apiVersion: "v1alpha1"})

    addonsConfigurations(first: Int, offset: Int): [AddonsConfiguration!]! @HasAccess(attributes: {resource: "configmaps", verb: "list", apiGroup: "", apiVersion: "v1"})

    # The query returns all instance of the resources which could be bound (proper UsageKind exists).
    bindableResources(namespace: String!): [BindableResourcesOutputItem!]! @HasAccess(attributes: {resource: "usagekinds", verb: "list", apiGroup: "servicecatalog.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace"})

    apis(namespace: String!, serviceName: String, hostname: String): [API!]! @HasAccess(attributes: {resource: "apis", verb: "list", apiGroup: "gateway.kyma-project.io", apiVersion: "v1alpha2", namespaceArg: "namespace"})

    application(name: String!): Application @HasAccess(attributes: {resource: "applications", verb: "get", apiGroup: "applicationconnector.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})
    applications(namespace: String, first: Int, offset: Int): [Application!]! @HasAccess(attributes: {resource: "applicationmappings", verb: "list", apiGroup: "applicationconnector.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace"}) @HasAccess(attributes: {resource: "applications", verb: "list", apiGroup: "applicationconnector.kyma-project.io", apiVersion: "v1alpha1"})
    connectorService(application: String!): ConnectorService! @HasAccess(attributes: {resource: "applications", verb: "create", apiGroup: "applicationconnector.kyma-project.io", apiVersion: "v1alpha1"})

    # Depends on 'application'
    namespaces(application: String): [Namespace!]! @HasAccess(attributes: {resource: "namespaces", verb: "list", apiGroup: "", apiVersion: "v1"})

    deployments(namespace: String!, excludeFunctions: Boolean): [Deployment!]! @HasAccess(attributes: {resource: "deployments", verb: "list", apiGroup: "apps", apiVersion: "v1beta2", namespaceArg: "namespace"})
    pod(name: String!, namespace: String!): Pod @HasAccess(attributes: {resource: "pods", verb: "get", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace", nameArg: "name"})
    pods(namespace: String!, first: Int, offset: Int): [Pod!]! @HasAccess(attributes: {resource: "pods", verb: "list", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})

    service(name: String!, namespace: String!): Service @HasAccess(attributes: {resource: "services", verb: "get", apiGroup: "", apiVersion: "v1"})
    services(namespace: String!, first: Int, offset: Int): [Service!]! @HasAccess(attributes: {resource: "services", verb: "list", apiGroup: "", apiVersion: "v1"})
    configMap(name: String!, namespace: String!): ConfigMap @HasAccess(attributes: {resource: "configmaps", verb: "get", apiGroup: "", apiVersion: "v1", nameArg: "name", namespaceArg: "namespace"})
    configMaps(namespace: String!, first: Int, offset: Int): [ConfigMap!]! @HasAccess(attributes: {resource: "configmaps", verb: "list", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})

    replicaSet(name: String!, namespace: String!): ReplicaSet @HasAccess(attributes: {resource: "replicasets", verb: "get", apiGroup: "apps", apiVersion: "v1", namespaceArg: "namespace", nameArg: "name"})
    replicaSets(namespace: String!, first: Int, offset: Int): [ReplicaSet!]! @HasAccess(attributes: {resource: "replicasets", verb: "list", apiGroup: "apps", apiVersion: "v1", namespaceArg: "namespace"})

    resourceQuotas(namespace: String!): [ResourceQuota!]! @HasAccess(attributes: {resource: "resourcequotas", verb: "list", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})
    resourceQuotasStatus(namespace: String!): ResourceQuotasStatus! @HasAccess(attributes: {resource: "resourcequotas", verb: "list", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})

    functions(namespace: String!, first: Int, offset: Int): [Function!]! @HasAccess(attributes: {resource: "functions", verb: "list", apiGroup: "kubeless.io", apiVersion: "v1beta1", namespaceArg: "namespace"})

    content(contentType: String!, id: String!): JSON @deprecated(reason: "No longer supported")
    topics(input: [InputTopic!]!, internal: Boolean): [TopicEntry!] @deprecated(reason: "No longer supported")
    eventActivations(namespace: String!): [EventActivation!]! @HasAccess(attributes: {resource: "eventactivations", verb: "list", apiGroup: "applicationconnector.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace"})

    limitRanges(namespace: String!): [LimitRange!]! @HasAccess(attributes: {resource: "limitranges", verb: "list", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})

    backendModules: [BackendModule!]! @HasAccess(attributes: {resource: "backendmodules", verb: "list", apiGroup: "ui.kyma-project.io", apiVersion: "v1alpha1"})

    secret(name: String!, namespace: String!): Secret @HasAccess(attributes: {resource: "secrets", verb: "get", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})
    secrets(namespace: String!, first: Int, offset: Int): [Secret!]!  @HasAccess(attributes: {resource: "secrets", verb: "list", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})

    IDPPreset(name: String!): IDPPreset @HasAccess(attributes: {resource: "idppresets", verb: "get", apiGroup: "authentication.kyma-project.io", apiVersion: "v1alpha1"})
    IDPPresets(first: Int, offset: Int): [IDPPreset!]! @HasAccess(attributes: {resource: "idppresets", verb: "list", apiGroup: "authentication.kyma-project.io", apiVersion: "v1alpha1"})
    selfSubjectRules(namespace: String): [ResourceRule!]! @HasAccess(attributes: {apiGroup: "authorization.k8s.io", resource: "selfsubjectrulesreviews", verb: "create", apiVersion: "v1"})
}

# Mutations

type Mutation {
    createResource(namespace: String!, resource: JSON!): JSON @HasAccess(attributes: {verb: "create", resourceArg: "resource", namespaceArg: "namespace"})
    createServiceInstance(namespace: String!, params: ServiceInstanceCreateInput!): ServiceInstance @HasAccess(attributes: {resource: "serviceinstances", verb: "create", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace"})
    deleteServiceInstance(name: String!, namespace: String!): ServiceInstance @HasAccess(attributes: {resource: "serviceinstances", verb: "delete", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace", nameArg: "name"})
    createServiceBinding(serviceBindingName: String, serviceInstanceName: String!, namespace: String!, parameters: JSON): CreateServiceBindingOutput @HasAccess(attributes: {resource: "servicebindings", verb: "create", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace"})
    deleteServiceBinding(serviceBindingName: String!, namespace: String!): DeleteServiceBindingOutput @HasAccess(attributes: {resource: "servicebindings", verb: "delete", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace", nameArg: "serviceBindingName"})
    createServiceBindingUsage(namespace: String!, createServiceBindingUsageInput: CreateServiceBindingUsageInput): ServiceBindingUsage @HasAccess(attributes: {resource: "servicebindingusages", verb: "create", apiGroup: "servicecatalog.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace"})
    deleteServiceBindingUsage(serviceBindingUsageName: String!, namespace: String!): DeleteServiceBindingUsageOutput @HasAccess(attributes: {resource: "servicebindingusages", verb: "delete", apiGroup: "servicecatalog.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace", nameArg: "serviceBindingUsageName"})

    createAddonsConfiguration(name: String!, urls: [String!]!, labels: Labels): AddonsConfiguration @HasAccess(attributes: {resource: "configmaps", verb: "create", apiGroup: "", apiVersion: "v1", nameArg: "name"})
    updateAddonsConfiguration(name: String!, urls: [String!], labels: Labels): AddonsConfiguration @HasAccess(attributes: {resource: "configmaps", verb: "update", apiGroup: "", apiVersion: "v1", nameArg: "name"})
    deleteAddonsConfiguration(name: String!): AddonsConfiguration @HasAccess(attributes: {resource: "configmaps", verb: "delete", apiGroup: "", apiVersion: "v1", nameArg: "name"})
    addAddonsConfigurationURLs(name: String!, urls: [String!]!): AddonsConfiguration @HasAccess(attributes: {resource: "configmaps", verb: "update", apiGroup: "", apiVersion: "v1", nameArg: "name"})
    removeAddonsConfigurationURLs(name: String!, urls: [String!]!): AddonsConfiguration @HasAccess(attributes: {resource: "configmaps", verb: "update", apiGroup: "", apiVersion: "v1", nameArg: "name"})

    createApplication(name: String!, description: String, labels: Labels): ApplicationMutationOutput! @HasAccess(attributes: {resource: "applications", verb: "create", apiGroup: "applicationconnector.kyma-project.io", apiVersion: "v1alpha1"})
    updateApplication(name: String!, description: String, labels: Labels): ApplicationMutationOutput! @HasAccess(attributes: {resource: "applications", verb: "update", apiGroup: "applicationconnector.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})
    deleteApplication(name: String!): DeleteApplicationOutput! @HasAccess(attributes: {resource: "applications", verb: "delete", apiGroup: "applicationconnector.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})

    enableApplication(application: String!, namespace: String!): ApplicationMapping @HasAccess(attributes: {resource: "applicationmappings", verb: "create", apiGroup: "applicationconnector.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace"})
    disableApplication(application: String!, namespace: String!): ApplicationMapping @HasAccess(attributes: {resource: "applicationmappings", verb: "delete", apiGroup: "applicationconnector.kyma-project.io", apiVersion: "v1alpha1", nameArg: "application", namespaceArg: "namespace"})

    updatePod(name: String!, namespace: String!, pod: JSON!): Pod @HasAccess(attributes: {resource: "pods", verb: "update", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace", nameArg: "name"})
    deletePod(name: String!, namespace: String!): Pod @HasAccess(attributes: {resource: "pods", verb: "delete", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace", nameArg: "name"})

    updateSecret(name: String!, namespace: String!, secret: JSON!): Secret @HasAccess(attributes: {resource: "secrets", verb: "update", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})
    deleteSecret(name: String!, namespace: String!): Secret @HasAccess(attributes: {resource: "secrets", verb: "delete", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})

    updateReplicaSet(name: String!, namespace: String!, replicaSet: JSON!): ReplicaSet @HasAccess(attributes: {resource: "replicasets", verb: "update", apiGroup: "apps", apiVersion: "v1", namespaceArg: "namespace", nameArg: "name"})
    deleteReplicaSet(name: String!, namespace: String!): ReplicaSet @HasAccess(attributes: {resource: "replicasets", verb: "delete", apiGroup: "apps", apiVersion: "v1", namespaceArg: "namespace", nameArg: "name"})

    updateConfigMap(name: String!, namespace: String!, configMap: JSON!): ConfigMap @HasAccess(attributes: {resource: "configmaps", verb: "update", apiGroup: "", apiVersion: "v1", nameArg: "name", namespaceArg: "namespace"})
    deleteConfigMap(name: String!, namespace: String!): ConfigMap @HasAccess(attributes: {resource: "configmaps", verb: "delete", apiGroup: "", apiVersion: "v1", nameArg: "name", namespaceArg: "namespace"})

    createIDPPreset(name: String!, issuer: String!, jwksUri: String!): IDPPreset @HasAccess(attributes: {resource: "idppresets", verb: "create", apiGroup: "authentication.kyma-project.io", apiVersion: "v1alpha1"})
    deleteIDPPreset(name: String!): IDPPreset @HasAccess(attributes: {resource: "idppresets", verb: "delete", apiGroup: "authentication.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})

    updateService(name: String!, namespace: String!, service: JSON!): Service @HasAccess(attributes: {resource: "services", verb: "update", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace", nameArg: "name"})
    deleteService(name: String!, namespace: String!): Service @HasAccess(attributes: {resource: "services", verb: "delete", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace", nameArg: "name"})
}

# Subscriptions

type Subscription {
    clusterAssetEvent: ClusterAssetEvent! @HasAccess(attributes: {resource: "clusterassets", verb: "watch", apiGroup: "assetstore.kyma-project.io", apiVersion: "v1alpha2"})
    assetEvent(namespace: String!): AssetEvent! @HasAccess(attributes: {resource: "assets", verb: "watch", apiGroup: "assetstore.kyma-project.io", apiVersion: "v1alpha2", namespaceArg: "namespace"})
    clusterDocsTopicEvent: ClusterDocsTopicEvent! @HasAccess(attributes: {resource: "clusterdocstopics", verb: "watch", apiGroup: "cms.kyma-project.io", apiVersion: "v1alpha1"})
    docsTopicEvent(namespace: String!): DocsTopicEvent! @HasAccess(attributes: {resource: "docstopics", verb: "watch", apiGroup: "cms.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace"})
    serviceInstanceEvent(namespace: String!): ServiceInstanceEvent! @HasAccess(attributes: {resource: "serviceinstances", verb: "watch", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace"})
    serviceBindingEvent(namespace: String!): ServiceBindingEvent! @HasAccess(attributes: {resource: "servicebindings", verb: "watch", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace"})
    serviceBindingUsageEvent(namespace: String!): ServiceBindingUsageEvent! @HasAccess(attributes: {resource: "servicebindingusages", verb: "watch", apiGroup: "servicecatalog.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace"})
    serviceBrokerEvent(namespace: String!): ServiceBrokerEvent! @HasAccess(attributes: {resource: "servicebrokers", verb: "watch", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace"})
    clusterServiceBrokerEvent: ClusterServiceBrokerEvent! @HasAccess(attributes: {resource: "clusterservicebrokers", verb: "watch", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1"})
    applicationEvent: ApplicationEvent! @HasAccess(attributes: {resource: "applications", verb: "watch", apiGroup: "applicationconnector.kyma-project.io", apiVersion: "v1alpha1"})
    podEvent(namespace: String!): PodEvent! @HasAccess(attributes: {resource: "pods", verb: "watch", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})
    serviceEvent(namespace: String!): ServiceEvent! @HasAccess(attributes: {resource: "services", verb: "watch", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})
    configMapEvent(namespace: String!): ConfigMapEvent! @HasAccess(attributes: {resource: "configmaps", verb: "watch", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})
    addonsConfigurationEvent: AddonsConfigurationEvent! @HasAccess(attributes: {resource: "configmaps", verb: "watch", apiGroup: "", apiVersion: "v1"})
    # secretEvent(namespace: String!): SecretEvent!  @HasAccess(attributes: {resource: "secrets", verb: "watch", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"}) # This subscription has to be disabled until https://github.com/kyma-project/kyma/issues/3412 gets resolved
}

# Schema

schema {
    query: Query
    mutation: Mutation
}
`},
)
