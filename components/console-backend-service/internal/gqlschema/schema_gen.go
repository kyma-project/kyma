// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gqlschema

import (
	"bytes"
	"context"
	"errors"
	"strconv"
	"sync"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/vektah/gqlparser"
	"github.com/vektah/gqlparser/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Application() ApplicationResolver
	Asset() AssetResolver
	AssetGroup() AssetGroupResolver
	ClusterAsset() ClusterAssetResolver
	ClusterAssetGroup() ClusterAssetGroupResolver
	ClusterServiceClass() ClusterServiceClassResolver
	ClusterServicePlan() ClusterServicePlanResolver
	Deployment() DeploymentResolver
	EventActivation() EventActivationResolver
	Mutation() MutationResolver
	Namespace() NamespaceResolver
	Query() QueryResolver
	ServiceBinding() ServiceBindingResolver
	ServiceBindingUsage() ServiceBindingUsageResolver
	ServiceClass() ServiceClassResolver
	ServiceInstance() ServiceInstanceResolver
	ServicePlan() ServicePlanResolver
	Subscription() SubscriptionResolver
}

type DirectiveRoot struct {
	HasAccess func(ctx context.Context, obj interface{}, next graphql.Resolver, attributes ResourceAttributes) (res interface{}, err error)
}

type ComplexityRoot struct {
	Apirule struct {
		Name    func(childComplexity int) int
		Service func(childComplexity int) int
		Gateway func(childComplexity int) int
		Rules   func(childComplexity int) int
		Status  func(childComplexity int) int
	}

	ApiruleConfig struct {
		Name   func(childComplexity int) int
		Config func(childComplexity int) int
	}

	ApiruleService struct {
		Host func(childComplexity int) int
		Name func(childComplexity int) int
		Port func(childComplexity int) int
	}

	ApiruleStatus struct {
		Code func(childComplexity int) int
		Desc func(childComplexity int) int
	}

	ApiruleStatuses struct {
		ApiRuleStatus        func(childComplexity int) int
		AccessRuleStatus     func(childComplexity int) int
		VirtualServiceStatus func(childComplexity int) int
	}

	AddonsConfiguration struct {
		Name         func(childComplexity int) int
		Urls         func(childComplexity int) int
		Repositories func(childComplexity int) int
		Labels       func(childComplexity int) int
		Status       func(childComplexity int) int
	}

	AddonsConfigurationEvent struct {
		Type                func(childComplexity int) int
		AddonsConfiguration func(childComplexity int) int
	}

	AddonsConfigurationRepository struct {
		Url       func(childComplexity int) int
		SecretRef func(childComplexity int) int
	}

	AddonsConfigurationStatus struct {
		Phase        func(childComplexity int) int
		Repositories func(childComplexity int) int
	}

	AddonsConfigurationStatusAddons struct {
		Name    func(childComplexity int) int
		Version func(childComplexity int) int
		Status  func(childComplexity int) int
		Reason  func(childComplexity int) int
		Message func(childComplexity int) int
	}

	AddonsConfigurationStatusRepository struct {
		Url     func(childComplexity int) int
		Status  func(childComplexity int) int
		Addons  func(childComplexity int) int
		Reason  func(childComplexity int) int
		Message func(childComplexity int) int
	}

	ApiRuleEvent struct {
		Type    func(childComplexity int) int
		ApiRule func(childComplexity int) int
	}

	Application struct {
		Name                   func(childComplexity int) int
		Description            func(childComplexity int) int
		Labels                 func(childComplexity int) int
		Services               func(childComplexity int) int
		EnabledInNamespaces    func(childComplexity int) int
		EnabledMappingServices func(childComplexity int) int
		Status                 func(childComplexity int) int
		CompassMetadata        func(childComplexity int) int
	}

	ApplicationEntry struct {
		Type        func(childComplexity int) int
		GatewayUrl  func(childComplexity int) int
		AccessLabel func(childComplexity int) int
	}

	ApplicationEvent struct {
		Type        func(childComplexity int) int
		Application func(childComplexity int) int
	}

	ApplicationMapping struct {
		Namespace   func(childComplexity int) int
		Application func(childComplexity int) int
		AllServices func(childComplexity int) int
		Services    func(childComplexity int) int
	}

	ApplicationMutationOutput struct {
		Name        func(childComplexity int) int
		Description func(childComplexity int) int
		Labels      func(childComplexity int) int
	}

	ApplicationService struct {
		Id                  func(childComplexity int) int
		DisplayName         func(childComplexity int) int
		LongDescription     func(childComplexity int) int
		ProviderDisplayName func(childComplexity int) int
		Tags                func(childComplexity int) int
		Entries             func(childComplexity int) int
	}

	Asset struct {
		Name        func(childComplexity int) int
		Namespace   func(childComplexity int) int
		Parameters  func(childComplexity int) int
		Type        func(childComplexity int) int
		Files       func(childComplexity int, filterExtensions []string) int
		Status      func(childComplexity int) int
		DisplayName func(childComplexity int) int
	}

	AssetEvent struct {
		Type  func(childComplexity int) int
		Asset func(childComplexity int) int
	}

	AssetGroup struct {
		Name        func(childComplexity int) int
		Namespace   func(childComplexity int) int
		GroupName   func(childComplexity int) int
		Assets      func(childComplexity int, types []string) int
		DisplayName func(childComplexity int) int
		Description func(childComplexity int) int
		Status      func(childComplexity int) int
	}

	AssetGroupEvent struct {
		Type       func(childComplexity int) int
		AssetGroup func(childComplexity int) int
	}

	AssetGroupStatus struct {
		Phase   func(childComplexity int) int
		Reason  func(childComplexity int) int
		Message func(childComplexity int) int
	}

	AssetStatus struct {
		Phase   func(childComplexity int) int
		Reason  func(childComplexity int) int
		Message func(childComplexity int) int
	}

	BackendModule struct {
		Name func(childComplexity int) int
	}

	BindableResourcesOutputItem struct {
		Kind        func(childComplexity int) int
		DisplayName func(childComplexity int) int
		Resources   func(childComplexity int) int
	}

	ClusterAddonsConfigurationEvent struct {
		Type                func(childComplexity int) int
		AddonsConfiguration func(childComplexity int) int
	}

	ClusterAsset struct {
		Name        func(childComplexity int) int
		Parameters  func(childComplexity int) int
		Type        func(childComplexity int) int
		Files       func(childComplexity int, filterExtensions []string) int
		Status      func(childComplexity int) int
		DisplayName func(childComplexity int) int
	}

	ClusterAssetEvent struct {
		Type         func(childComplexity int) int
		ClusterAsset func(childComplexity int) int
	}

	ClusterAssetGroup struct {
		Name        func(childComplexity int) int
		GroupName   func(childComplexity int) int
		Assets      func(childComplexity int, types []string) int
		DisplayName func(childComplexity int) int
		Description func(childComplexity int) int
		Status      func(childComplexity int) int
	}

	ClusterAssetGroupEvent struct {
		Type              func(childComplexity int) int
		ClusterAssetGroup func(childComplexity int) int
	}

	ClusterMicroFrontend struct {
		Name            func(childComplexity int) int
		Version         func(childComplexity int) int
		Category        func(childComplexity int) int
		ViewBaseUrl     func(childComplexity int) int
		Placement       func(childComplexity int) int
		PreloadUrl      func(childComplexity int) int
		NavigationNodes func(childComplexity int) int
	}

	ClusterServiceBroker struct {
		Name              func(childComplexity int) int
		Status            func(childComplexity int) int
		CreationTimestamp func(childComplexity int) int
		Url               func(childComplexity int) int
		Labels            func(childComplexity int) int
	}

	ClusterServiceBrokerEvent struct {
		Type                 func(childComplexity int) int
		ClusterServiceBroker func(childComplexity int) int
	}

	ClusterServiceClass struct {
		Name                func(childComplexity int) int
		ExternalName        func(childComplexity int) int
		DisplayName         func(childComplexity int) int
		CreationTimestamp   func(childComplexity int) int
		Description         func(childComplexity int) int
		LongDescription     func(childComplexity int) int
		ImageUrl            func(childComplexity int) int
		DocumentationUrl    func(childComplexity int) int
		SupportUrl          func(childComplexity int) int
		ProviderDisplayName func(childComplexity int) int
		Tags                func(childComplexity int) int
		Labels              func(childComplexity int) int
		Plans               func(childComplexity int) int
		Activated           func(childComplexity int, namespace *string) int
		Instances           func(childComplexity int, namespace *string) int
		ClusterAssetGroup   func(childComplexity int) int
	}

	ClusterServicePlan struct {
		Name                           func(childComplexity int) int
		DisplayName                    func(childComplexity int) int
		ExternalName                   func(childComplexity int) int
		Description                    func(childComplexity int) int
		RelatedClusterServiceClassName func(childComplexity int) int
		InstanceCreateParameterSchema  func(childComplexity int) int
		BindingCreateParameterSchema   func(childComplexity int) int
		ClusterAssetGroup              func(childComplexity int) int
	}

	ConfigMap struct {
		Name              func(childComplexity int) int
		Namespace         func(childComplexity int) int
		CreationTimestamp func(childComplexity int) int
		Labels            func(childComplexity int) int
		Json              func(childComplexity int) int
	}

	ConfigMapEvent struct {
		Type      func(childComplexity int) int
		ConfigMap func(childComplexity int) int
	}

	ConnectorService struct {
		Url func(childComplexity int) int
	}

	Container struct {
		Name  func(childComplexity int) int
		Image func(childComplexity int) int
	}

	ContainerState struct {
		State   func(childComplexity int) int
		Reason  func(childComplexity int) int
		Message func(childComplexity int) int
	}

	CreateServiceBindingOutput struct {
		Name                func(childComplexity int) int
		ServiceInstanceName func(childComplexity int) int
		Namespace           func(childComplexity int) int
	}

	DeleteApplicationOutput struct {
		Name func(childComplexity int) int
	}

	DeleteServiceBindingOutput struct {
		Name      func(childComplexity int) int
		Namespace func(childComplexity int) int
	}

	DeleteServiceBindingUsageOutput struct {
		Name      func(childComplexity int) int
		Namespace func(childComplexity int) int
	}

	Deployment struct {
		Name                      func(childComplexity int) int
		Namespace                 func(childComplexity int) int
		CreationTimestamp         func(childComplexity int) int
		Status                    func(childComplexity int) int
		Labels                    func(childComplexity int) int
		Containers                func(childComplexity int) int
		BoundServiceInstanceNames func(childComplexity int) int
	}

	DeploymentCondition struct {
		Status                  func(childComplexity int) int
		Type                    func(childComplexity int) int
		LastTransitionTimestamp func(childComplexity int) int
		LastUpdateTimestamp     func(childComplexity int) int
		Message                 func(childComplexity int) int
		Reason                  func(childComplexity int) int
	}

	DeploymentStatus struct {
		Replicas          func(childComplexity int) int
		UpdatedReplicas   func(childComplexity int) int
		ReadyReplicas     func(childComplexity int) int
		AvailableReplicas func(childComplexity int) int
		Conditions        func(childComplexity int) int
	}

	EnabledApplicationService struct {
		Id          func(childComplexity int) int
		DisplayName func(childComplexity int) int
		Exist       func(childComplexity int) int
	}

	EnvPrefix struct {
		Name func(childComplexity int) int
	}

	EventActivation struct {
		Name        func(childComplexity int) int
		DisplayName func(childComplexity int) int
		SourceId    func(childComplexity int) int
		Events      func(childComplexity int) int
	}

	EventActivationEvent struct {
		EventType   func(childComplexity int) int
		Version     func(childComplexity int) int
		Description func(childComplexity int) int
		Schema      func(childComplexity int) int
	}

	ExceededQuota struct {
		QuotaName         func(childComplexity int) int
		ResourceName      func(childComplexity int) int
		AffectedResources func(childComplexity int) int
	}

	File struct {
		Url      func(childComplexity int) int
		Metadata func(childComplexity int) int
	}

	Function struct {
		Name         func(childComplexity int) int
		Namespace    func(childComplexity int) int
		Uid          func(childComplexity int) int
		Labels       func(childComplexity int) int
		Source       func(childComplexity int) int
		Dependencies func(childComplexity int) int
		Env          func(childComplexity int) int
		Replicas     func(childComplexity int) int
		Resources    func(childComplexity int) int
		Status       func(childComplexity int) int
	}

	FunctionEnv struct {
		Name      func(childComplexity int) int
		Value     func(childComplexity int) int
		ValueFrom func(childComplexity int) int
	}

	FunctionEnvValueFrom struct {
		Type     func(childComplexity int) int
		Name     func(childComplexity int) int
		Key      func(childComplexity int) int
		Optional func(childComplexity int) int
	}

	FunctionEvent struct {
		Type     func(childComplexity int) int
		Function func(childComplexity int) int
	}

	FunctionMetadata struct {
		Name      func(childComplexity int) int
		Namespace func(childComplexity int) int
	}

	FunctionReplicas struct {
		Min func(childComplexity int) int
		Max func(childComplexity int) int
	}

	FunctionResources struct {
		Limits   func(childComplexity int) int
		Requests func(childComplexity int) int
	}

	FunctionStatus struct {
		Phase   func(childComplexity int) int
		Reason  func(childComplexity int) int
		Message func(childComplexity int) int
	}

	Idppreset struct {
		Name    func(childComplexity int) int
		Issuer  func(childComplexity int) int
		JwksUri func(childComplexity int) int
	}

	LimitRange struct {
		Name   func(childComplexity int) int
		Limits func(childComplexity int) int
	}

	LimitRangeItem struct {
		LimitType      func(childComplexity int) int
		Max            func(childComplexity int) int
		Default        func(childComplexity int) int
		DefaultRequest func(childComplexity int) int
	}

	LoadBalancerIngress struct {
		Ip       func(childComplexity int) int
		HostName func(childComplexity int) int
	}

	LoadBalancerStatus struct {
		Ingress func(childComplexity int) int
	}

	LocalObjectReference struct {
		Kind func(childComplexity int) int
		Name func(childComplexity int) int
	}

	MicroFrontend struct {
		Name            func(childComplexity int) int
		Version         func(childComplexity int) int
		Category        func(childComplexity int) int
		ViewBaseUrl     func(childComplexity int) int
		NavigationNodes func(childComplexity int) int
	}

	Mutation struct {
		CreateResource                             func(childComplexity int, namespace string, resource JSON) int
		CreateServiceInstance                      func(childComplexity int, namespace string, params ServiceInstanceCreateInput) int
		DeleteServiceInstance                      func(childComplexity int, name string, namespace string) int
		CreateServiceBinding                       func(childComplexity int, serviceBindingName *string, serviceInstanceName string, namespace string, parameters *JSON) int
		DeleteServiceBinding                       func(childComplexity int, serviceBindingName string, namespace string) int
		CreateServiceBindingUsage                  func(childComplexity int, namespace string, createServiceBindingUsageInput *CreateServiceBindingUsageInput) int
		DeleteServiceBindingUsage                  func(childComplexity int, serviceBindingUsageName string, namespace string) int
		DeleteServiceBindingUsages                 func(childComplexity int, serviceBindingUsageNames []string, namespace string) int
		CreateClusterAddonsConfiguration           func(childComplexity int, name string, repositories []AddonsConfigurationRepositoryInput, urls []string, labels *Labels) int
		UpdateClusterAddonsConfiguration           func(childComplexity int, name string, repositories []AddonsConfigurationRepositoryInput, urls []string, labels *Labels) int
		DeleteClusterAddonsConfiguration           func(childComplexity int, name string) int
		AddClusterAddonsConfigurationUrls          func(childComplexity int, name string, urls []string) int
		RemoveClusterAddonsConfigurationUrls       func(childComplexity int, name string, urls []string) int
		AddClusterAddonsConfigurationRepository    func(childComplexity int, name string, repositories []AddonsConfigurationRepositoryInput) int
		RemoveClusterAddonsConfigurationRepository func(childComplexity int, name string, urls []string) int
		ResyncClusterAddonsConfiguration           func(childComplexity int, name string) int
		CreateAddonsConfiguration                  func(childComplexity int, name string, namespace string, repositories []AddonsConfigurationRepositoryInput, urls []string, labels *Labels) int
		UpdateAddonsConfiguration                  func(childComplexity int, name string, namespace string, repositories []AddonsConfigurationRepositoryInput, urls []string, labels *Labels) int
		DeleteAddonsConfiguration                  func(childComplexity int, name string, namespace string) int
		AddAddonsConfigurationUrls                 func(childComplexity int, name string, namespace string, urls []string) int
		RemoveAddonsConfigurationUrls              func(childComplexity int, name string, namespace string, urls []string) int
		AddAddonsConfigurationRepository           func(childComplexity int, name string, namespace string, repositories []AddonsConfigurationRepositoryInput) int
		RemoveAddonsConfigurationRepository        func(childComplexity int, name string, namespace string, urls []string) int
		ResyncAddonsConfiguration                  func(childComplexity int, name string, namespace string) int
		CreateApplication                          func(childComplexity int, name string, description *string, labels *Labels) int
		UpdateApplication                          func(childComplexity int, name string, description *string, labels *Labels) int
		DeleteApplication                          func(childComplexity int, name string) int
		EnableApplication                          func(childComplexity int, application string, namespace string, allServices *bool, services []*ApplicationMappingService) int
		OverloadApplication                        func(childComplexity int, application string, namespace string, allServices *bool, services []*ApplicationMappingService) int
		DisableApplication                         func(childComplexity int, application string, namespace string) int
		UpdatePod                                  func(childComplexity int, name string, namespace string, pod JSON) int
		DeletePod                                  func(childComplexity int, name string, namespace string) int
		UpdateSecret                               func(childComplexity int, name string, namespace string, secret JSON) int
		DeleteSecret                               func(childComplexity int, name string, namespace string) int
		UpdateReplicaSet                           func(childComplexity int, name string, namespace string, replicaSet JSON) int
		DeleteReplicaSet                           func(childComplexity int, name string, namespace string) int
		CreateResourceQuota                        func(childComplexity int, namespace string, name string, resourceQuota ResourceQuotaInput) int
		UpdateConfigMap                            func(childComplexity int, name string, namespace string, configMap JSON) int
		DeleteConfigMap                            func(childComplexity int, name string, namespace string) int
		CreateIdppreset                            func(childComplexity int, name string, issuer string, jwksUri string) int
		DeleteIdppreset                            func(childComplexity int, name string) int
		UpdateService                              func(childComplexity int, name string, namespace string, service JSON) int
		DeleteService                              func(childComplexity int, name string, namespace string) int
		CreateNamespace                            func(childComplexity int, name string, labels *Labels) int
		UpdateNamespace                            func(childComplexity int, name string, labels Labels) int
		DeleteNamespace                            func(childComplexity int, name string) int
		CreateApirule                              func(childComplexity int, name string, namespace string, params APIRuleInput) int
		UpdateApirule                              func(childComplexity int, name string, namespace string, params APIRuleInput) int
		DeleteApirule                              func(childComplexity int, name string, namespace string) int
		CreateLimitRange                           func(childComplexity int, namespace string, name string, limitRange LimitRangeInput) int
		CreateFunction                             func(childComplexity int, name string, namespace string, params FunctionMutationInput) int
		UpdateFunction                             func(childComplexity int, name string, namespace string, params FunctionMutationInput) int
		DeleteFunction                             func(childComplexity int, function FunctionMetadataInput) int
		DeleteManyFunctions                        func(childComplexity int, functions []FunctionMetadataInput) int
		CreateTrigger                              func(childComplexity int, trigger TriggerCreateInput, ownerRef []OwnerReference) int
		CreateManyTriggers                         func(childComplexity int, triggers []TriggerCreateInput, ownerRef []OwnerReference) int
		DeleteTrigger                              func(childComplexity int, trigger TriggerMetadataInput) int
		DeleteManyTriggers                         func(childComplexity int, triggers []TriggerMetadataInput) int
	}

	Namespace struct {
		Name              func(childComplexity int) int
		Labels            func(childComplexity int) int
		Status            func(childComplexity int) int
		IsSystemNamespace func(childComplexity int) int
		Pods              func(childComplexity int) int
		Applications      func(childComplexity int) int
	}

	NamespaceEvent struct {
		Type      func(childComplexity int) int
		Namespace func(childComplexity int) int
	}

	NamespaceMutationOutput struct {
		Name   func(childComplexity int) int
		Labels func(childComplexity int) int
	}

	NavigationNode struct {
		Label               func(childComplexity int) int
		NavigationPath      func(childComplexity int) int
		ViewUrl             func(childComplexity int) int
		ShowInNavigation    func(childComplexity int) int
		Order               func(childComplexity int) int
		Settings            func(childComplexity int) int
		ExternalLink        func(childComplexity int) int
		RequiredPermissions func(childComplexity int) int
	}

	Pod struct {
		Name              func(childComplexity int) int
		NodeName          func(childComplexity int) int
		Namespace         func(childComplexity int) int
		RestartCount      func(childComplexity int) int
		CreationTimestamp func(childComplexity int) int
		Labels            func(childComplexity int) int
		Status            func(childComplexity int) int
		ContainerStates   func(childComplexity int) int
		Json              func(childComplexity int) int
	}

	PodEvent struct {
		Type func(childComplexity int) int
		Pod  func(childComplexity int) int
	}

	Query struct {
		ClusterAssetGroups          func(childComplexity int, viewContext *string, groupName *string) int
		ServiceInstance             func(childComplexity int, name string, namespace string) int
		ServiceInstances            func(childComplexity int, namespace string, first *int, offset *int, status *InstanceStatusType) int
		ClusterServiceClasses       func(childComplexity int, first *int, offset *int) int
		ClusterServiceClass         func(childComplexity int, name string) int
		ServiceClasses              func(childComplexity int, namespace string, first *int, offset *int) int
		ServiceClass                func(childComplexity int, namespace string, name string) int
		ClusterServiceBrokers       func(childComplexity int, first *int, offset *int) int
		ClusterServiceBroker        func(childComplexity int, name string) int
		ServiceBrokers              func(childComplexity int, namespace string, first *int, offset *int) int
		ServiceBroker               func(childComplexity int, name string, namespace string) int
		ServiceBindingUsage         func(childComplexity int, name string, namespace string) int
		ServiceBindingUsages        func(childComplexity int, namespace string, resourceKind *string, resourceName *string) int
		ServiceBinding              func(childComplexity int, name string, namespace string) int
		UsageKinds                  func(childComplexity int, first *int, offset *int) int
		ClusterAddonsConfigurations func(childComplexity int, first *int, offset *int) int
		AddonsConfigurations        func(childComplexity int, namespace string, first *int, offset *int) int
		BindableResources           func(childComplexity int, namespace string) int
		Apirules                    func(childComplexity int, namespace string, serviceName *string, hostname *string) int
		Apirule                     func(childComplexity int, name string, namespace string) int
		Application                 func(childComplexity int, name string) int
		Applications                func(childComplexity int, namespace *string, first *int, offset *int) int
		ConnectorService            func(childComplexity int, application string) int
		Namespaces                  func(childComplexity int, withSystemNamespaces *bool, withInactiveStatus *bool) int
		Namespace                   func(childComplexity int, name string) int
		Deployments                 func(childComplexity int, namespace string, excludeFunctions *bool) int
		VersionInfo                 func(childComplexity int) int
		Pod                         func(childComplexity int, name string, namespace string) int
		Pods                        func(childComplexity int, namespace string, first *int, offset *int) int
		Service                     func(childComplexity int, name string, namespace string) int
		Services                    func(childComplexity int, namespace string, excludedLabels []string, first *int, offset *int) int
		ConfigMap                   func(childComplexity int, name string, namespace string) int
		ConfigMaps                  func(childComplexity int, namespace string, first *int, offset *int) int
		ReplicaSet                  func(childComplexity int, name string, namespace string) int
		ReplicaSets                 func(childComplexity int, namespace string, first *int, offset *int) int
		ResourceQuotas              func(childComplexity int, namespace string) int
		ResourceQuotasStatus        func(childComplexity int, namespace string) int
		EventActivations            func(childComplexity int, namespace string) int
		LimitRanges                 func(childComplexity int, namespace string) int
		BackendModules              func(childComplexity int) int
		Secret                      func(childComplexity int, name string, namespace string) int
		Secrets                     func(childComplexity int, namespace string, first *int, offset *int) int
		Idppreset                   func(childComplexity int, name string) int
		Idppresets                  func(childComplexity int, first *int, offset *int) int
		MicroFrontends              func(childComplexity int, namespace string) int
		ClusterMicroFrontends       func(childComplexity int) int
		SelfSubjectRules            func(childComplexity int, namespace *string) int
		Function                    func(childComplexity int, name string, namespace string) int
		Functions                   func(childComplexity int, namespace string) int
		Triggers                    func(childComplexity int, namespace string, subscriber *SubscriberInput) int
	}

	ReplicaSet struct {
		Name              func(childComplexity int) int
		Pods              func(childComplexity int) int
		Namespace         func(childComplexity int) int
		Images            func(childComplexity int) int
		CreationTimestamp func(childComplexity int) int
		Labels            func(childComplexity int) int
		Json              func(childComplexity int) int
	}

	RequiredPermission struct {
		Verbs    func(childComplexity int) int
		ApiGroup func(childComplexity int) int
		Resource func(childComplexity int) int
	}

	ResourceQuota struct {
		Name     func(childComplexity int) int
		Pods     func(childComplexity int) int
		Limits   func(childComplexity int) int
		Requests func(childComplexity int) int
	}

	ResourceQuotasStatus struct {
		Exceeded       func(childComplexity int) int
		ExceededQuotas func(childComplexity int) int
	}

	ResourceRef struct {
		Name      func(childComplexity int) int
		Namespace func(childComplexity int) int
	}

	ResourceRule struct {
		Verbs     func(childComplexity int) int
		ApiGroups func(childComplexity int) int
		Resources func(childComplexity int) int
	}

	ResourceType struct {
		Memory func(childComplexity int) int
		Cpu    func(childComplexity int) int
	}

	ResourceValues struct {
		Memory func(childComplexity int) int
		Cpu    func(childComplexity int) int
	}

	Rule struct {
		Path             func(childComplexity int) int
		Methods          func(childComplexity int) int
		AccessStrategies func(childComplexity int) int
		Mutators         func(childComplexity int) int
	}

	Secret struct {
		Name         func(childComplexity int) int
		Namespace    func(childComplexity int) int
		Data         func(childComplexity int) int
		Type         func(childComplexity int) int
		CreationTime func(childComplexity int) int
		Labels       func(childComplexity int) int
		Annotations  func(childComplexity int) int
		Json         func(childComplexity int) int
	}

	SecretEvent struct {
		Type   func(childComplexity int) int
		Secret func(childComplexity int) int
	}

	Service struct {
		Name              func(childComplexity int) int
		ClusterIp         func(childComplexity int) int
		CreationTimestamp func(childComplexity int) int
		Labels            func(childComplexity int) int
		Ports             func(childComplexity int) int
		Status            func(childComplexity int) int
		Json              func(childComplexity int) int
	}

	ServiceBinding struct {
		Name                func(childComplexity int) int
		ServiceInstanceName func(childComplexity int) int
		Namespace           func(childComplexity int) int
		Secret              func(childComplexity int) int
		Status              func(childComplexity int) int
		Parameters          func(childComplexity int) int
	}

	ServiceBindingEvent struct {
		Type           func(childComplexity int) int
		ServiceBinding func(childComplexity int) int
	}

	ServiceBindingStatus struct {
		Type    func(childComplexity int) int
		Reason  func(childComplexity int) int
		Message func(childComplexity int) int
	}

	ServiceBindingUsage struct {
		Name           func(childComplexity int) int
		Namespace      func(childComplexity int) int
		ServiceBinding func(childComplexity int) int
		UsedBy         func(childComplexity int) int
		Parameters     func(childComplexity int) int
		Status         func(childComplexity int) int
	}

	ServiceBindingUsageEvent struct {
		Type                func(childComplexity int) int
		ServiceBindingUsage func(childComplexity int) int
	}

	ServiceBindingUsageParameters struct {
		EnvPrefix func(childComplexity int) int
	}

	ServiceBindingUsageStatus struct {
		Type    func(childComplexity int) int
		Reason  func(childComplexity int) int
		Message func(childComplexity int) int
	}

	ServiceBindings struct {
		Items func(childComplexity int) int
		Stats func(childComplexity int) int
	}

	ServiceBindingsStats struct {
		Ready   func(childComplexity int) int
		Failed  func(childComplexity int) int
		Pending func(childComplexity int) int
		Unknown func(childComplexity int) int
	}

	ServiceBroker struct {
		Name              func(childComplexity int) int
		Namespace         func(childComplexity int) int
		Status            func(childComplexity int) int
		CreationTimestamp func(childComplexity int) int
		Url               func(childComplexity int) int
		Labels            func(childComplexity int) int
	}

	ServiceBrokerEvent struct {
		Type          func(childComplexity int) int
		ServiceBroker func(childComplexity int) int
	}

	ServiceBrokerStatus struct {
		Ready   func(childComplexity int) int
		Reason  func(childComplexity int) int
		Message func(childComplexity int) int
	}

	ServiceClass struct {
		Name                func(childComplexity int) int
		Namespace           func(childComplexity int) int
		ExternalName        func(childComplexity int) int
		DisplayName         func(childComplexity int) int
		CreationTimestamp   func(childComplexity int) int
		Description         func(childComplexity int) int
		LongDescription     func(childComplexity int) int
		ImageUrl            func(childComplexity int) int
		DocumentationUrl    func(childComplexity int) int
		SupportUrl          func(childComplexity int) int
		ProviderDisplayName func(childComplexity int) int
		Tags                func(childComplexity int) int
		Labels              func(childComplexity int) int
		Plans               func(childComplexity int) int
		Activated           func(childComplexity int) int
		Instances           func(childComplexity int) int
		ClusterAssetGroup   func(childComplexity int) int
		AssetGroup          func(childComplexity int) int
	}

	ServiceEvent struct {
		Type    func(childComplexity int) int
		Service func(childComplexity int) int
	}

	ServiceInstance struct {
		Name                 func(childComplexity int) int
		Namespace            func(childComplexity int) int
		PlanSpec             func(childComplexity int) int
		CreationTimestamp    func(childComplexity int) int
		Labels               func(childComplexity int) int
		Status               func(childComplexity int) int
		ClassReference       func(childComplexity int) int
		PlanReference        func(childComplexity int) int
		ServiceClass         func(childComplexity int) int
		ClusterServiceClass  func(childComplexity int) int
		ServicePlan          func(childComplexity int) int
		ClusterServicePlan   func(childComplexity int) int
		Bindable             func(childComplexity int) int
		ServiceBindings      func(childComplexity int) int
		ServiceBindingUsages func(childComplexity int) int
	}

	ServiceInstanceEvent struct {
		Type            func(childComplexity int) int
		ServiceInstance func(childComplexity int) int
	}

	ServiceInstanceResourceRef struct {
		Name        func(childComplexity int) int
		DisplayName func(childComplexity int) int
		ClusterWide func(childComplexity int) int
	}

	ServiceInstanceStatus struct {
		Type    func(childComplexity int) int
		Reason  func(childComplexity int) int
		Message func(childComplexity int) int
	}

	ServicePlan struct {
		Name                          func(childComplexity int) int
		Namespace                     func(childComplexity int) int
		DisplayName                   func(childComplexity int) int
		ExternalName                  func(childComplexity int) int
		Description                   func(childComplexity int) int
		RelatedServiceClassName       func(childComplexity int) int
		InstanceCreateParameterSchema func(childComplexity int) int
		BindingCreateParameterSchema  func(childComplexity int) int
		ClusterAssetGroup             func(childComplexity int) int
		AssetGroup                    func(childComplexity int) int
	}

	ServicePort struct {
		Name            func(childComplexity int) int
		ServiceProtocol func(childComplexity int) int
		Port            func(childComplexity int) int
		NodePort        func(childComplexity int) int
		TargetPort      func(childComplexity int) int
	}

	ServiceStatus struct {
		LoadBalancer func(childComplexity int) int
	}

	Subscriber struct {
		Uri func(childComplexity int) int
		Ref func(childComplexity int) int
	}

	SubscriberRef struct {
		ApiVersion func(childComplexity int) int
		Kind       func(childComplexity int) int
		Name       func(childComplexity int) int
		Namespace  func(childComplexity int) int
	}

	Subscription struct {
		ClusterAssetEvent               func(childComplexity int) int
		AssetEvent                      func(childComplexity int, namespace string) int
		ClusterAssetGroupEvent          func(childComplexity int) int
		AssetGroupEvent                 func(childComplexity int, namespace string) int
		ServiceInstanceEvent            func(childComplexity int, namespace string) int
		ServiceBindingEvent             func(childComplexity int, namespace string) int
		ServiceBindingUsageEvent        func(childComplexity int, namespace string, resourceKind *string, resourceName *string) int
		ServiceBrokerEvent              func(childComplexity int, namespace string) int
		ClusterServiceBrokerEvent       func(childComplexity int) int
		ApplicationEvent                func(childComplexity int) int
		PodEvent                        func(childComplexity int, namespace string) int
		ServiceEvent                    func(childComplexity int, namespace string) int
		ConfigMapEvent                  func(childComplexity int, namespace string) int
		ClusterAddonsConfigurationEvent func(childComplexity int) int
		AddonsConfigurationEvent        func(childComplexity int, namespace string) int
		ApiRuleEvent                    func(childComplexity int, namespace string, serviceName *string) int
		NamespaceEvent                  func(childComplexity int, withSystemNamespaces *bool) int
		FunctionEvent                   func(childComplexity int, namespace string, functionName *string) int
		TriggerEvent                    func(childComplexity int, namespace string, subscriber *SubscriberInput) int
	}

	Trigger struct {
		Name             func(childComplexity int) int
		Namespace        func(childComplexity int) int
		Broker           func(childComplexity int) int
		FilterAttributes func(childComplexity int) int
		Subscriber       func(childComplexity int) int
		Status           func(childComplexity int) int
	}

	TriggerEvent struct {
		Type    func(childComplexity int) int
		Trigger func(childComplexity int) int
	}

	TriggerMetadata struct {
		Name      func(childComplexity int) int
		Namespace func(childComplexity int) int
	}

	TriggerStatus struct {
		Reason func(childComplexity int) int
		Status func(childComplexity int) int
	}

	UsageKind struct {
		Name        func(childComplexity int) int
		Group       func(childComplexity int) int
		Kind        func(childComplexity int) int
		Version     func(childComplexity int) int
		DisplayName func(childComplexity int) int
	}

	UsageKindResource struct {
		Name      func(childComplexity int) int
		Namespace func(childComplexity int) int
	}

	VersionInfo struct {
		KymaVersion func(childComplexity int) int
	}

	CompassMetadata struct {
		ApplicationId func(childComplexity int) int
	}

	EnabledMappingService struct {
		Namespace   func(childComplexity int) int
		AllServices func(childComplexity int) int
		Services    func(childComplexity int) int
	}
}

type ApplicationResolver interface {
	EnabledInNamespaces(ctx context.Context, obj *Application) ([]string, error)
	EnabledMappingServices(ctx context.Context, obj *Application) ([]*EnabledMappingService, error)
	Status(ctx context.Context, obj *Application) (ApplicationStatus, error)
}
type AssetResolver interface {
	Files(ctx context.Context, obj *Asset, filterExtensions []string) ([]File, error)
}
type AssetGroupResolver interface {
	Assets(ctx context.Context, obj *AssetGroup, types []string) ([]Asset, error)
}
type ClusterAssetResolver interface {
	Files(ctx context.Context, obj *ClusterAsset, filterExtensions []string) ([]File, error)
}
type ClusterAssetGroupResolver interface {
	Assets(ctx context.Context, obj *ClusterAssetGroup, types []string) ([]ClusterAsset, error)
}
type ClusterServiceClassResolver interface {
	Plans(ctx context.Context, obj *ClusterServiceClass) ([]ClusterServicePlan, error)
	Activated(ctx context.Context, obj *ClusterServiceClass, namespace *string) (bool, error)
	Instances(ctx context.Context, obj *ClusterServiceClass, namespace *string) ([]ServiceInstance, error)
	ClusterAssetGroup(ctx context.Context, obj *ClusterServiceClass) (*ClusterAssetGroup, error)
}
type ClusterServicePlanResolver interface {
	ClusterAssetGroup(ctx context.Context, obj *ClusterServicePlan) (*ClusterAssetGroup, error)
}
type DeploymentResolver interface {
	BoundServiceInstanceNames(ctx context.Context, obj *Deployment) ([]string, error)
}
type EventActivationResolver interface {
	Events(ctx context.Context, obj *EventActivation) ([]EventActivationEvent, error)
}
type MutationResolver interface {
	CreateResource(ctx context.Context, namespace string, resource JSON) (*JSON, error)
	CreateServiceInstance(ctx context.Context, namespace string, params ServiceInstanceCreateInput) (*ServiceInstance, error)
	DeleteServiceInstance(ctx context.Context, name string, namespace string) (*ServiceInstance, error)
	CreateServiceBinding(ctx context.Context, serviceBindingName *string, serviceInstanceName string, namespace string, parameters *JSON) (*CreateServiceBindingOutput, error)
	DeleteServiceBinding(ctx context.Context, serviceBindingName string, namespace string) (*DeleteServiceBindingOutput, error)
	CreateServiceBindingUsage(ctx context.Context, namespace string, createServiceBindingUsageInput *CreateServiceBindingUsageInput) (*ServiceBindingUsage, error)
	DeleteServiceBindingUsage(ctx context.Context, serviceBindingUsageName string, namespace string) (*DeleteServiceBindingUsageOutput, error)
	DeleteServiceBindingUsages(ctx context.Context, serviceBindingUsageNames []string, namespace string) ([]*DeleteServiceBindingUsageOutput, error)
	CreateClusterAddonsConfiguration(ctx context.Context, name string, repositories []AddonsConfigurationRepositoryInput, urls []string, labels *Labels) (*AddonsConfiguration, error)
	UpdateClusterAddonsConfiguration(ctx context.Context, name string, repositories []AddonsConfigurationRepositoryInput, urls []string, labels *Labels) (*AddonsConfiguration, error)
	DeleteClusterAddonsConfiguration(ctx context.Context, name string) (*AddonsConfiguration, error)
	AddClusterAddonsConfigurationURLs(ctx context.Context, name string, urls []string) (*AddonsConfiguration, error)
	RemoveClusterAddonsConfigurationURLs(ctx context.Context, name string, urls []string) (*AddonsConfiguration, error)
	AddClusterAddonsConfigurationRepository(ctx context.Context, name string, repositories []AddonsConfigurationRepositoryInput) (*AddonsConfiguration, error)
	RemoveClusterAddonsConfigurationRepository(ctx context.Context, name string, urls []string) (*AddonsConfiguration, error)
	ResyncClusterAddonsConfiguration(ctx context.Context, name string) (*AddonsConfiguration, error)
	CreateAddonsConfiguration(ctx context.Context, name string, namespace string, repositories []AddonsConfigurationRepositoryInput, urls []string, labels *Labels) (*AddonsConfiguration, error)
	UpdateAddonsConfiguration(ctx context.Context, name string, namespace string, repositories []AddonsConfigurationRepositoryInput, urls []string, labels *Labels) (*AddonsConfiguration, error)
	DeleteAddonsConfiguration(ctx context.Context, name string, namespace string) (*AddonsConfiguration, error)
	AddAddonsConfigurationURLs(ctx context.Context, name string, namespace string, urls []string) (*AddonsConfiguration, error)
	RemoveAddonsConfigurationURLs(ctx context.Context, name string, namespace string, urls []string) (*AddonsConfiguration, error)
	AddAddonsConfigurationRepository(ctx context.Context, name string, namespace string, repositories []AddonsConfigurationRepositoryInput) (*AddonsConfiguration, error)
	RemoveAddonsConfigurationRepository(ctx context.Context, name string, namespace string, urls []string) (*AddonsConfiguration, error)
	ResyncAddonsConfiguration(ctx context.Context, name string, namespace string) (*AddonsConfiguration, error)
	CreateApplication(ctx context.Context, name string, description *string, labels *Labels) (ApplicationMutationOutput, error)
	UpdateApplication(ctx context.Context, name string, description *string, labels *Labels) (ApplicationMutationOutput, error)
	DeleteApplication(ctx context.Context, name string) (DeleteApplicationOutput, error)
	EnableApplication(ctx context.Context, application string, namespace string, allServices *bool, services []*ApplicationMappingService) (*ApplicationMapping, error)
	OverloadApplication(ctx context.Context, application string, namespace string, allServices *bool, services []*ApplicationMappingService) (*ApplicationMapping, error)
	DisableApplication(ctx context.Context, application string, namespace string) (*ApplicationMapping, error)
	UpdatePod(ctx context.Context, name string, namespace string, pod JSON) (*Pod, error)
	DeletePod(ctx context.Context, name string, namespace string) (*Pod, error)
	UpdateSecret(ctx context.Context, name string, namespace string, secret JSON) (*Secret, error)
	DeleteSecret(ctx context.Context, name string, namespace string) (*Secret, error)
	UpdateReplicaSet(ctx context.Context, name string, namespace string, replicaSet JSON) (*ReplicaSet, error)
	DeleteReplicaSet(ctx context.Context, name string, namespace string) (*ReplicaSet, error)
	CreateResourceQuota(ctx context.Context, namespace string, name string, resourceQuota ResourceQuotaInput) (*ResourceQuota, error)
	UpdateConfigMap(ctx context.Context, name string, namespace string, configMap JSON) (*ConfigMap, error)
	DeleteConfigMap(ctx context.Context, name string, namespace string) (*ConfigMap, error)
	CreateIDPPreset(ctx context.Context, name string, issuer string, jwksUri string) (*IDPPreset, error)
	DeleteIDPPreset(ctx context.Context, name string) (*IDPPreset, error)
	UpdateService(ctx context.Context, name string, namespace string, service JSON) (*Service, error)
	DeleteService(ctx context.Context, name string, namespace string) (*Service, error)
	CreateNamespace(ctx context.Context, name string, labels *Labels) (NamespaceMutationOutput, error)
	UpdateNamespace(ctx context.Context, name string, labels Labels) (NamespaceMutationOutput, error)
	DeleteNamespace(ctx context.Context, name string) (*Namespace, error)
	CreateAPIRule(ctx context.Context, name string, namespace string, params APIRuleInput) (*APIRule, error)
	UpdateAPIRule(ctx context.Context, name string, namespace string, params APIRuleInput) (*APIRule, error)
	DeleteAPIRule(ctx context.Context, name string, namespace string) (*APIRule, error)
	CreateLimitRange(ctx context.Context, namespace string, name string, limitRange LimitRangeInput) (*LimitRange, error)
	CreateFunction(ctx context.Context, name string, namespace string, params FunctionMutationInput) (*Function, error)
	UpdateFunction(ctx context.Context, name string, namespace string, params FunctionMutationInput) (*Function, error)
	DeleteFunction(ctx context.Context, function FunctionMetadataInput) (*FunctionMetadata, error)
	DeleteManyFunctions(ctx context.Context, functions []FunctionMetadataInput) ([]FunctionMetadata, error)
	CreateTrigger(ctx context.Context, trigger TriggerCreateInput, ownerRef []OwnerReference) (*Trigger, error)
	CreateManyTriggers(ctx context.Context, triggers []TriggerCreateInput, ownerRef []OwnerReference) ([]Trigger, error)
	DeleteTrigger(ctx context.Context, trigger TriggerMetadataInput) (*TriggerMetadata, error)
	DeleteManyTriggers(ctx context.Context, triggers []TriggerMetadataInput) ([]TriggerMetadata, error)
}
type NamespaceResolver interface {
	Pods(ctx context.Context, obj *Namespace) ([]Pod, error)
	Applications(ctx context.Context, obj *Namespace) ([]string, error)
}
type QueryResolver interface {
	ClusterAssetGroups(ctx context.Context, viewContext *string, groupName *string) ([]ClusterAssetGroup, error)
	ServiceInstance(ctx context.Context, name string, namespace string) (*ServiceInstance, error)
	ServiceInstances(ctx context.Context, namespace string, first *int, offset *int, status *InstanceStatusType) ([]ServiceInstance, error)
	ClusterServiceClasses(ctx context.Context, first *int, offset *int) ([]ClusterServiceClass, error)
	ClusterServiceClass(ctx context.Context, name string) (*ClusterServiceClass, error)
	ServiceClasses(ctx context.Context, namespace string, first *int, offset *int) ([]ServiceClass, error)
	ServiceClass(ctx context.Context, namespace string, name string) (*ServiceClass, error)
	ClusterServiceBrokers(ctx context.Context, first *int, offset *int) ([]ClusterServiceBroker, error)
	ClusterServiceBroker(ctx context.Context, name string) (*ClusterServiceBroker, error)
	ServiceBrokers(ctx context.Context, namespace string, first *int, offset *int) ([]ServiceBroker, error)
	ServiceBroker(ctx context.Context, name string, namespace string) (*ServiceBroker, error)
	ServiceBindingUsage(ctx context.Context, name string, namespace string) (*ServiceBindingUsage, error)
	ServiceBindingUsages(ctx context.Context, namespace string, resourceKind *string, resourceName *string) ([]ServiceBindingUsage, error)
	ServiceBinding(ctx context.Context, name string, namespace string) (*ServiceBinding, error)
	UsageKinds(ctx context.Context, first *int, offset *int) ([]UsageKind, error)
	ClusterAddonsConfigurations(ctx context.Context, first *int, offset *int) ([]AddonsConfiguration, error)
	AddonsConfigurations(ctx context.Context, namespace string, first *int, offset *int) ([]AddonsConfiguration, error)
	BindableResources(ctx context.Context, namespace string) ([]BindableResourcesOutputItem, error)
	APIRules(ctx context.Context, namespace string, serviceName *string, hostname *string) ([]APIRule, error)
	APIRule(ctx context.Context, name string, namespace string) (*APIRule, error)
	Application(ctx context.Context, name string) (*Application, error)
	Applications(ctx context.Context, namespace *string, first *int, offset *int) ([]Application, error)
	ConnectorService(ctx context.Context, application string) (ConnectorService, error)
	Namespaces(ctx context.Context, withSystemNamespaces *bool, withInactiveStatus *bool) ([]Namespace, error)
	Namespace(ctx context.Context, name string) (*Namespace, error)
	Deployments(ctx context.Context, namespace string, excludeFunctions *bool) ([]Deployment, error)
	VersionInfo(ctx context.Context) (VersionInfo, error)
	Pod(ctx context.Context, name string, namespace string) (*Pod, error)
	Pods(ctx context.Context, namespace string, first *int, offset *int) ([]Pod, error)
	Service(ctx context.Context, name string, namespace string) (*Service, error)
	Services(ctx context.Context, namespace string, excludedLabels []string, first *int, offset *int) ([]Service, error)
	ConfigMap(ctx context.Context, name string, namespace string) (*ConfigMap, error)
	ConfigMaps(ctx context.Context, namespace string, first *int, offset *int) ([]ConfigMap, error)
	ReplicaSet(ctx context.Context, name string, namespace string) (*ReplicaSet, error)
	ReplicaSets(ctx context.Context, namespace string, first *int, offset *int) ([]ReplicaSet, error)
	ResourceQuotas(ctx context.Context, namespace string) ([]ResourceQuota, error)
	ResourceQuotasStatus(ctx context.Context, namespace string) (ResourceQuotasStatus, error)
	EventActivations(ctx context.Context, namespace string) ([]EventActivation, error)
	LimitRanges(ctx context.Context, namespace string) ([]LimitRange, error)
	BackendModules(ctx context.Context) ([]BackendModule, error)
	Secret(ctx context.Context, name string, namespace string) (*Secret, error)
	Secrets(ctx context.Context, namespace string, first *int, offset *int) ([]Secret, error)
	IDPPreset(ctx context.Context, name string) (*IDPPreset, error)
	IDPPresets(ctx context.Context, first *int, offset *int) ([]IDPPreset, error)
	MicroFrontends(ctx context.Context, namespace string) ([]MicroFrontend, error)
	ClusterMicroFrontends(ctx context.Context) ([]ClusterMicroFrontend, error)
	SelfSubjectRules(ctx context.Context, namespace *string) ([]ResourceRule, error)
	Function(ctx context.Context, name string, namespace string) (*Function, error)
	Functions(ctx context.Context, namespace string) ([]Function, error)
	Triggers(ctx context.Context, namespace string, subscriber *SubscriberInput) ([]Trigger, error)
}
type ServiceBindingResolver interface {
	Secret(ctx context.Context, obj *ServiceBinding) (*Secret, error)
}
type ServiceBindingUsageResolver interface {
	ServiceBinding(ctx context.Context, obj *ServiceBindingUsage) (*ServiceBinding, error)
}
type ServiceClassResolver interface {
	Plans(ctx context.Context, obj *ServiceClass) ([]ServicePlan, error)
	Activated(ctx context.Context, obj *ServiceClass) (bool, error)
	Instances(ctx context.Context, obj *ServiceClass) ([]ServiceInstance, error)
	ClusterAssetGroup(ctx context.Context, obj *ServiceClass) (*ClusterAssetGroup, error)
	AssetGroup(ctx context.Context, obj *ServiceClass) (*AssetGroup, error)
}
type ServiceInstanceResolver interface {
	ServiceClass(ctx context.Context, obj *ServiceInstance) (*ServiceClass, error)
	ClusterServiceClass(ctx context.Context, obj *ServiceInstance) (*ClusterServiceClass, error)
	ServicePlan(ctx context.Context, obj *ServiceInstance) (*ServicePlan, error)
	ClusterServicePlan(ctx context.Context, obj *ServiceInstance) (*ClusterServicePlan, error)
	Bindable(ctx context.Context, obj *ServiceInstance) (bool, error)
	ServiceBindings(ctx context.Context, obj *ServiceInstance) (*ServiceBindings, error)
	ServiceBindingUsages(ctx context.Context, obj *ServiceInstance) ([]ServiceBindingUsage, error)
}
type ServicePlanResolver interface {
	ClusterAssetGroup(ctx context.Context, obj *ServicePlan) (*ClusterAssetGroup, error)
	AssetGroup(ctx context.Context, obj *ServicePlan) (*AssetGroup, error)
}
type SubscriptionResolver interface {
	ClusterAssetEvent(ctx context.Context) (<-chan ClusterAssetEvent, error)
	AssetEvent(ctx context.Context, namespace string) (<-chan AssetEvent, error)
	ClusterAssetGroupEvent(ctx context.Context) (<-chan ClusterAssetGroupEvent, error)
	AssetGroupEvent(ctx context.Context, namespace string) (<-chan AssetGroupEvent, error)
	ServiceInstanceEvent(ctx context.Context, namespace string) (<-chan ServiceInstanceEvent, error)
	ServiceBindingEvent(ctx context.Context, namespace string) (<-chan ServiceBindingEvent, error)
	ServiceBindingUsageEvent(ctx context.Context, namespace string, resourceKind *string, resourceName *string) (<-chan ServiceBindingUsageEvent, error)
	ServiceBrokerEvent(ctx context.Context, namespace string) (<-chan ServiceBrokerEvent, error)
	ClusterServiceBrokerEvent(ctx context.Context) (<-chan ClusterServiceBrokerEvent, error)
	ApplicationEvent(ctx context.Context) (<-chan ApplicationEvent, error)
	PodEvent(ctx context.Context, namespace string) (<-chan PodEvent, error)
	ServiceEvent(ctx context.Context, namespace string) (<-chan ServiceEvent, error)
	ConfigMapEvent(ctx context.Context, namespace string) (<-chan ConfigMapEvent, error)
	ClusterAddonsConfigurationEvent(ctx context.Context) (<-chan ClusterAddonsConfigurationEvent, error)
	AddonsConfigurationEvent(ctx context.Context, namespace string) (<-chan AddonsConfigurationEvent, error)
	APIRuleEvent(ctx context.Context, namespace string, serviceName *string) (<-chan ApiRuleEvent, error)
	NamespaceEvent(ctx context.Context, withSystemNamespaces *bool) (<-chan NamespaceEvent, error)
	FunctionEvent(ctx context.Context, namespace string, functionName *string) (<-chan FunctionEvent, error)
	TriggerEvent(ctx context.Context, namespace string, subscriber *SubscriberInput) (<-chan TriggerEvent, error)
}

func field_Asset_files_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["filterExtensions"]; ok {
		var err error
		var rawIf1 []interface{}
		if tmp != nil {
			if tmp1, ok := tmp.([]interface{}); ok {
				rawIf1 = tmp1
			} else {
				rawIf1 = []interface{}{tmp}
			}
		}
		arg0 = make([]string, len(rawIf1))
		for idx1 := range rawIf1 {
			arg0[idx1], err = graphql.UnmarshalString(rawIf1[idx1])
		}
		if err != nil {
			return nil, err
		}
	}
	args["filterExtensions"] = arg0
	return args, nil

}

func field_AssetGroup_assets_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["types"]; ok {
		var err error
		var rawIf1 []interface{}
		if tmp != nil {
			if tmp1, ok := tmp.([]interface{}); ok {
				rawIf1 = tmp1
			} else {
				rawIf1 = []interface{}{tmp}
			}
		}
		arg0 = make([]string, len(rawIf1))
		for idx1 := range rawIf1 {
			arg0[idx1], err = graphql.UnmarshalString(rawIf1[idx1])
		}
		if err != nil {
			return nil, err
		}
	}
	args["types"] = arg0
	return args, nil

}

func field_ClusterAsset_files_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["filterExtensions"]; ok {
		var err error
		var rawIf1 []interface{}
		if tmp != nil {
			if tmp1, ok := tmp.([]interface{}); ok {
				rawIf1 = tmp1
			} else {
				rawIf1 = []interface{}{tmp}
			}
		}
		arg0 = make([]string, len(rawIf1))
		for idx1 := range rawIf1 {
			arg0[idx1], err = graphql.UnmarshalString(rawIf1[idx1])
		}
		if err != nil {
			return nil, err
		}
	}
	args["filterExtensions"] = arg0
	return args, nil

}

func field_ClusterAssetGroup_assets_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["types"]; ok {
		var err error
		var rawIf1 []interface{}
		if tmp != nil {
			if tmp1, ok := tmp.([]interface{}); ok {
				rawIf1 = tmp1
			} else {
				rawIf1 = []interface{}{tmp}
			}
		}
		arg0 = make([]string, len(rawIf1))
		for idx1 := range rawIf1 {
			arg0[idx1], err = graphql.UnmarshalString(rawIf1[idx1])
		}
		if err != nil {
			return nil, err
		}
	}
	args["types"] = arg0
	return args, nil

}

func field_ClusterServiceClass_activated_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	return args, nil

}

func field_ClusterServiceClass_instances_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	return args, nil

}

func field_Mutation_createResource_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	var arg1 JSON
	if tmp, ok := rawArgs["resource"]; ok {
		var err error
		err = (&arg1).UnmarshalGQL(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["resource"] = arg1
	return args, nil

}

func field_Mutation_createServiceInstance_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	var arg1 ServiceInstanceCreateInput
	if tmp, ok := rawArgs["params"]; ok {
		var err error
		arg1, err = UnmarshalServiceInstanceCreateInput(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["params"] = arg1
	return args, nil

}

func field_Mutation_deleteServiceInstance_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil

}

func field_Mutation_createServiceBinding_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["serviceBindingName"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["serviceBindingName"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["serviceInstanceName"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["serviceInstanceName"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg2, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg2
	var arg3 *JSON
	if tmp, ok := rawArgs["parameters"]; ok {
		var err error
		var ptr1 JSON
		if tmp != nil {
			err = (&ptr1).UnmarshalGQL(tmp)
			arg3 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["parameters"] = arg3
	return args, nil

}

func field_Mutation_deleteServiceBinding_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["serviceBindingName"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["serviceBindingName"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil

}

func field_Mutation_createServiceBindingUsage_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	var arg1 *CreateServiceBindingUsageInput
	if tmp, ok := rawArgs["createServiceBindingUsageInput"]; ok {
		var err error
		var ptr1 CreateServiceBindingUsageInput
		if tmp != nil {
			ptr1, err = UnmarshalCreateServiceBindingUsageInput(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["createServiceBindingUsageInput"] = arg1
	return args, nil

}

func field_Mutation_deleteServiceBindingUsage_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["serviceBindingUsageName"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["serviceBindingUsageName"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil

}

func field_Mutation_deleteServiceBindingUsages_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["serviceBindingUsageNames"]; ok {
		var err error
		var rawIf1 []interface{}
		if tmp != nil {
			if tmp1, ok := tmp.([]interface{}); ok {
				rawIf1 = tmp1
			} else {
				rawIf1 = []interface{}{tmp}
			}
		}
		arg0 = make([]string, len(rawIf1))
		for idx1 := range rawIf1 {
			arg0[idx1], err = graphql.UnmarshalString(rawIf1[idx1])
		}
		if err != nil {
			return nil, err
		}
	}
	args["serviceBindingUsageNames"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil

}

func field_Mutation_createClusterAddonsConfiguration_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 []AddonsConfigurationRepositoryInput
	if tmp, ok := rawArgs["repositories"]; ok {
		var err error
		var rawIf1 []interface{}
		if tmp != nil {
			if tmp1, ok := tmp.([]interface{}); ok {
				rawIf1 = tmp1
			} else {
				rawIf1 = []interface{}{tmp}
			}
		}
		arg1 = make([]AddonsConfigurationRepositoryInput, len(rawIf1))
		for idx1 := range rawIf1 {
			arg1[idx1], err = UnmarshalAddonsConfigurationRepositoryInput(rawIf1[idx1])
		}
		if err != nil {
			return nil, err
		}
	}
	args["repositories"] = arg1
	var arg2 []string
	if tmp, ok := rawArgs["urls"]; ok {
		var err error
		var rawIf1 []interface{}
		if tmp != nil {
			if tmp1, ok := tmp.([]interface{}); ok {
				rawIf1 = tmp1
			} else {
				rawIf1 = []interface{}{tmp}
			}
		}
		arg2 = make([]string, len(rawIf1))
		for idx1 := range rawIf1 {
			arg2[idx1], err = graphql.UnmarshalString(rawIf1[idx1])
		}
		if err != nil {
			return nil, err
		}
	}
	args["urls"] = arg2
	var arg3 *Labels
	if tmp, ok := rawArgs["labels"]; ok {
		var err error
		var ptr1 Labels
		if tmp != nil {
			err = (&ptr1).UnmarshalGQL(tmp)
			arg3 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["labels"] = arg3
	return args, nil

}

func field_Mutation_updateClusterAddonsConfiguration_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 []AddonsConfigurationRepositoryInput
	if tmp, ok := rawArgs["repositories"]; ok {
		var err error
		var rawIf1 []interface{}
		if tmp != nil {
			if tmp1, ok := tmp.([]interface{}); ok {
				rawIf1 = tmp1
			} else {
				rawIf1 = []interface{}{tmp}
			}
		}
		arg1 = make([]AddonsConfigurationRepositoryInput, len(rawIf1))
		for idx1 := range rawIf1 {
			arg1[idx1], err = UnmarshalAddonsConfigurationRepositoryInput(rawIf1[idx1])
		}
		if err != nil {
			return nil, err
		}
	}
	args["repositories"] = arg1
	var arg2 []string
	if tmp, ok := rawArgs["urls"]; ok {
		var err error
		var rawIf1 []interface{}
		if tmp != nil {
			if tmp1, ok := tmp.([]interface{}); ok {
				rawIf1 = tmp1
			} else {
				rawIf1 = []interface{}{tmp}
			}
		}
		arg2 = make([]string, len(rawIf1))
		for idx1 := range rawIf1 {
			arg2[idx1], err = graphql.UnmarshalString(rawIf1[idx1])
		}
		if err != nil {
			return nil, err
		}
	}
	args["urls"] = arg2
	var arg3 *Labels
	if tmp, ok := rawArgs["labels"]; ok {
		var err error
		var ptr1 Labels
		if tmp != nil {
			err = (&ptr1).UnmarshalGQL(tmp)
			arg3 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["labels"] = arg3
	return args, nil

}

func field_Mutation_deleteClusterAddonsConfiguration_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil

}

func field_Mutation_addClusterAddonsConfigurationURLs_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 []string
	if tmp, ok := rawArgs["urls"]; ok {
		var err error
		var rawIf1 []interface{}
		if tmp != nil {
			if tmp1, ok := tmp.([]interface{}); ok {
				rawIf1 = tmp1
			} else {
				rawIf1 = []interface{}{tmp}
			}
		}
		arg1 = make([]string, len(rawIf1))
		for idx1 := range rawIf1 {
			arg1[idx1], err = graphql.UnmarshalString(rawIf1[idx1])
		}
		if err != nil {
			return nil, err
		}
	}
	args["urls"] = arg1
	return args, nil

}

func field_Mutation_removeClusterAddonsConfigurationURLs_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 []string
	if tmp, ok := rawArgs["urls"]; ok {
		var err error
		var rawIf1 []interface{}
		if tmp != nil {
			if tmp1, ok := tmp.([]interface{}); ok {
				rawIf1 = tmp1
			} else {
				rawIf1 = []interface{}{tmp}
			}
		}
		arg1 = make([]string, len(rawIf1))
		for idx1 := range rawIf1 {
			arg1[idx1], err = graphql.UnmarshalString(rawIf1[idx1])
		}
		if err != nil {
			return nil, err
		}
	}
	args["urls"] = arg1
	return args, nil

}

func field_Mutation_addClusterAddonsConfigurationRepository_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 []AddonsConfigurationRepositoryInput
	if tmp, ok := rawArgs["repositories"]; ok {
		var err error
		var rawIf1 []interface{}
		if tmp != nil {
			if tmp1, ok := tmp.([]interface{}); ok {
				rawIf1 = tmp1
			} else {
				rawIf1 = []interface{}{tmp}
			}
		}
		arg1 = make([]AddonsConfigurationRepositoryInput, len(rawIf1))
		for idx1 := range rawIf1 {
			arg1[idx1], err = UnmarshalAddonsConfigurationRepositoryInput(rawIf1[idx1])
		}
		if err != nil {
			return nil, err
		}
	}
	args["repositories"] = arg1
	return args, nil

}

func field_Mutation_removeClusterAddonsConfigurationRepository_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 []string
	if tmp, ok := rawArgs["urls"]; ok {
		var err error
		var rawIf1 []interface{}
		if tmp != nil {
			if tmp1, ok := tmp.([]interface{}); ok {
				rawIf1 = tmp1
			} else {
				rawIf1 = []interface{}{tmp}
			}
		}
		arg1 = make([]string, len(rawIf1))
		for idx1 := range rawIf1 {
			arg1[idx1], err = graphql.UnmarshalString(rawIf1[idx1])
		}
		if err != nil {
			return nil, err
		}
	}
	args["urls"] = arg1
	return args, nil

}

func field_Mutation_resyncClusterAddonsConfiguration_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil

}

func field_Mutation_createAddonsConfiguration_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	var arg2 []AddonsConfigurationRepositoryInput
	if tmp, ok := rawArgs["repositories"]; ok {
		var err error
		var rawIf1 []interface{}
		if tmp != nil {
			if tmp1, ok := tmp.([]interface{}); ok {
				rawIf1 = tmp1
			} else {
				rawIf1 = []interface{}{tmp}
			}
		}
		arg2 = make([]AddonsConfigurationRepositoryInput, len(rawIf1))
		for idx1 := range rawIf1 {
			arg2[idx1], err = UnmarshalAddonsConfigurationRepositoryInput(rawIf1[idx1])
		}
		if err != nil {
			return nil, err
		}
	}
	args["repositories"] = arg2
	var arg3 []string
	if tmp, ok := rawArgs["urls"]; ok {
		var err error
		var rawIf1 []interface{}
		if tmp != nil {
			if tmp1, ok := tmp.([]interface{}); ok {
				rawIf1 = tmp1
			} else {
				rawIf1 = []interface{}{tmp}
			}
		}
		arg3 = make([]string, len(rawIf1))
		for idx1 := range rawIf1 {
			arg3[idx1], err = graphql.UnmarshalString(rawIf1[idx1])
		}
		if err != nil {
			return nil, err
		}
	}
	args["urls"] = arg3
	var arg4 *Labels
	if tmp, ok := rawArgs["labels"]; ok {
		var err error
		var ptr1 Labels
		if tmp != nil {
			err = (&ptr1).UnmarshalGQL(tmp)
			arg4 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["labels"] = arg4
	return args, nil

}

func field_Mutation_updateAddonsConfiguration_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	var arg2 []AddonsConfigurationRepositoryInput
	if tmp, ok := rawArgs["repositories"]; ok {
		var err error
		var rawIf1 []interface{}
		if tmp != nil {
			if tmp1, ok := tmp.([]interface{}); ok {
				rawIf1 = tmp1
			} else {
				rawIf1 = []interface{}{tmp}
			}
		}
		arg2 = make([]AddonsConfigurationRepositoryInput, len(rawIf1))
		for idx1 := range rawIf1 {
			arg2[idx1], err = UnmarshalAddonsConfigurationRepositoryInput(rawIf1[idx1])
		}
		if err != nil {
			return nil, err
		}
	}
	args["repositories"] = arg2
	var arg3 []string
	if tmp, ok := rawArgs["urls"]; ok {
		var err error
		var rawIf1 []interface{}
		if tmp != nil {
			if tmp1, ok := tmp.([]interface{}); ok {
				rawIf1 = tmp1
			} else {
				rawIf1 = []interface{}{tmp}
			}
		}
		arg3 = make([]string, len(rawIf1))
		for idx1 := range rawIf1 {
			arg3[idx1], err = graphql.UnmarshalString(rawIf1[idx1])
		}
		if err != nil {
			return nil, err
		}
	}
	args["urls"] = arg3
	var arg4 *Labels
	if tmp, ok := rawArgs["labels"]; ok {
		var err error
		var ptr1 Labels
		if tmp != nil {
			err = (&ptr1).UnmarshalGQL(tmp)
			arg4 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["labels"] = arg4
	return args, nil

}

func field_Mutation_deleteAddonsConfiguration_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil

}

func field_Mutation_addAddonsConfigurationURLs_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	var arg2 []string
	if tmp, ok := rawArgs["urls"]; ok {
		var err error
		var rawIf1 []interface{}
		if tmp != nil {
			if tmp1, ok := tmp.([]interface{}); ok {
				rawIf1 = tmp1
			} else {
				rawIf1 = []interface{}{tmp}
			}
		}
		arg2 = make([]string, len(rawIf1))
		for idx1 := range rawIf1 {
			arg2[idx1], err = graphql.UnmarshalString(rawIf1[idx1])
		}
		if err != nil {
			return nil, err
		}
	}
	args["urls"] = arg2
	return args, nil

}

func field_Mutation_removeAddonsConfigurationURLs_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	var arg2 []string
	if tmp, ok := rawArgs["urls"]; ok {
		var err error
		var rawIf1 []interface{}
		if tmp != nil {
			if tmp1, ok := tmp.([]interface{}); ok {
				rawIf1 = tmp1
			} else {
				rawIf1 = []interface{}{tmp}
			}
		}
		arg2 = make([]string, len(rawIf1))
		for idx1 := range rawIf1 {
			arg2[idx1], err = graphql.UnmarshalString(rawIf1[idx1])
		}
		if err != nil {
			return nil, err
		}
	}
	args["urls"] = arg2
	return args, nil

}

func field_Mutation_addAddonsConfigurationRepository_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	var arg2 []AddonsConfigurationRepositoryInput
	if tmp, ok := rawArgs["repositories"]; ok {
		var err error
		var rawIf1 []interface{}
		if tmp != nil {
			if tmp1, ok := tmp.([]interface{}); ok {
				rawIf1 = tmp1
			} else {
				rawIf1 = []interface{}{tmp}
			}
		}
		arg2 = make([]AddonsConfigurationRepositoryInput, len(rawIf1))
		for idx1 := range rawIf1 {
			arg2[idx1], err = UnmarshalAddonsConfigurationRepositoryInput(rawIf1[idx1])
		}
		if err != nil {
			return nil, err
		}
	}
	args["repositories"] = arg2
	return args, nil

}

func field_Mutation_removeAddonsConfigurationRepository_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	var arg2 []string
	if tmp, ok := rawArgs["urls"]; ok {
		var err error
		var rawIf1 []interface{}
		if tmp != nil {
			if tmp1, ok := tmp.([]interface{}); ok {
				rawIf1 = tmp1
			} else {
				rawIf1 = []interface{}{tmp}
			}
		}
		arg2 = make([]string, len(rawIf1))
		for idx1 := range rawIf1 {
			arg2[idx1], err = graphql.UnmarshalString(rawIf1[idx1])
		}
		if err != nil {
			return nil, err
		}
	}
	args["urls"] = arg2
	return args, nil

}

func field_Mutation_resyncAddonsConfiguration_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil

}

func field_Mutation_createApplication_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["description"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["description"] = arg1
	var arg2 *Labels
	if tmp, ok := rawArgs["labels"]; ok {
		var err error
		var ptr1 Labels
		if tmp != nil {
			err = (&ptr1).UnmarshalGQL(tmp)
			arg2 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["labels"] = arg2
	return args, nil

}

func field_Mutation_updateApplication_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["description"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["description"] = arg1
	var arg2 *Labels
	if tmp, ok := rawArgs["labels"]; ok {
		var err error
		var ptr1 Labels
		if tmp != nil {
			err = (&ptr1).UnmarshalGQL(tmp)
			arg2 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["labels"] = arg2
	return args, nil

}

func field_Mutation_deleteApplication_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil

}

func field_Mutation_enableApplication_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["application"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["application"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	var arg2 *bool
	if tmp, ok := rawArgs["allServices"]; ok {
		var err error
		var ptr1 bool
		if tmp != nil {
			ptr1, err = graphql.UnmarshalBoolean(tmp)
			arg2 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["allServices"] = arg2
	var arg3 []*ApplicationMappingService
	if tmp, ok := rawArgs["services"]; ok {
		var err error
		var rawIf1 []interface{}
		if tmp != nil {
			if tmp1, ok := tmp.([]interface{}); ok {
				rawIf1 = tmp1
			} else {
				rawIf1 = []interface{}{tmp}
			}
		}
		arg3 = make([]*ApplicationMappingService, len(rawIf1))
		for idx1 := range rawIf1 {
			var ptr2 ApplicationMappingService
			if rawIf1[idx1] != nil {
				err = (&ptr2).UnmarshalGQL(rawIf1[idx1])
				arg3[idx1] = &ptr2
			}
		}
		if err != nil {
			return nil, err
		}
	}
	args["services"] = arg3
	return args, nil

}

func field_Mutation_overloadApplication_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["application"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["application"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	var arg2 *bool
	if tmp, ok := rawArgs["allServices"]; ok {
		var err error
		var ptr1 bool
		if tmp != nil {
			ptr1, err = graphql.UnmarshalBoolean(tmp)
			arg2 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["allServices"] = arg2
	var arg3 []*ApplicationMappingService
	if tmp, ok := rawArgs["services"]; ok {
		var err error
		var rawIf1 []interface{}
		if tmp != nil {
			if tmp1, ok := tmp.([]interface{}); ok {
				rawIf1 = tmp1
			} else {
				rawIf1 = []interface{}{tmp}
			}
		}
		arg3 = make([]*ApplicationMappingService, len(rawIf1))
		for idx1 := range rawIf1 {
			var ptr2 ApplicationMappingService
			if rawIf1[idx1] != nil {
				err = (&ptr2).UnmarshalGQL(rawIf1[idx1])
				arg3[idx1] = &ptr2
			}
		}
		if err != nil {
			return nil, err
		}
	}
	args["services"] = arg3
	return args, nil

}

func field_Mutation_disableApplication_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["application"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["application"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil

}

func field_Mutation_updatePod_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	var arg2 JSON
	if tmp, ok := rawArgs["pod"]; ok {
		var err error
		err = (&arg2).UnmarshalGQL(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pod"] = arg2
	return args, nil

}

func field_Mutation_deletePod_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil

}

func field_Mutation_updateSecret_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	var arg2 JSON
	if tmp, ok := rawArgs["secret"]; ok {
		var err error
		err = (&arg2).UnmarshalGQL(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["secret"] = arg2
	return args, nil

}

func field_Mutation_deleteSecret_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil

}

func field_Mutation_updateReplicaSet_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	var arg2 JSON
	if tmp, ok := rawArgs["replicaSet"]; ok {
		var err error
		err = (&arg2).UnmarshalGQL(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["replicaSet"] = arg2
	return args, nil

}

func field_Mutation_deleteReplicaSet_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil

}

func field_Mutation_createResourceQuota_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg1
	var arg2 ResourceQuotaInput
	if tmp, ok := rawArgs["resourceQuota"]; ok {
		var err error
		arg2, err = UnmarshalResourceQuotaInput(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["resourceQuota"] = arg2
	return args, nil

}

func field_Mutation_updateConfigMap_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	var arg2 JSON
	if tmp, ok := rawArgs["configMap"]; ok {
		var err error
		err = (&arg2).UnmarshalGQL(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["configMap"] = arg2
	return args, nil

}

func field_Mutation_deleteConfigMap_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil

}

func field_Mutation_createIDPPreset_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["issuer"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["issuer"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["jwksUri"]; ok {
		var err error
		arg2, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["jwksUri"] = arg2
	return args, nil

}

func field_Mutation_deleteIDPPreset_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil

}

func field_Mutation_updateService_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	var arg2 JSON
	if tmp, ok := rawArgs["service"]; ok {
		var err error
		err = (&arg2).UnmarshalGQL(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["service"] = arg2
	return args, nil

}

func field_Mutation_deleteService_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil

}

func field_Mutation_createNamespace_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 *Labels
	if tmp, ok := rawArgs["labels"]; ok {
		var err error
		var ptr1 Labels
		if tmp != nil {
			err = (&ptr1).UnmarshalGQL(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["labels"] = arg1
	return args, nil

}

func field_Mutation_updateNamespace_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 Labels
	if tmp, ok := rawArgs["labels"]; ok {
		var err error
		err = (&arg1).UnmarshalGQL(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["labels"] = arg1
	return args, nil

}

func field_Mutation_deleteNamespace_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil

}

func field_Mutation_createAPIRule_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	var arg2 APIRuleInput
	if tmp, ok := rawArgs["params"]; ok {
		var err error
		arg2, err = UnmarshalAPIRuleInput(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["params"] = arg2
	return args, nil

}

func field_Mutation_updateAPIRule_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	var arg2 APIRuleInput
	if tmp, ok := rawArgs["params"]; ok {
		var err error
		arg2, err = UnmarshalAPIRuleInput(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["params"] = arg2
	return args, nil

}

func field_Mutation_deleteAPIRule_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil

}

func field_Mutation_createLimitRange_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg1
	var arg2 LimitRangeInput
	if tmp, ok := rawArgs["limitRange"]; ok {
		var err error
		arg2, err = UnmarshalLimitRangeInput(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limitRange"] = arg2
	return args, nil

}

func field_Mutation_createFunction_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	var arg2 FunctionMutationInput
	if tmp, ok := rawArgs["params"]; ok {
		var err error
		arg2, err = UnmarshalFunctionMutationInput(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["params"] = arg2
	return args, nil

}

func field_Mutation_updateFunction_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	var arg2 FunctionMutationInput
	if tmp, ok := rawArgs["params"]; ok {
		var err error
		arg2, err = UnmarshalFunctionMutationInput(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["params"] = arg2
	return args, nil

}

func field_Mutation_deleteFunction_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 FunctionMetadataInput
	if tmp, ok := rawArgs["function"]; ok {
		var err error
		arg0, err = UnmarshalFunctionMetadataInput(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["function"] = arg0
	return args, nil

}

func field_Mutation_deleteManyFunctions_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 []FunctionMetadataInput
	if tmp, ok := rawArgs["functions"]; ok {
		var err error
		var rawIf1 []interface{}
		if tmp != nil {
			if tmp1, ok := tmp.([]interface{}); ok {
				rawIf1 = tmp1
			} else {
				rawIf1 = []interface{}{tmp}
			}
		}
		arg0 = make([]FunctionMetadataInput, len(rawIf1))
		for idx1 := range rawIf1 {
			arg0[idx1], err = UnmarshalFunctionMetadataInput(rawIf1[idx1])
		}
		if err != nil {
			return nil, err
		}
	}
	args["functions"] = arg0
	return args, nil

}

func field_Mutation_createTrigger_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 TriggerCreateInput
	if tmp, ok := rawArgs["trigger"]; ok {
		var err error
		arg0, err = UnmarshalTriggerCreateInput(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["trigger"] = arg0
	var arg1 []OwnerReference
	if tmp, ok := rawArgs["ownerRef"]; ok {
		var err error
		var rawIf1 []interface{}
		if tmp != nil {
			if tmp1, ok := tmp.([]interface{}); ok {
				rawIf1 = tmp1
			} else {
				rawIf1 = []interface{}{tmp}
			}
		}
		arg1 = make([]OwnerReference, len(rawIf1))
		for idx1 := range rawIf1 {
			arg1[idx1], err = UnmarshalOwnerReference(rawIf1[idx1])
		}
		if err != nil {
			return nil, err
		}
	}
	args["ownerRef"] = arg1
	return args, nil

}

func field_Mutation_createManyTriggers_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 []TriggerCreateInput
	if tmp, ok := rawArgs["triggers"]; ok {
		var err error
		var rawIf1 []interface{}
		if tmp != nil {
			if tmp1, ok := tmp.([]interface{}); ok {
				rawIf1 = tmp1
			} else {
				rawIf1 = []interface{}{tmp}
			}
		}
		arg0 = make([]TriggerCreateInput, len(rawIf1))
		for idx1 := range rawIf1 {
			arg0[idx1], err = UnmarshalTriggerCreateInput(rawIf1[idx1])
		}
		if err != nil {
			return nil, err
		}
	}
	args["triggers"] = arg0
	var arg1 []OwnerReference
	if tmp, ok := rawArgs["ownerRef"]; ok {
		var err error
		var rawIf1 []interface{}
		if tmp != nil {
			if tmp1, ok := tmp.([]interface{}); ok {
				rawIf1 = tmp1
			} else {
				rawIf1 = []interface{}{tmp}
			}
		}
		arg1 = make([]OwnerReference, len(rawIf1))
		for idx1 := range rawIf1 {
			arg1[idx1], err = UnmarshalOwnerReference(rawIf1[idx1])
		}
		if err != nil {
			return nil, err
		}
	}
	args["ownerRef"] = arg1
	return args, nil

}

func field_Mutation_deleteTrigger_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 TriggerMetadataInput
	if tmp, ok := rawArgs["trigger"]; ok {
		var err error
		arg0, err = UnmarshalTriggerMetadataInput(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["trigger"] = arg0
	return args, nil

}

func field_Mutation_deleteManyTriggers_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 []TriggerMetadataInput
	if tmp, ok := rawArgs["triggers"]; ok {
		var err error
		var rawIf1 []interface{}
		if tmp != nil {
			if tmp1, ok := tmp.([]interface{}); ok {
				rawIf1 = tmp1
			} else {
				rawIf1 = []interface{}{tmp}
			}
		}
		arg0 = make([]TriggerMetadataInput, len(rawIf1))
		for idx1 := range rawIf1 {
			arg0[idx1], err = UnmarshalTriggerMetadataInput(rawIf1[idx1])
		}
		if err != nil {
			return nil, err
		}
	}
	args["triggers"] = arg0
	return args, nil

}

func field_Query_clusterAssetGroups_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["viewContext"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["viewContext"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["groupName"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["groupName"] = arg1
	return args, nil

}

func field_Query_serviceInstance_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil

}

func field_Query_serviceInstances_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["offset"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg2 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg2
	var arg3 *InstanceStatusType
	if tmp, ok := rawArgs["status"]; ok {
		var err error
		var ptr1 InstanceStatusType
		if tmp != nil {
			err = (&ptr1).UnmarshalGQL(tmp)
			arg3 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["status"] = arg3
	return args, nil

}

func field_Query_clusterServiceClasses_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["first"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	return args, nil

}

func field_Query_clusterServiceClass_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil

}

func field_Query_serviceClasses_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["offset"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg2 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg2
	return args, nil

}

func field_Query_serviceClass_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg1
	return args, nil

}

func field_Query_clusterServiceBrokers_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["first"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	return args, nil

}

func field_Query_clusterServiceBroker_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil

}

func field_Query_serviceBrokers_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["offset"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg2 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg2
	return args, nil

}

func field_Query_serviceBroker_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil

}

func field_Query_serviceBindingUsage_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil

}

func field_Query_serviceBindingUsages_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["resourceKind"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["resourceKind"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["resourceName"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg2 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["resourceName"] = arg2
	return args, nil

}

func field_Query_serviceBinding_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil

}

func field_Query_usageKinds_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["first"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	return args, nil

}

func field_Query_clusterAddonsConfigurations_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["first"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	return args, nil

}

func field_Query_addonsConfigurations_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["offset"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg2 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg2
	return args, nil

}

func field_Query_bindableResources_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	return args, nil

}

func field_Query_APIRules_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["serviceName"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["serviceName"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["hostname"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg2 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["hostname"] = arg2
	return args, nil

}

func field_Query_APIRule_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil

}

func field_Query_application_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil

}

func field_Query_applications_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["offset"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg2 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg2
	return args, nil

}

func field_Query_connectorService_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["application"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["application"] = arg0
	return args, nil

}

func field_Query_namespaces_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *bool
	if tmp, ok := rawArgs["withSystemNamespaces"]; ok {
		var err error
		var ptr1 bool
		if tmp != nil {
			ptr1, err = graphql.UnmarshalBoolean(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["withSystemNamespaces"] = arg0
	var arg1 *bool
	if tmp, ok := rawArgs["withInactiveStatus"]; ok {
		var err error
		var ptr1 bool
		if tmp != nil {
			ptr1, err = graphql.UnmarshalBoolean(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["withInactiveStatus"] = arg1
	return args, nil

}

func field_Query_namespace_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil

}

func field_Query_deployments_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	var arg1 *bool
	if tmp, ok := rawArgs["excludeFunctions"]; ok {
		var err error
		var ptr1 bool
		if tmp != nil {
			ptr1, err = graphql.UnmarshalBoolean(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["excludeFunctions"] = arg1
	return args, nil

}

func field_Query_pod_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil

}

func field_Query_pods_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["offset"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg2 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg2
	return args, nil

}

func field_Query_service_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil

}

func field_Query_services_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	var arg1 []string
	if tmp, ok := rawArgs["excludedLabels"]; ok {
		var err error
		var rawIf1 []interface{}
		if tmp != nil {
			if tmp1, ok := tmp.([]interface{}); ok {
				rawIf1 = tmp1
			} else {
				rawIf1 = []interface{}{tmp}
			}
		}
		arg1 = make([]string, len(rawIf1))
		for idx1 := range rawIf1 {
			arg1[idx1], err = graphql.UnmarshalString(rawIf1[idx1])
		}
		if err != nil {
			return nil, err
		}
	}
	args["excludedLabels"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["first"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg2 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["offset"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg3 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg3
	return args, nil

}

func field_Query_configMap_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil

}

func field_Query_configMaps_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["offset"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg2 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg2
	return args, nil

}

func field_Query_replicaSet_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil

}

func field_Query_replicaSets_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["offset"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg2 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg2
	return args, nil

}

func field_Query_resourceQuotas_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	return args, nil

}

func field_Query_resourceQuotasStatus_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	return args, nil

}

func field_Query_eventActivations_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	return args, nil

}

func field_Query_limitRanges_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	return args, nil

}

func field_Query_secret_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil

}

func field_Query_secrets_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["offset"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg2 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg2
	return args, nil

}

func field_Query_IDPPreset_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil

}

func field_Query_IDPPresets_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["first"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	return args, nil

}

func field_Query_microFrontends_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	return args, nil

}

func field_Query_selfSubjectRules_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	return args, nil

}

func field_Query_function_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil

}

func field_Query_functions_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	return args, nil

}

func field_Query_triggers_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	var arg1 *SubscriberInput
	if tmp, ok := rawArgs["subscriber"]; ok {
		var err error
		var ptr1 SubscriberInput
		if tmp != nil {
			ptr1, err = UnmarshalSubscriberInput(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["subscriber"] = arg1
	return args, nil

}

func field_Query___type_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil

}

func field_Subscription_assetEvent_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	return args, nil

}

func field_Subscription_assetGroupEvent_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	return args, nil

}

func field_Subscription_serviceInstanceEvent_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	return args, nil

}

func field_Subscription_serviceBindingEvent_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	return args, nil

}

func field_Subscription_serviceBindingUsageEvent_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["resourceKind"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["resourceKind"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["resourceName"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg2 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["resourceName"] = arg2
	return args, nil

}

func field_Subscription_serviceBrokerEvent_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	return args, nil

}

func field_Subscription_podEvent_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	return args, nil

}

func field_Subscription_serviceEvent_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	return args, nil

}

func field_Subscription_configMapEvent_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	return args, nil

}

func field_Subscription_addonsConfigurationEvent_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	return args, nil

}

func field_Subscription_apiRuleEvent_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["serviceName"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["serviceName"] = arg1
	return args, nil

}

func field_Subscription_namespaceEvent_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *bool
	if tmp, ok := rawArgs["withSystemNamespaces"]; ok {
		var err error
		var ptr1 bool
		if tmp != nil {
			ptr1, err = graphql.UnmarshalBoolean(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["withSystemNamespaces"] = arg0
	return args, nil

}

func field_Subscription_functionEvent_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["functionName"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["functionName"] = arg1
	return args, nil

}

func field_Subscription_triggerEvent_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg0
	var arg1 *SubscriberInput
	if tmp, ok := rawArgs["subscriber"]; ok {
		var err error
		var ptr1 SubscriberInput
		if tmp != nil {
			ptr1, err = UnmarshalSubscriberInput(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["subscriber"] = arg1
	return args, nil

}

func field___Type_fields_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		var err error
		arg0, err = graphql.UnmarshalBoolean(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil

}

func field___Type_enumValues_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		var err error
		arg0, err = graphql.UnmarshalBoolean(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil

}

func dir_HasAccess_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 ResourceAttributes
	if tmp, ok := rawArgs["attributes"]; ok {
		var err error
		arg0, err = UnmarshalResourceAttributes(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["attributes"] = arg0
	return args, nil

}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	switch typeName + "." + field {

	case "APIRule.name":
		if e.complexity.Apirule.Name == nil {
			break
		}

		return e.complexity.Apirule.Name(childComplexity), true

	case "APIRule.service":
		if e.complexity.Apirule.Service == nil {
			break
		}

		return e.complexity.Apirule.Service(childComplexity), true

	case "APIRule.gateway":
		if e.complexity.Apirule.Gateway == nil {
			break
		}

		return e.complexity.Apirule.Gateway(childComplexity), true

	case "APIRule.rules":
		if e.complexity.Apirule.Rules == nil {
			break
		}

		return e.complexity.Apirule.Rules(childComplexity), true

	case "APIRule.status":
		if e.complexity.Apirule.Status == nil {
			break
		}

		return e.complexity.Apirule.Status(childComplexity), true

	case "APIRuleConfig.name":
		if e.complexity.ApiruleConfig.Name == nil {
			break
		}

		return e.complexity.ApiruleConfig.Name(childComplexity), true

	case "APIRuleConfig.config":
		if e.complexity.ApiruleConfig.Config == nil {
			break
		}

		return e.complexity.ApiruleConfig.Config(childComplexity), true

	case "APIRuleService.host":
		if e.complexity.ApiruleService.Host == nil {
			break
		}

		return e.complexity.ApiruleService.Host(childComplexity), true

	case "APIRuleService.name":
		if e.complexity.ApiruleService.Name == nil {
			break
		}

		return e.complexity.ApiruleService.Name(childComplexity), true

	case "APIRuleService.port":
		if e.complexity.ApiruleService.Port == nil {
			break
		}

		return e.complexity.ApiruleService.Port(childComplexity), true

	case "APIRuleStatus.code":
		if e.complexity.ApiruleStatus.Code == nil {
			break
		}

		return e.complexity.ApiruleStatus.Code(childComplexity), true

	case "APIRuleStatus.desc":
		if e.complexity.ApiruleStatus.Desc == nil {
			break
		}

		return e.complexity.ApiruleStatus.Desc(childComplexity), true

	case "APIRuleStatuses.apiRuleStatus":
		if e.complexity.ApiruleStatuses.ApiRuleStatus == nil {
			break
		}

		return e.complexity.ApiruleStatuses.ApiRuleStatus(childComplexity), true

	case "APIRuleStatuses.accessRuleStatus":
		if e.complexity.ApiruleStatuses.AccessRuleStatus == nil {
			break
		}

		return e.complexity.ApiruleStatuses.AccessRuleStatus(childComplexity), true

	case "APIRuleStatuses.virtualServiceStatus":
		if e.complexity.ApiruleStatuses.VirtualServiceStatus == nil {
			break
		}

		return e.complexity.ApiruleStatuses.VirtualServiceStatus(childComplexity), true

	case "AddonsConfiguration.name":
		if e.complexity.AddonsConfiguration.Name == nil {
			break
		}

		return e.complexity.AddonsConfiguration.Name(childComplexity), true

	case "AddonsConfiguration.urls":
		if e.complexity.AddonsConfiguration.Urls == nil {
			break
		}

		return e.complexity.AddonsConfiguration.Urls(childComplexity), true

	case "AddonsConfiguration.repositories":
		if e.complexity.AddonsConfiguration.Repositories == nil {
			break
		}

		return e.complexity.AddonsConfiguration.Repositories(childComplexity), true

	case "AddonsConfiguration.labels":
		if e.complexity.AddonsConfiguration.Labels == nil {
			break
		}

		return e.complexity.AddonsConfiguration.Labels(childComplexity), true

	case "AddonsConfiguration.status":
		if e.complexity.AddonsConfiguration.Status == nil {
			break
		}

		return e.complexity.AddonsConfiguration.Status(childComplexity), true

	case "AddonsConfigurationEvent.type":
		if e.complexity.AddonsConfigurationEvent.Type == nil {
			break
		}

		return e.complexity.AddonsConfigurationEvent.Type(childComplexity), true

	case "AddonsConfigurationEvent.addonsConfiguration":
		if e.complexity.AddonsConfigurationEvent.AddonsConfiguration == nil {
			break
		}

		return e.complexity.AddonsConfigurationEvent.AddonsConfiguration(childComplexity), true

	case "AddonsConfigurationRepository.url":
		if e.complexity.AddonsConfigurationRepository.Url == nil {
			break
		}

		return e.complexity.AddonsConfigurationRepository.Url(childComplexity), true

	case "AddonsConfigurationRepository.secretRef":
		if e.complexity.AddonsConfigurationRepository.SecretRef == nil {
			break
		}

		return e.complexity.AddonsConfigurationRepository.SecretRef(childComplexity), true

	case "AddonsConfigurationStatus.phase":
		if e.complexity.AddonsConfigurationStatus.Phase == nil {
			break
		}

		return e.complexity.AddonsConfigurationStatus.Phase(childComplexity), true

	case "AddonsConfigurationStatus.repositories":
		if e.complexity.AddonsConfigurationStatus.Repositories == nil {
			break
		}

		return e.complexity.AddonsConfigurationStatus.Repositories(childComplexity), true

	case "AddonsConfigurationStatusAddons.name":
		if e.complexity.AddonsConfigurationStatusAddons.Name == nil {
			break
		}

		return e.complexity.AddonsConfigurationStatusAddons.Name(childComplexity), true

	case "AddonsConfigurationStatusAddons.version":
		if e.complexity.AddonsConfigurationStatusAddons.Version == nil {
			break
		}

		return e.complexity.AddonsConfigurationStatusAddons.Version(childComplexity), true

	case "AddonsConfigurationStatusAddons.status":
		if e.complexity.AddonsConfigurationStatusAddons.Status == nil {
			break
		}

		return e.complexity.AddonsConfigurationStatusAddons.Status(childComplexity), true

	case "AddonsConfigurationStatusAddons.reason":
		if e.complexity.AddonsConfigurationStatusAddons.Reason == nil {
			break
		}

		return e.complexity.AddonsConfigurationStatusAddons.Reason(childComplexity), true

	case "AddonsConfigurationStatusAddons.message":
		if e.complexity.AddonsConfigurationStatusAddons.Message == nil {
			break
		}

		return e.complexity.AddonsConfigurationStatusAddons.Message(childComplexity), true

	case "AddonsConfigurationStatusRepository.url":
		if e.complexity.AddonsConfigurationStatusRepository.Url == nil {
			break
		}

		return e.complexity.AddonsConfigurationStatusRepository.Url(childComplexity), true

	case "AddonsConfigurationStatusRepository.status":
		if e.complexity.AddonsConfigurationStatusRepository.Status == nil {
			break
		}

		return e.complexity.AddonsConfigurationStatusRepository.Status(childComplexity), true

	case "AddonsConfigurationStatusRepository.addons":
		if e.complexity.AddonsConfigurationStatusRepository.Addons == nil {
			break
		}

		return e.complexity.AddonsConfigurationStatusRepository.Addons(childComplexity), true

	case "AddonsConfigurationStatusRepository.reason":
		if e.complexity.AddonsConfigurationStatusRepository.Reason == nil {
			break
		}

		return e.complexity.AddonsConfigurationStatusRepository.Reason(childComplexity), true

	case "AddonsConfigurationStatusRepository.message":
		if e.complexity.AddonsConfigurationStatusRepository.Message == nil {
			break
		}

		return e.complexity.AddonsConfigurationStatusRepository.Message(childComplexity), true

	case "ApiRuleEvent.type":
		if e.complexity.ApiRuleEvent.Type == nil {
			break
		}

		return e.complexity.ApiRuleEvent.Type(childComplexity), true

	case "ApiRuleEvent.apiRule":
		if e.complexity.ApiRuleEvent.ApiRule == nil {
			break
		}

		return e.complexity.ApiRuleEvent.ApiRule(childComplexity), true

	case "Application.name":
		if e.complexity.Application.Name == nil {
			break
		}

		return e.complexity.Application.Name(childComplexity), true

	case "Application.description":
		if e.complexity.Application.Description == nil {
			break
		}

		return e.complexity.Application.Description(childComplexity), true

	case "Application.labels":
		if e.complexity.Application.Labels == nil {
			break
		}

		return e.complexity.Application.Labels(childComplexity), true

	case "Application.services":
		if e.complexity.Application.Services == nil {
			break
		}

		return e.complexity.Application.Services(childComplexity), true

	case "Application.enabledInNamespaces":
		if e.complexity.Application.EnabledInNamespaces == nil {
			break
		}

		return e.complexity.Application.EnabledInNamespaces(childComplexity), true

	case "Application.enabledMappingServices":
		if e.complexity.Application.EnabledMappingServices == nil {
			break
		}

		return e.complexity.Application.EnabledMappingServices(childComplexity), true

	case "Application.status":
		if e.complexity.Application.Status == nil {
			break
		}

		return e.complexity.Application.Status(childComplexity), true

	case "Application.compassMetadata":
		if e.complexity.Application.CompassMetadata == nil {
			break
		}

		return e.complexity.Application.CompassMetadata(childComplexity), true

	case "ApplicationEntry.type":
		if e.complexity.ApplicationEntry.Type == nil {
			break
		}

		return e.complexity.ApplicationEntry.Type(childComplexity), true

	case "ApplicationEntry.gatewayUrl":
		if e.complexity.ApplicationEntry.GatewayUrl == nil {
			break
		}

		return e.complexity.ApplicationEntry.GatewayUrl(childComplexity), true

	case "ApplicationEntry.accessLabel":
		if e.complexity.ApplicationEntry.AccessLabel == nil {
			break
		}

		return e.complexity.ApplicationEntry.AccessLabel(childComplexity), true

	case "ApplicationEvent.type":
		if e.complexity.ApplicationEvent.Type == nil {
			break
		}

		return e.complexity.ApplicationEvent.Type(childComplexity), true

	case "ApplicationEvent.application":
		if e.complexity.ApplicationEvent.Application == nil {
			break
		}

		return e.complexity.ApplicationEvent.Application(childComplexity), true

	case "ApplicationMapping.namespace":
		if e.complexity.ApplicationMapping.Namespace == nil {
			break
		}

		return e.complexity.ApplicationMapping.Namespace(childComplexity), true

	case "ApplicationMapping.application":
		if e.complexity.ApplicationMapping.Application == nil {
			break
		}

		return e.complexity.ApplicationMapping.Application(childComplexity), true

	case "ApplicationMapping.allServices":
		if e.complexity.ApplicationMapping.AllServices == nil {
			break
		}

		return e.complexity.ApplicationMapping.AllServices(childComplexity), true

	case "ApplicationMapping.services":
		if e.complexity.ApplicationMapping.Services == nil {
			break
		}

		return e.complexity.ApplicationMapping.Services(childComplexity), true

	case "ApplicationMutationOutput.name":
		if e.complexity.ApplicationMutationOutput.Name == nil {
			break
		}

		return e.complexity.ApplicationMutationOutput.Name(childComplexity), true

	case "ApplicationMutationOutput.description":
		if e.complexity.ApplicationMutationOutput.Description == nil {
			break
		}

		return e.complexity.ApplicationMutationOutput.Description(childComplexity), true

	case "ApplicationMutationOutput.labels":
		if e.complexity.ApplicationMutationOutput.Labels == nil {
			break
		}

		return e.complexity.ApplicationMutationOutput.Labels(childComplexity), true

	case "ApplicationService.id":
		if e.complexity.ApplicationService.Id == nil {
			break
		}

		return e.complexity.ApplicationService.Id(childComplexity), true

	case "ApplicationService.displayName":
		if e.complexity.ApplicationService.DisplayName == nil {
			break
		}

		return e.complexity.ApplicationService.DisplayName(childComplexity), true

	case "ApplicationService.longDescription":
		if e.complexity.ApplicationService.LongDescription == nil {
			break
		}

		return e.complexity.ApplicationService.LongDescription(childComplexity), true

	case "ApplicationService.providerDisplayName":
		if e.complexity.ApplicationService.ProviderDisplayName == nil {
			break
		}

		return e.complexity.ApplicationService.ProviderDisplayName(childComplexity), true

	case "ApplicationService.tags":
		if e.complexity.ApplicationService.Tags == nil {
			break
		}

		return e.complexity.ApplicationService.Tags(childComplexity), true

	case "ApplicationService.entries":
		if e.complexity.ApplicationService.Entries == nil {
			break
		}

		return e.complexity.ApplicationService.Entries(childComplexity), true

	case "Asset.name":
		if e.complexity.Asset.Name == nil {
			break
		}

		return e.complexity.Asset.Name(childComplexity), true

	case "Asset.namespace":
		if e.complexity.Asset.Namespace == nil {
			break
		}

		return e.complexity.Asset.Namespace(childComplexity), true

	case "Asset.parameters":
		if e.complexity.Asset.Parameters == nil {
			break
		}

		return e.complexity.Asset.Parameters(childComplexity), true

	case "Asset.type":
		if e.complexity.Asset.Type == nil {
			break
		}

		return e.complexity.Asset.Type(childComplexity), true

	case "Asset.files":
		if e.complexity.Asset.Files == nil {
			break
		}

		args, err := field_Asset_files_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Asset.Files(childComplexity, args["filterExtensions"].([]string)), true

	case "Asset.status":
		if e.complexity.Asset.Status == nil {
			break
		}

		return e.complexity.Asset.Status(childComplexity), true

	case "Asset.displayName":
		if e.complexity.Asset.DisplayName == nil {
			break
		}

		return e.complexity.Asset.DisplayName(childComplexity), true

	case "AssetEvent.type":
		if e.complexity.AssetEvent.Type == nil {
			break
		}

		return e.complexity.AssetEvent.Type(childComplexity), true

	case "AssetEvent.asset":
		if e.complexity.AssetEvent.Asset == nil {
			break
		}

		return e.complexity.AssetEvent.Asset(childComplexity), true

	case "AssetGroup.name":
		if e.complexity.AssetGroup.Name == nil {
			break
		}

		return e.complexity.AssetGroup.Name(childComplexity), true

	case "AssetGroup.namespace":
		if e.complexity.AssetGroup.Namespace == nil {
			break
		}

		return e.complexity.AssetGroup.Namespace(childComplexity), true

	case "AssetGroup.groupName":
		if e.complexity.AssetGroup.GroupName == nil {
			break
		}

		return e.complexity.AssetGroup.GroupName(childComplexity), true

	case "AssetGroup.assets":
		if e.complexity.AssetGroup.Assets == nil {
			break
		}

		args, err := field_AssetGroup_assets_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AssetGroup.Assets(childComplexity, args["types"].([]string)), true

	case "AssetGroup.displayName":
		if e.complexity.AssetGroup.DisplayName == nil {
			break
		}

		return e.complexity.AssetGroup.DisplayName(childComplexity), true

	case "AssetGroup.description":
		if e.complexity.AssetGroup.Description == nil {
			break
		}

		return e.complexity.AssetGroup.Description(childComplexity), true

	case "AssetGroup.status":
		if e.complexity.AssetGroup.Status == nil {
			break
		}

		return e.complexity.AssetGroup.Status(childComplexity), true

	case "AssetGroupEvent.type":
		if e.complexity.AssetGroupEvent.Type == nil {
			break
		}

		return e.complexity.AssetGroupEvent.Type(childComplexity), true

	case "AssetGroupEvent.assetGroup":
		if e.complexity.AssetGroupEvent.AssetGroup == nil {
			break
		}

		return e.complexity.AssetGroupEvent.AssetGroup(childComplexity), true

	case "AssetGroupStatus.phase":
		if e.complexity.AssetGroupStatus.Phase == nil {
			break
		}

		return e.complexity.AssetGroupStatus.Phase(childComplexity), true

	case "AssetGroupStatus.reason":
		if e.complexity.AssetGroupStatus.Reason == nil {
			break
		}

		return e.complexity.AssetGroupStatus.Reason(childComplexity), true

	case "AssetGroupStatus.message":
		if e.complexity.AssetGroupStatus.Message == nil {
			break
		}

		return e.complexity.AssetGroupStatus.Message(childComplexity), true

	case "AssetStatus.phase":
		if e.complexity.AssetStatus.Phase == nil {
			break
		}

		return e.complexity.AssetStatus.Phase(childComplexity), true

	case "AssetStatus.reason":
		if e.complexity.AssetStatus.Reason == nil {
			break
		}

		return e.complexity.AssetStatus.Reason(childComplexity), true

	case "AssetStatus.message":
		if e.complexity.AssetStatus.Message == nil {
			break
		}

		return e.complexity.AssetStatus.Message(childComplexity), true

	case "BackendModule.name":
		if e.complexity.BackendModule.Name == nil {
			break
		}

		return e.complexity.BackendModule.Name(childComplexity), true

	case "BindableResourcesOutputItem.kind":
		if e.complexity.BindableResourcesOutputItem.Kind == nil {
			break
		}

		return e.complexity.BindableResourcesOutputItem.Kind(childComplexity), true

	case "BindableResourcesOutputItem.displayName":
		if e.complexity.BindableResourcesOutputItem.DisplayName == nil {
			break
		}

		return e.complexity.BindableResourcesOutputItem.DisplayName(childComplexity), true

	case "BindableResourcesOutputItem.resources":
		if e.complexity.BindableResourcesOutputItem.Resources == nil {
			break
		}

		return e.complexity.BindableResourcesOutputItem.Resources(childComplexity), true

	case "ClusterAddonsConfigurationEvent.type":
		if e.complexity.ClusterAddonsConfigurationEvent.Type == nil {
			break
		}

		return e.complexity.ClusterAddonsConfigurationEvent.Type(childComplexity), true

	case "ClusterAddonsConfigurationEvent.addonsConfiguration":
		if e.complexity.ClusterAddonsConfigurationEvent.AddonsConfiguration == nil {
			break
		}

		return e.complexity.ClusterAddonsConfigurationEvent.AddonsConfiguration(childComplexity), true

	case "ClusterAsset.name":
		if e.complexity.ClusterAsset.Name == nil {
			break
		}

		return e.complexity.ClusterAsset.Name(childComplexity), true

	case "ClusterAsset.parameters":
		if e.complexity.ClusterAsset.Parameters == nil {
			break
		}

		return e.complexity.ClusterAsset.Parameters(childComplexity), true

	case "ClusterAsset.type":
		if e.complexity.ClusterAsset.Type == nil {
			break
		}

		return e.complexity.ClusterAsset.Type(childComplexity), true

	case "ClusterAsset.files":
		if e.complexity.ClusterAsset.Files == nil {
			break
		}

		args, err := field_ClusterAsset_files_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ClusterAsset.Files(childComplexity, args["filterExtensions"].([]string)), true

	case "ClusterAsset.status":
		if e.complexity.ClusterAsset.Status == nil {
			break
		}

		return e.complexity.ClusterAsset.Status(childComplexity), true

	case "ClusterAsset.displayName":
		if e.complexity.ClusterAsset.DisplayName == nil {
			break
		}

		return e.complexity.ClusterAsset.DisplayName(childComplexity), true

	case "ClusterAssetEvent.type":
		if e.complexity.ClusterAssetEvent.Type == nil {
			break
		}

		return e.complexity.ClusterAssetEvent.Type(childComplexity), true

	case "ClusterAssetEvent.clusterAsset":
		if e.complexity.ClusterAssetEvent.ClusterAsset == nil {
			break
		}

		return e.complexity.ClusterAssetEvent.ClusterAsset(childComplexity), true

	case "ClusterAssetGroup.name":
		if e.complexity.ClusterAssetGroup.Name == nil {
			break
		}

		return e.complexity.ClusterAssetGroup.Name(childComplexity), true

	case "ClusterAssetGroup.groupName":
		if e.complexity.ClusterAssetGroup.GroupName == nil {
			break
		}

		return e.complexity.ClusterAssetGroup.GroupName(childComplexity), true

	case "ClusterAssetGroup.assets":
		if e.complexity.ClusterAssetGroup.Assets == nil {
			break
		}

		args, err := field_ClusterAssetGroup_assets_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ClusterAssetGroup.Assets(childComplexity, args["types"].([]string)), true

	case "ClusterAssetGroup.displayName":
		if e.complexity.ClusterAssetGroup.DisplayName == nil {
			break
		}

		return e.complexity.ClusterAssetGroup.DisplayName(childComplexity), true

	case "ClusterAssetGroup.description":
		if e.complexity.ClusterAssetGroup.Description == nil {
			break
		}

		return e.complexity.ClusterAssetGroup.Description(childComplexity), true

	case "ClusterAssetGroup.status":
		if e.complexity.ClusterAssetGroup.Status == nil {
			break
		}

		return e.complexity.ClusterAssetGroup.Status(childComplexity), true

	case "ClusterAssetGroupEvent.type":
		if e.complexity.ClusterAssetGroupEvent.Type == nil {
			break
		}

		return e.complexity.ClusterAssetGroupEvent.Type(childComplexity), true

	case "ClusterAssetGroupEvent.clusterAssetGroup":
		if e.complexity.ClusterAssetGroupEvent.ClusterAssetGroup == nil {
			break
		}

		return e.complexity.ClusterAssetGroupEvent.ClusterAssetGroup(childComplexity), true

	case "ClusterMicroFrontend.name":
		if e.complexity.ClusterMicroFrontend.Name == nil {
			break
		}

		return e.complexity.ClusterMicroFrontend.Name(childComplexity), true

	case "ClusterMicroFrontend.version":
		if e.complexity.ClusterMicroFrontend.Version == nil {
			break
		}

		return e.complexity.ClusterMicroFrontend.Version(childComplexity), true

	case "ClusterMicroFrontend.category":
		if e.complexity.ClusterMicroFrontend.Category == nil {
			break
		}

		return e.complexity.ClusterMicroFrontend.Category(childComplexity), true

	case "ClusterMicroFrontend.viewBaseUrl":
		if e.complexity.ClusterMicroFrontend.ViewBaseUrl == nil {
			break
		}

		return e.complexity.ClusterMicroFrontend.ViewBaseUrl(childComplexity), true

	case "ClusterMicroFrontend.placement":
		if e.complexity.ClusterMicroFrontend.Placement == nil {
			break
		}

		return e.complexity.ClusterMicroFrontend.Placement(childComplexity), true

	case "ClusterMicroFrontend.preloadUrl":
		if e.complexity.ClusterMicroFrontend.PreloadUrl == nil {
			break
		}

		return e.complexity.ClusterMicroFrontend.PreloadUrl(childComplexity), true

	case "ClusterMicroFrontend.navigationNodes":
		if e.complexity.ClusterMicroFrontend.NavigationNodes == nil {
			break
		}

		return e.complexity.ClusterMicroFrontend.NavigationNodes(childComplexity), true

	case "ClusterServiceBroker.name":
		if e.complexity.ClusterServiceBroker.Name == nil {
			break
		}

		return e.complexity.ClusterServiceBroker.Name(childComplexity), true

	case "ClusterServiceBroker.status":
		if e.complexity.ClusterServiceBroker.Status == nil {
			break
		}

		return e.complexity.ClusterServiceBroker.Status(childComplexity), true

	case "ClusterServiceBroker.creationTimestamp":
		if e.complexity.ClusterServiceBroker.CreationTimestamp == nil {
			break
		}

		return e.complexity.ClusterServiceBroker.CreationTimestamp(childComplexity), true

	case "ClusterServiceBroker.url":
		if e.complexity.ClusterServiceBroker.Url == nil {
			break
		}

		return e.complexity.ClusterServiceBroker.Url(childComplexity), true

	case "ClusterServiceBroker.labels":
		if e.complexity.ClusterServiceBroker.Labels == nil {
			break
		}

		return e.complexity.ClusterServiceBroker.Labels(childComplexity), true

	case "ClusterServiceBrokerEvent.type":
		if e.complexity.ClusterServiceBrokerEvent.Type == nil {
			break
		}

		return e.complexity.ClusterServiceBrokerEvent.Type(childComplexity), true

	case "ClusterServiceBrokerEvent.clusterServiceBroker":
		if e.complexity.ClusterServiceBrokerEvent.ClusterServiceBroker == nil {
			break
		}

		return e.complexity.ClusterServiceBrokerEvent.ClusterServiceBroker(childComplexity), true

	case "ClusterServiceClass.name":
		if e.complexity.ClusterServiceClass.Name == nil {
			break
		}

		return e.complexity.ClusterServiceClass.Name(childComplexity), true

	case "ClusterServiceClass.externalName":
		if e.complexity.ClusterServiceClass.ExternalName == nil {
			break
		}

		return e.complexity.ClusterServiceClass.ExternalName(childComplexity), true

	case "ClusterServiceClass.displayName":
		if e.complexity.ClusterServiceClass.DisplayName == nil {
			break
		}

		return e.complexity.ClusterServiceClass.DisplayName(childComplexity), true

	case "ClusterServiceClass.creationTimestamp":
		if e.complexity.ClusterServiceClass.CreationTimestamp == nil {
			break
		}

		return e.complexity.ClusterServiceClass.CreationTimestamp(childComplexity), true

	case "ClusterServiceClass.description":
		if e.complexity.ClusterServiceClass.Description == nil {
			break
		}

		return e.complexity.ClusterServiceClass.Description(childComplexity), true

	case "ClusterServiceClass.longDescription":
		if e.complexity.ClusterServiceClass.LongDescription == nil {
			break
		}

		return e.complexity.ClusterServiceClass.LongDescription(childComplexity), true

	case "ClusterServiceClass.imageUrl":
		if e.complexity.ClusterServiceClass.ImageUrl == nil {
			break
		}

		return e.complexity.ClusterServiceClass.ImageUrl(childComplexity), true

	case "ClusterServiceClass.documentationUrl":
		if e.complexity.ClusterServiceClass.DocumentationUrl == nil {
			break
		}

		return e.complexity.ClusterServiceClass.DocumentationUrl(childComplexity), true

	case "ClusterServiceClass.supportUrl":
		if e.complexity.ClusterServiceClass.SupportUrl == nil {
			break
		}

		return e.complexity.ClusterServiceClass.SupportUrl(childComplexity), true

	case "ClusterServiceClass.providerDisplayName":
		if e.complexity.ClusterServiceClass.ProviderDisplayName == nil {
			break
		}

		return e.complexity.ClusterServiceClass.ProviderDisplayName(childComplexity), true

	case "ClusterServiceClass.tags":
		if e.complexity.ClusterServiceClass.Tags == nil {
			break
		}

		return e.complexity.ClusterServiceClass.Tags(childComplexity), true

	case "ClusterServiceClass.labels":
		if e.complexity.ClusterServiceClass.Labels == nil {
			break
		}

		return e.complexity.ClusterServiceClass.Labels(childComplexity), true

	case "ClusterServiceClass.plans":
		if e.complexity.ClusterServiceClass.Plans == nil {
			break
		}

		return e.complexity.ClusterServiceClass.Plans(childComplexity), true

	case "ClusterServiceClass.activated":
		if e.complexity.ClusterServiceClass.Activated == nil {
			break
		}

		args, err := field_ClusterServiceClass_activated_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ClusterServiceClass.Activated(childComplexity, args["namespace"].(*string)), true

	case "ClusterServiceClass.instances":
		if e.complexity.ClusterServiceClass.Instances == nil {
			break
		}

		args, err := field_ClusterServiceClass_instances_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ClusterServiceClass.Instances(childComplexity, args["namespace"].(*string)), true

	case "ClusterServiceClass.clusterAssetGroup":
		if e.complexity.ClusterServiceClass.ClusterAssetGroup == nil {
			break
		}

		return e.complexity.ClusterServiceClass.ClusterAssetGroup(childComplexity), true

	case "ClusterServicePlan.name":
		if e.complexity.ClusterServicePlan.Name == nil {
			break
		}

		return e.complexity.ClusterServicePlan.Name(childComplexity), true

	case "ClusterServicePlan.displayName":
		if e.complexity.ClusterServicePlan.DisplayName == nil {
			break
		}

		return e.complexity.ClusterServicePlan.DisplayName(childComplexity), true

	case "ClusterServicePlan.externalName":
		if e.complexity.ClusterServicePlan.ExternalName == nil {
			break
		}

		return e.complexity.ClusterServicePlan.ExternalName(childComplexity), true

	case "ClusterServicePlan.description":
		if e.complexity.ClusterServicePlan.Description == nil {
			break
		}

		return e.complexity.ClusterServicePlan.Description(childComplexity), true

	case "ClusterServicePlan.relatedClusterServiceClassName":
		if e.complexity.ClusterServicePlan.RelatedClusterServiceClassName == nil {
			break
		}

		return e.complexity.ClusterServicePlan.RelatedClusterServiceClassName(childComplexity), true

	case "ClusterServicePlan.instanceCreateParameterSchema":
		if e.complexity.ClusterServicePlan.InstanceCreateParameterSchema == nil {
			break
		}

		return e.complexity.ClusterServicePlan.InstanceCreateParameterSchema(childComplexity), true

	case "ClusterServicePlan.bindingCreateParameterSchema":
		if e.complexity.ClusterServicePlan.BindingCreateParameterSchema == nil {
			break
		}

		return e.complexity.ClusterServicePlan.BindingCreateParameterSchema(childComplexity), true

	case "ClusterServicePlan.clusterAssetGroup":
		if e.complexity.ClusterServicePlan.ClusterAssetGroup == nil {
			break
		}

		return e.complexity.ClusterServicePlan.ClusterAssetGroup(childComplexity), true

	case "ConfigMap.name":
		if e.complexity.ConfigMap.Name == nil {
			break
		}

		return e.complexity.ConfigMap.Name(childComplexity), true

	case "ConfigMap.namespace":
		if e.complexity.ConfigMap.Namespace == nil {
			break
		}

		return e.complexity.ConfigMap.Namespace(childComplexity), true

	case "ConfigMap.creationTimestamp":
		if e.complexity.ConfigMap.CreationTimestamp == nil {
			break
		}

		return e.complexity.ConfigMap.CreationTimestamp(childComplexity), true

	case "ConfigMap.labels":
		if e.complexity.ConfigMap.Labels == nil {
			break
		}

		return e.complexity.ConfigMap.Labels(childComplexity), true

	case "ConfigMap.json":
		if e.complexity.ConfigMap.Json == nil {
			break
		}

		return e.complexity.ConfigMap.Json(childComplexity), true

	case "ConfigMapEvent.type":
		if e.complexity.ConfigMapEvent.Type == nil {
			break
		}

		return e.complexity.ConfigMapEvent.Type(childComplexity), true

	case "ConfigMapEvent.configMap":
		if e.complexity.ConfigMapEvent.ConfigMap == nil {
			break
		}

		return e.complexity.ConfigMapEvent.ConfigMap(childComplexity), true

	case "ConnectorService.url":
		if e.complexity.ConnectorService.Url == nil {
			break
		}

		return e.complexity.ConnectorService.Url(childComplexity), true

	case "Container.name":
		if e.complexity.Container.Name == nil {
			break
		}

		return e.complexity.Container.Name(childComplexity), true

	case "Container.image":
		if e.complexity.Container.Image == nil {
			break
		}

		return e.complexity.Container.Image(childComplexity), true

	case "ContainerState.state":
		if e.complexity.ContainerState.State == nil {
			break
		}

		return e.complexity.ContainerState.State(childComplexity), true

	case "ContainerState.reason":
		if e.complexity.ContainerState.Reason == nil {
			break
		}

		return e.complexity.ContainerState.Reason(childComplexity), true

	case "ContainerState.message":
		if e.complexity.ContainerState.Message == nil {
			break
		}

		return e.complexity.ContainerState.Message(childComplexity), true

	case "CreateServiceBindingOutput.name":
		if e.complexity.CreateServiceBindingOutput.Name == nil {
			break
		}

		return e.complexity.CreateServiceBindingOutput.Name(childComplexity), true

	case "CreateServiceBindingOutput.serviceInstanceName":
		if e.complexity.CreateServiceBindingOutput.ServiceInstanceName == nil {
			break
		}

		return e.complexity.CreateServiceBindingOutput.ServiceInstanceName(childComplexity), true

	case "CreateServiceBindingOutput.namespace":
		if e.complexity.CreateServiceBindingOutput.Namespace == nil {
			break
		}

		return e.complexity.CreateServiceBindingOutput.Namespace(childComplexity), true

	case "DeleteApplicationOutput.name":
		if e.complexity.DeleteApplicationOutput.Name == nil {
			break
		}

		return e.complexity.DeleteApplicationOutput.Name(childComplexity), true

	case "DeleteServiceBindingOutput.name":
		if e.complexity.DeleteServiceBindingOutput.Name == nil {
			break
		}

		return e.complexity.DeleteServiceBindingOutput.Name(childComplexity), true

	case "DeleteServiceBindingOutput.namespace":
		if e.complexity.DeleteServiceBindingOutput.Namespace == nil {
			break
		}

		return e.complexity.DeleteServiceBindingOutput.Namespace(childComplexity), true

	case "DeleteServiceBindingUsageOutput.name":
		if e.complexity.DeleteServiceBindingUsageOutput.Name == nil {
			break
		}

		return e.complexity.DeleteServiceBindingUsageOutput.Name(childComplexity), true

	case "DeleteServiceBindingUsageOutput.namespace":
		if e.complexity.DeleteServiceBindingUsageOutput.Namespace == nil {
			break
		}

		return e.complexity.DeleteServiceBindingUsageOutput.Namespace(childComplexity), true

	case "Deployment.name":
		if e.complexity.Deployment.Name == nil {
			break
		}

		return e.complexity.Deployment.Name(childComplexity), true

	case "Deployment.namespace":
		if e.complexity.Deployment.Namespace == nil {
			break
		}

		return e.complexity.Deployment.Namespace(childComplexity), true

	case "Deployment.creationTimestamp":
		if e.complexity.Deployment.CreationTimestamp == nil {
			break
		}

		return e.complexity.Deployment.CreationTimestamp(childComplexity), true

	case "Deployment.status":
		if e.complexity.Deployment.Status == nil {
			break
		}

		return e.complexity.Deployment.Status(childComplexity), true

	case "Deployment.labels":
		if e.complexity.Deployment.Labels == nil {
			break
		}

		return e.complexity.Deployment.Labels(childComplexity), true

	case "Deployment.containers":
		if e.complexity.Deployment.Containers == nil {
			break
		}

		return e.complexity.Deployment.Containers(childComplexity), true

	case "Deployment.boundServiceInstanceNames":
		if e.complexity.Deployment.BoundServiceInstanceNames == nil {
			break
		}

		return e.complexity.Deployment.BoundServiceInstanceNames(childComplexity), true

	case "DeploymentCondition.status":
		if e.complexity.DeploymentCondition.Status == nil {
			break
		}

		return e.complexity.DeploymentCondition.Status(childComplexity), true

	case "DeploymentCondition.type":
		if e.complexity.DeploymentCondition.Type == nil {
			break
		}

		return e.complexity.DeploymentCondition.Type(childComplexity), true

	case "DeploymentCondition.lastTransitionTimestamp":
		if e.complexity.DeploymentCondition.LastTransitionTimestamp == nil {
			break
		}

		return e.complexity.DeploymentCondition.LastTransitionTimestamp(childComplexity), true

	case "DeploymentCondition.lastUpdateTimestamp":
		if e.complexity.DeploymentCondition.LastUpdateTimestamp == nil {
			break
		}

		return e.complexity.DeploymentCondition.LastUpdateTimestamp(childComplexity), true

	case "DeploymentCondition.message":
		if e.complexity.DeploymentCondition.Message == nil {
			break
		}

		return e.complexity.DeploymentCondition.Message(childComplexity), true

	case "DeploymentCondition.reason":
		if e.complexity.DeploymentCondition.Reason == nil {
			break
		}

		return e.complexity.DeploymentCondition.Reason(childComplexity), true

	case "DeploymentStatus.replicas":
		if e.complexity.DeploymentStatus.Replicas == nil {
			break
		}

		return e.complexity.DeploymentStatus.Replicas(childComplexity), true

	case "DeploymentStatus.updatedReplicas":
		if e.complexity.DeploymentStatus.UpdatedReplicas == nil {
			break
		}

		return e.complexity.DeploymentStatus.UpdatedReplicas(childComplexity), true

	case "DeploymentStatus.readyReplicas":
		if e.complexity.DeploymentStatus.ReadyReplicas == nil {
			break
		}

		return e.complexity.DeploymentStatus.ReadyReplicas(childComplexity), true

	case "DeploymentStatus.availableReplicas":
		if e.complexity.DeploymentStatus.AvailableReplicas == nil {
			break
		}

		return e.complexity.DeploymentStatus.AvailableReplicas(childComplexity), true

	case "DeploymentStatus.conditions":
		if e.complexity.DeploymentStatus.Conditions == nil {
			break
		}

		return e.complexity.DeploymentStatus.Conditions(childComplexity), true

	case "EnabledApplicationService.id":
		if e.complexity.EnabledApplicationService.Id == nil {
			break
		}

		return e.complexity.EnabledApplicationService.Id(childComplexity), true

	case "EnabledApplicationService.displayName":
		if e.complexity.EnabledApplicationService.DisplayName == nil {
			break
		}

		return e.complexity.EnabledApplicationService.DisplayName(childComplexity), true

	case "EnabledApplicationService.exist":
		if e.complexity.EnabledApplicationService.Exist == nil {
			break
		}

		return e.complexity.EnabledApplicationService.Exist(childComplexity), true

	case "EnvPrefix.name":
		if e.complexity.EnvPrefix.Name == nil {
			break
		}

		return e.complexity.EnvPrefix.Name(childComplexity), true

	case "EventActivation.name":
		if e.complexity.EventActivation.Name == nil {
			break
		}

		return e.complexity.EventActivation.Name(childComplexity), true

	case "EventActivation.displayName":
		if e.complexity.EventActivation.DisplayName == nil {
			break
		}

		return e.complexity.EventActivation.DisplayName(childComplexity), true

	case "EventActivation.sourceId":
		if e.complexity.EventActivation.SourceId == nil {
			break
		}

		return e.complexity.EventActivation.SourceId(childComplexity), true

	case "EventActivation.events":
		if e.complexity.EventActivation.Events == nil {
			break
		}

		return e.complexity.EventActivation.Events(childComplexity), true

	case "EventActivationEvent.eventType":
		if e.complexity.EventActivationEvent.EventType == nil {
			break
		}

		return e.complexity.EventActivationEvent.EventType(childComplexity), true

	case "EventActivationEvent.version":
		if e.complexity.EventActivationEvent.Version == nil {
			break
		}

		return e.complexity.EventActivationEvent.Version(childComplexity), true

	case "EventActivationEvent.description":
		if e.complexity.EventActivationEvent.Description == nil {
			break
		}

		return e.complexity.EventActivationEvent.Description(childComplexity), true

	case "EventActivationEvent.schema":
		if e.complexity.EventActivationEvent.Schema == nil {
			break
		}

		return e.complexity.EventActivationEvent.Schema(childComplexity), true

	case "ExceededQuota.quotaName":
		if e.complexity.ExceededQuota.QuotaName == nil {
			break
		}

		return e.complexity.ExceededQuota.QuotaName(childComplexity), true

	case "ExceededQuota.resourceName":
		if e.complexity.ExceededQuota.ResourceName == nil {
			break
		}

		return e.complexity.ExceededQuota.ResourceName(childComplexity), true

	case "ExceededQuota.affectedResources":
		if e.complexity.ExceededQuota.AffectedResources == nil {
			break
		}

		return e.complexity.ExceededQuota.AffectedResources(childComplexity), true

	case "File.url":
		if e.complexity.File.Url == nil {
			break
		}

		return e.complexity.File.Url(childComplexity), true

	case "File.metadata":
		if e.complexity.File.Metadata == nil {
			break
		}

		return e.complexity.File.Metadata(childComplexity), true

	case "Function.name":
		if e.complexity.Function.Name == nil {
			break
		}

		return e.complexity.Function.Name(childComplexity), true

	case "Function.namespace":
		if e.complexity.Function.Namespace == nil {
			break
		}

		return e.complexity.Function.Namespace(childComplexity), true

	case "Function.UID":
		if e.complexity.Function.Uid == nil {
			break
		}

		return e.complexity.Function.Uid(childComplexity), true

	case "Function.labels":
		if e.complexity.Function.Labels == nil {
			break
		}

		return e.complexity.Function.Labels(childComplexity), true

	case "Function.source":
		if e.complexity.Function.Source == nil {
			break
		}

		return e.complexity.Function.Source(childComplexity), true

	case "Function.dependencies":
		if e.complexity.Function.Dependencies == nil {
			break
		}

		return e.complexity.Function.Dependencies(childComplexity), true

	case "Function.env":
		if e.complexity.Function.Env == nil {
			break
		}

		return e.complexity.Function.Env(childComplexity), true

	case "Function.replicas":
		if e.complexity.Function.Replicas == nil {
			break
		}

		return e.complexity.Function.Replicas(childComplexity), true

	case "Function.resources":
		if e.complexity.Function.Resources == nil {
			break
		}

		return e.complexity.Function.Resources(childComplexity), true

	case "Function.status":
		if e.complexity.Function.Status == nil {
			break
		}

		return e.complexity.Function.Status(childComplexity), true

	case "FunctionEnv.name":
		if e.complexity.FunctionEnv.Name == nil {
			break
		}

		return e.complexity.FunctionEnv.Name(childComplexity), true

	case "FunctionEnv.value":
		if e.complexity.FunctionEnv.Value == nil {
			break
		}

		return e.complexity.FunctionEnv.Value(childComplexity), true

	case "FunctionEnv.valueFrom":
		if e.complexity.FunctionEnv.ValueFrom == nil {
			break
		}

		return e.complexity.FunctionEnv.ValueFrom(childComplexity), true

	case "FunctionEnvValueFrom.type":
		if e.complexity.FunctionEnvValueFrom.Type == nil {
			break
		}

		return e.complexity.FunctionEnvValueFrom.Type(childComplexity), true

	case "FunctionEnvValueFrom.name":
		if e.complexity.FunctionEnvValueFrom.Name == nil {
			break
		}

		return e.complexity.FunctionEnvValueFrom.Name(childComplexity), true

	case "FunctionEnvValueFrom.key":
		if e.complexity.FunctionEnvValueFrom.Key == nil {
			break
		}

		return e.complexity.FunctionEnvValueFrom.Key(childComplexity), true

	case "FunctionEnvValueFrom.optional":
		if e.complexity.FunctionEnvValueFrom.Optional == nil {
			break
		}

		return e.complexity.FunctionEnvValueFrom.Optional(childComplexity), true

	case "FunctionEvent.type":
		if e.complexity.FunctionEvent.Type == nil {
			break
		}

		return e.complexity.FunctionEvent.Type(childComplexity), true

	case "FunctionEvent.function":
		if e.complexity.FunctionEvent.Function == nil {
			break
		}

		return e.complexity.FunctionEvent.Function(childComplexity), true

	case "FunctionMetadata.name":
		if e.complexity.FunctionMetadata.Name == nil {
			break
		}

		return e.complexity.FunctionMetadata.Name(childComplexity), true

	case "FunctionMetadata.namespace":
		if e.complexity.FunctionMetadata.Namespace == nil {
			break
		}

		return e.complexity.FunctionMetadata.Namespace(childComplexity), true

	case "FunctionReplicas.min":
		if e.complexity.FunctionReplicas.Min == nil {
			break
		}

		return e.complexity.FunctionReplicas.Min(childComplexity), true

	case "FunctionReplicas.max":
		if e.complexity.FunctionReplicas.Max == nil {
			break
		}

		return e.complexity.FunctionReplicas.Max(childComplexity), true

	case "FunctionResources.limits":
		if e.complexity.FunctionResources.Limits == nil {
			break
		}

		return e.complexity.FunctionResources.Limits(childComplexity), true

	case "FunctionResources.requests":
		if e.complexity.FunctionResources.Requests == nil {
			break
		}

		return e.complexity.FunctionResources.Requests(childComplexity), true

	case "FunctionStatus.phase":
		if e.complexity.FunctionStatus.Phase == nil {
			break
		}

		return e.complexity.FunctionStatus.Phase(childComplexity), true

	case "FunctionStatus.reason":
		if e.complexity.FunctionStatus.Reason == nil {
			break
		}

		return e.complexity.FunctionStatus.Reason(childComplexity), true

	case "FunctionStatus.message":
		if e.complexity.FunctionStatus.Message == nil {
			break
		}

		return e.complexity.FunctionStatus.Message(childComplexity), true

	case "IDPPreset.name":
		if e.complexity.Idppreset.Name == nil {
			break
		}

		return e.complexity.Idppreset.Name(childComplexity), true

	case "IDPPreset.issuer":
		if e.complexity.Idppreset.Issuer == nil {
			break
		}

		return e.complexity.Idppreset.Issuer(childComplexity), true

	case "IDPPreset.jwksUri":
		if e.complexity.Idppreset.JwksUri == nil {
			break
		}

		return e.complexity.Idppreset.JwksUri(childComplexity), true

	case "LimitRange.name":
		if e.complexity.LimitRange.Name == nil {
			break
		}

		return e.complexity.LimitRange.Name(childComplexity), true

	case "LimitRange.limits":
		if e.complexity.LimitRange.Limits == nil {
			break
		}

		return e.complexity.LimitRange.Limits(childComplexity), true

	case "LimitRangeItem.limitType":
		if e.complexity.LimitRangeItem.LimitType == nil {
			break
		}

		return e.complexity.LimitRangeItem.LimitType(childComplexity), true

	case "LimitRangeItem.max":
		if e.complexity.LimitRangeItem.Max == nil {
			break
		}

		return e.complexity.LimitRangeItem.Max(childComplexity), true

	case "LimitRangeItem.default":
		if e.complexity.LimitRangeItem.Default == nil {
			break
		}

		return e.complexity.LimitRangeItem.Default(childComplexity), true

	case "LimitRangeItem.defaultRequest":
		if e.complexity.LimitRangeItem.DefaultRequest == nil {
			break
		}

		return e.complexity.LimitRangeItem.DefaultRequest(childComplexity), true

	case "LoadBalancerIngress.ip":
		if e.complexity.LoadBalancerIngress.Ip == nil {
			break
		}

		return e.complexity.LoadBalancerIngress.Ip(childComplexity), true

	case "LoadBalancerIngress.hostName":
		if e.complexity.LoadBalancerIngress.HostName == nil {
			break
		}

		return e.complexity.LoadBalancerIngress.HostName(childComplexity), true

	case "LoadBalancerStatus.ingress":
		if e.complexity.LoadBalancerStatus.Ingress == nil {
			break
		}

		return e.complexity.LoadBalancerStatus.Ingress(childComplexity), true

	case "LocalObjectReference.kind":
		if e.complexity.LocalObjectReference.Kind == nil {
			break
		}

		return e.complexity.LocalObjectReference.Kind(childComplexity), true

	case "LocalObjectReference.name":
		if e.complexity.LocalObjectReference.Name == nil {
			break
		}

		return e.complexity.LocalObjectReference.Name(childComplexity), true

	case "MicroFrontend.name":
		if e.complexity.MicroFrontend.Name == nil {
			break
		}

		return e.complexity.MicroFrontend.Name(childComplexity), true

	case "MicroFrontend.version":
		if e.complexity.MicroFrontend.Version == nil {
			break
		}

		return e.complexity.MicroFrontend.Version(childComplexity), true

	case "MicroFrontend.category":
		if e.complexity.MicroFrontend.Category == nil {
			break
		}

		return e.complexity.MicroFrontend.Category(childComplexity), true

	case "MicroFrontend.viewBaseUrl":
		if e.complexity.MicroFrontend.ViewBaseUrl == nil {
			break
		}

		return e.complexity.MicroFrontend.ViewBaseUrl(childComplexity), true

	case "MicroFrontend.navigationNodes":
		if e.complexity.MicroFrontend.NavigationNodes == nil {
			break
		}

		return e.complexity.MicroFrontend.NavigationNodes(childComplexity), true

	case "Mutation.createResource":
		if e.complexity.Mutation.CreateResource == nil {
			break
		}

		args, err := field_Mutation_createResource_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateResource(childComplexity, args["namespace"].(string), args["resource"].(JSON)), true

	case "Mutation.createServiceInstance":
		if e.complexity.Mutation.CreateServiceInstance == nil {
			break
		}

		args, err := field_Mutation_createServiceInstance_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateServiceInstance(childComplexity, args["namespace"].(string), args["params"].(ServiceInstanceCreateInput)), true

	case "Mutation.deleteServiceInstance":
		if e.complexity.Mutation.DeleteServiceInstance == nil {
			break
		}

		args, err := field_Mutation_deleteServiceInstance_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteServiceInstance(childComplexity, args["name"].(string), args["namespace"].(string)), true

	case "Mutation.createServiceBinding":
		if e.complexity.Mutation.CreateServiceBinding == nil {
			break
		}

		args, err := field_Mutation_createServiceBinding_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateServiceBinding(childComplexity, args["serviceBindingName"].(*string), args["serviceInstanceName"].(string), args["namespace"].(string), args["parameters"].(*JSON)), true

	case "Mutation.deleteServiceBinding":
		if e.complexity.Mutation.DeleteServiceBinding == nil {
			break
		}

		args, err := field_Mutation_deleteServiceBinding_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteServiceBinding(childComplexity, args["serviceBindingName"].(string), args["namespace"].(string)), true

	case "Mutation.createServiceBindingUsage":
		if e.complexity.Mutation.CreateServiceBindingUsage == nil {
			break
		}

		args, err := field_Mutation_createServiceBindingUsage_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateServiceBindingUsage(childComplexity, args["namespace"].(string), args["createServiceBindingUsageInput"].(*CreateServiceBindingUsageInput)), true

	case "Mutation.deleteServiceBindingUsage":
		if e.complexity.Mutation.DeleteServiceBindingUsage == nil {
			break
		}

		args, err := field_Mutation_deleteServiceBindingUsage_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteServiceBindingUsage(childComplexity, args["serviceBindingUsageName"].(string), args["namespace"].(string)), true

	case "Mutation.deleteServiceBindingUsages":
		if e.complexity.Mutation.DeleteServiceBindingUsages == nil {
			break
		}

		args, err := field_Mutation_deleteServiceBindingUsages_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteServiceBindingUsages(childComplexity, args["serviceBindingUsageNames"].([]string), args["namespace"].(string)), true

	case "Mutation.createClusterAddonsConfiguration":
		if e.complexity.Mutation.CreateClusterAddonsConfiguration == nil {
			break
		}

		args, err := field_Mutation_createClusterAddonsConfiguration_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateClusterAddonsConfiguration(childComplexity, args["name"].(string), args["repositories"].([]AddonsConfigurationRepositoryInput), args["urls"].([]string), args["labels"].(*Labels)), true

	case "Mutation.updateClusterAddonsConfiguration":
		if e.complexity.Mutation.UpdateClusterAddonsConfiguration == nil {
			break
		}

		args, err := field_Mutation_updateClusterAddonsConfiguration_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateClusterAddonsConfiguration(childComplexity, args["name"].(string), args["repositories"].([]AddonsConfigurationRepositoryInput), args["urls"].([]string), args["labels"].(*Labels)), true

	case "Mutation.deleteClusterAddonsConfiguration":
		if e.complexity.Mutation.DeleteClusterAddonsConfiguration == nil {
			break
		}

		args, err := field_Mutation_deleteClusterAddonsConfiguration_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteClusterAddonsConfiguration(childComplexity, args["name"].(string)), true

	case "Mutation.addClusterAddonsConfigurationURLs":
		if e.complexity.Mutation.AddClusterAddonsConfigurationUrls == nil {
			break
		}

		args, err := field_Mutation_addClusterAddonsConfigurationURLs_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddClusterAddonsConfigurationUrls(childComplexity, args["name"].(string), args["urls"].([]string)), true

	case "Mutation.removeClusterAddonsConfigurationURLs":
		if e.complexity.Mutation.RemoveClusterAddonsConfigurationUrls == nil {
			break
		}

		args, err := field_Mutation_removeClusterAddonsConfigurationURLs_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemoveClusterAddonsConfigurationUrls(childComplexity, args["name"].(string), args["urls"].([]string)), true

	case "Mutation.addClusterAddonsConfigurationRepository":
		if e.complexity.Mutation.AddClusterAddonsConfigurationRepository == nil {
			break
		}

		args, err := field_Mutation_addClusterAddonsConfigurationRepository_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddClusterAddonsConfigurationRepository(childComplexity, args["name"].(string), args["repositories"].([]AddonsConfigurationRepositoryInput)), true

	case "Mutation.removeClusterAddonsConfigurationRepository":
		if e.complexity.Mutation.RemoveClusterAddonsConfigurationRepository == nil {
			break
		}

		args, err := field_Mutation_removeClusterAddonsConfigurationRepository_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemoveClusterAddonsConfigurationRepository(childComplexity, args["name"].(string), args["urls"].([]string)), true

	case "Mutation.resyncClusterAddonsConfiguration":
		if e.complexity.Mutation.ResyncClusterAddonsConfiguration == nil {
			break
		}

		args, err := field_Mutation_resyncClusterAddonsConfiguration_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ResyncClusterAddonsConfiguration(childComplexity, args["name"].(string)), true

	case "Mutation.createAddonsConfiguration":
		if e.complexity.Mutation.CreateAddonsConfiguration == nil {
			break
		}

		args, err := field_Mutation_createAddonsConfiguration_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateAddonsConfiguration(childComplexity, args["name"].(string), args["namespace"].(string), args["repositories"].([]AddonsConfigurationRepositoryInput), args["urls"].([]string), args["labels"].(*Labels)), true

	case "Mutation.updateAddonsConfiguration":
		if e.complexity.Mutation.UpdateAddonsConfiguration == nil {
			break
		}

		args, err := field_Mutation_updateAddonsConfiguration_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateAddonsConfiguration(childComplexity, args["name"].(string), args["namespace"].(string), args["repositories"].([]AddonsConfigurationRepositoryInput), args["urls"].([]string), args["labels"].(*Labels)), true

	case "Mutation.deleteAddonsConfiguration":
		if e.complexity.Mutation.DeleteAddonsConfiguration == nil {
			break
		}

		args, err := field_Mutation_deleteAddonsConfiguration_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteAddonsConfiguration(childComplexity, args["name"].(string), args["namespace"].(string)), true

	case "Mutation.addAddonsConfigurationURLs":
		if e.complexity.Mutation.AddAddonsConfigurationUrls == nil {
			break
		}

		args, err := field_Mutation_addAddonsConfigurationURLs_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddAddonsConfigurationUrls(childComplexity, args["name"].(string), args["namespace"].(string), args["urls"].([]string)), true

	case "Mutation.removeAddonsConfigurationURLs":
		if e.complexity.Mutation.RemoveAddonsConfigurationUrls == nil {
			break
		}

		args, err := field_Mutation_removeAddonsConfigurationURLs_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemoveAddonsConfigurationUrls(childComplexity, args["name"].(string), args["namespace"].(string), args["urls"].([]string)), true

	case "Mutation.addAddonsConfigurationRepository":
		if e.complexity.Mutation.AddAddonsConfigurationRepository == nil {
			break
		}

		args, err := field_Mutation_addAddonsConfigurationRepository_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddAddonsConfigurationRepository(childComplexity, args["name"].(string), args["namespace"].(string), args["repositories"].([]AddonsConfigurationRepositoryInput)), true

	case "Mutation.removeAddonsConfigurationRepository":
		if e.complexity.Mutation.RemoveAddonsConfigurationRepository == nil {
			break
		}

		args, err := field_Mutation_removeAddonsConfigurationRepository_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemoveAddonsConfigurationRepository(childComplexity, args["name"].(string), args["namespace"].(string), args["urls"].([]string)), true

	case "Mutation.resyncAddonsConfiguration":
		if e.complexity.Mutation.ResyncAddonsConfiguration == nil {
			break
		}

		args, err := field_Mutation_resyncAddonsConfiguration_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ResyncAddonsConfiguration(childComplexity, args["name"].(string), args["namespace"].(string)), true

	case "Mutation.createApplication":
		if e.complexity.Mutation.CreateApplication == nil {
			break
		}

		args, err := field_Mutation_createApplication_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateApplication(childComplexity, args["name"].(string), args["description"].(*string), args["labels"].(*Labels)), true

	case "Mutation.updateApplication":
		if e.complexity.Mutation.UpdateApplication == nil {
			break
		}

		args, err := field_Mutation_updateApplication_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateApplication(childComplexity, args["name"].(string), args["description"].(*string), args["labels"].(*Labels)), true

	case "Mutation.deleteApplication":
		if e.complexity.Mutation.DeleteApplication == nil {
			break
		}

		args, err := field_Mutation_deleteApplication_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteApplication(childComplexity, args["name"].(string)), true

	case "Mutation.enableApplication":
		if e.complexity.Mutation.EnableApplication == nil {
			break
		}

		args, err := field_Mutation_enableApplication_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.EnableApplication(childComplexity, args["application"].(string), args["namespace"].(string), args["allServices"].(*bool), args["services"].([]*ApplicationMappingService)), true

	case "Mutation.overloadApplication":
		if e.complexity.Mutation.OverloadApplication == nil {
			break
		}

		args, err := field_Mutation_overloadApplication_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.OverloadApplication(childComplexity, args["application"].(string), args["namespace"].(string), args["allServices"].(*bool), args["services"].([]*ApplicationMappingService)), true

	case "Mutation.disableApplication":
		if e.complexity.Mutation.DisableApplication == nil {
			break
		}

		args, err := field_Mutation_disableApplication_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DisableApplication(childComplexity, args["application"].(string), args["namespace"].(string)), true

	case "Mutation.updatePod":
		if e.complexity.Mutation.UpdatePod == nil {
			break
		}

		args, err := field_Mutation_updatePod_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdatePod(childComplexity, args["name"].(string), args["namespace"].(string), args["pod"].(JSON)), true

	case "Mutation.deletePod":
		if e.complexity.Mutation.DeletePod == nil {
			break
		}

		args, err := field_Mutation_deletePod_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeletePod(childComplexity, args["name"].(string), args["namespace"].(string)), true

	case "Mutation.updateSecret":
		if e.complexity.Mutation.UpdateSecret == nil {
			break
		}

		args, err := field_Mutation_updateSecret_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateSecret(childComplexity, args["name"].(string), args["namespace"].(string), args["secret"].(JSON)), true

	case "Mutation.deleteSecret":
		if e.complexity.Mutation.DeleteSecret == nil {
			break
		}

		args, err := field_Mutation_deleteSecret_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteSecret(childComplexity, args["name"].(string), args["namespace"].(string)), true

	case "Mutation.updateReplicaSet":
		if e.complexity.Mutation.UpdateReplicaSet == nil {
			break
		}

		args, err := field_Mutation_updateReplicaSet_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateReplicaSet(childComplexity, args["name"].(string), args["namespace"].(string), args["replicaSet"].(JSON)), true

	case "Mutation.deleteReplicaSet":
		if e.complexity.Mutation.DeleteReplicaSet == nil {
			break
		}

		args, err := field_Mutation_deleteReplicaSet_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteReplicaSet(childComplexity, args["name"].(string), args["namespace"].(string)), true

	case "Mutation.createResourceQuota":
		if e.complexity.Mutation.CreateResourceQuota == nil {
			break
		}

		args, err := field_Mutation_createResourceQuota_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateResourceQuota(childComplexity, args["namespace"].(string), args["name"].(string), args["resourceQuota"].(ResourceQuotaInput)), true

	case "Mutation.updateConfigMap":
		if e.complexity.Mutation.UpdateConfigMap == nil {
			break
		}

		args, err := field_Mutation_updateConfigMap_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateConfigMap(childComplexity, args["name"].(string), args["namespace"].(string), args["configMap"].(JSON)), true

	case "Mutation.deleteConfigMap":
		if e.complexity.Mutation.DeleteConfigMap == nil {
			break
		}

		args, err := field_Mutation_deleteConfigMap_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteConfigMap(childComplexity, args["name"].(string), args["namespace"].(string)), true

	case "Mutation.createIDPPreset":
		if e.complexity.Mutation.CreateIdppreset == nil {
			break
		}

		args, err := field_Mutation_createIDPPreset_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateIdppreset(childComplexity, args["name"].(string), args["issuer"].(string), args["jwksUri"].(string)), true

	case "Mutation.deleteIDPPreset":
		if e.complexity.Mutation.DeleteIdppreset == nil {
			break
		}

		args, err := field_Mutation_deleteIDPPreset_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteIdppreset(childComplexity, args["name"].(string)), true

	case "Mutation.updateService":
		if e.complexity.Mutation.UpdateService == nil {
			break
		}

		args, err := field_Mutation_updateService_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateService(childComplexity, args["name"].(string), args["namespace"].(string), args["service"].(JSON)), true

	case "Mutation.deleteService":
		if e.complexity.Mutation.DeleteService == nil {
			break
		}

		args, err := field_Mutation_deleteService_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteService(childComplexity, args["name"].(string), args["namespace"].(string)), true

	case "Mutation.createNamespace":
		if e.complexity.Mutation.CreateNamespace == nil {
			break
		}

		args, err := field_Mutation_createNamespace_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateNamespace(childComplexity, args["name"].(string), args["labels"].(*Labels)), true

	case "Mutation.updateNamespace":
		if e.complexity.Mutation.UpdateNamespace == nil {
			break
		}

		args, err := field_Mutation_updateNamespace_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateNamespace(childComplexity, args["name"].(string), args["labels"].(Labels)), true

	case "Mutation.deleteNamespace":
		if e.complexity.Mutation.DeleteNamespace == nil {
			break
		}

		args, err := field_Mutation_deleteNamespace_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteNamespace(childComplexity, args["name"].(string)), true

	case "Mutation.createAPIRule":
		if e.complexity.Mutation.CreateApirule == nil {
			break
		}

		args, err := field_Mutation_createAPIRule_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateApirule(childComplexity, args["name"].(string), args["namespace"].(string), args["params"].(APIRuleInput)), true

	case "Mutation.updateAPIRule":
		if e.complexity.Mutation.UpdateApirule == nil {
			break
		}

		args, err := field_Mutation_updateAPIRule_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateApirule(childComplexity, args["name"].(string), args["namespace"].(string), args["params"].(APIRuleInput)), true

	case "Mutation.deleteAPIRule":
		if e.complexity.Mutation.DeleteApirule == nil {
			break
		}

		args, err := field_Mutation_deleteAPIRule_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteApirule(childComplexity, args["name"].(string), args["namespace"].(string)), true

	case "Mutation.createLimitRange":
		if e.complexity.Mutation.CreateLimitRange == nil {
			break
		}

		args, err := field_Mutation_createLimitRange_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateLimitRange(childComplexity, args["namespace"].(string), args["name"].(string), args["limitRange"].(LimitRangeInput)), true

	case "Mutation.createFunction":
		if e.complexity.Mutation.CreateFunction == nil {
			break
		}

		args, err := field_Mutation_createFunction_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateFunction(childComplexity, args["name"].(string), args["namespace"].(string), args["params"].(FunctionMutationInput)), true

	case "Mutation.updateFunction":
		if e.complexity.Mutation.UpdateFunction == nil {
			break
		}

		args, err := field_Mutation_updateFunction_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateFunction(childComplexity, args["name"].(string), args["namespace"].(string), args["params"].(FunctionMutationInput)), true

	case "Mutation.deleteFunction":
		if e.complexity.Mutation.DeleteFunction == nil {
			break
		}

		args, err := field_Mutation_deleteFunction_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteFunction(childComplexity, args["function"].(FunctionMetadataInput)), true

	case "Mutation.deleteManyFunctions":
		if e.complexity.Mutation.DeleteManyFunctions == nil {
			break
		}

		args, err := field_Mutation_deleteManyFunctions_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteManyFunctions(childComplexity, args["functions"].([]FunctionMetadataInput)), true

	case "Mutation.createTrigger":
		if e.complexity.Mutation.CreateTrigger == nil {
			break
		}

		args, err := field_Mutation_createTrigger_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateTrigger(childComplexity, args["trigger"].(TriggerCreateInput), args["ownerRef"].([]OwnerReference)), true

	case "Mutation.createManyTriggers":
		if e.complexity.Mutation.CreateManyTriggers == nil {
			break
		}

		args, err := field_Mutation_createManyTriggers_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateManyTriggers(childComplexity, args["triggers"].([]TriggerCreateInput), args["ownerRef"].([]OwnerReference)), true

	case "Mutation.deleteTrigger":
		if e.complexity.Mutation.DeleteTrigger == nil {
			break
		}

		args, err := field_Mutation_deleteTrigger_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteTrigger(childComplexity, args["trigger"].(TriggerMetadataInput)), true

	case "Mutation.deleteManyTriggers":
		if e.complexity.Mutation.DeleteManyTriggers == nil {
			break
		}

		args, err := field_Mutation_deleteManyTriggers_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteManyTriggers(childComplexity, args["triggers"].([]TriggerMetadataInput)), true

	case "Namespace.name":
		if e.complexity.Namespace.Name == nil {
			break
		}

		return e.complexity.Namespace.Name(childComplexity), true

	case "Namespace.labels":
		if e.complexity.Namespace.Labels == nil {
			break
		}

		return e.complexity.Namespace.Labels(childComplexity), true

	case "Namespace.status":
		if e.complexity.Namespace.Status == nil {
			break
		}

		return e.complexity.Namespace.Status(childComplexity), true

	case "Namespace.isSystemNamespace":
		if e.complexity.Namespace.IsSystemNamespace == nil {
			break
		}

		return e.complexity.Namespace.IsSystemNamespace(childComplexity), true

	case "Namespace.pods":
		if e.complexity.Namespace.Pods == nil {
			break
		}

		return e.complexity.Namespace.Pods(childComplexity), true

	case "Namespace.applications":
		if e.complexity.Namespace.Applications == nil {
			break
		}

		return e.complexity.Namespace.Applications(childComplexity), true

	case "NamespaceEvent.type":
		if e.complexity.NamespaceEvent.Type == nil {
			break
		}

		return e.complexity.NamespaceEvent.Type(childComplexity), true

	case "NamespaceEvent.namespace":
		if e.complexity.NamespaceEvent.Namespace == nil {
			break
		}

		return e.complexity.NamespaceEvent.Namespace(childComplexity), true

	case "NamespaceMutationOutput.name":
		if e.complexity.NamespaceMutationOutput.Name == nil {
			break
		}

		return e.complexity.NamespaceMutationOutput.Name(childComplexity), true

	case "NamespaceMutationOutput.labels":
		if e.complexity.NamespaceMutationOutput.Labels == nil {
			break
		}

		return e.complexity.NamespaceMutationOutput.Labels(childComplexity), true

	case "NavigationNode.label":
		if e.complexity.NavigationNode.Label == nil {
			break
		}

		return e.complexity.NavigationNode.Label(childComplexity), true

	case "NavigationNode.navigationPath":
		if e.complexity.NavigationNode.NavigationPath == nil {
			break
		}

		return e.complexity.NavigationNode.NavigationPath(childComplexity), true

	case "NavigationNode.viewUrl":
		if e.complexity.NavigationNode.ViewUrl == nil {
			break
		}

		return e.complexity.NavigationNode.ViewUrl(childComplexity), true

	case "NavigationNode.showInNavigation":
		if e.complexity.NavigationNode.ShowInNavigation == nil {
			break
		}

		return e.complexity.NavigationNode.ShowInNavigation(childComplexity), true

	case "NavigationNode.order":
		if e.complexity.NavigationNode.Order == nil {
			break
		}

		return e.complexity.NavigationNode.Order(childComplexity), true

	case "NavigationNode.settings":
		if e.complexity.NavigationNode.Settings == nil {
			break
		}

		return e.complexity.NavigationNode.Settings(childComplexity), true

	case "NavigationNode.externalLink":
		if e.complexity.NavigationNode.ExternalLink == nil {
			break
		}

		return e.complexity.NavigationNode.ExternalLink(childComplexity), true

	case "NavigationNode.requiredPermissions":
		if e.complexity.NavigationNode.RequiredPermissions == nil {
			break
		}

		return e.complexity.NavigationNode.RequiredPermissions(childComplexity), true

	case "Pod.name":
		if e.complexity.Pod.Name == nil {
			break
		}

		return e.complexity.Pod.Name(childComplexity), true

	case "Pod.nodeName":
		if e.complexity.Pod.NodeName == nil {
			break
		}

		return e.complexity.Pod.NodeName(childComplexity), true

	case "Pod.namespace":
		if e.complexity.Pod.Namespace == nil {
			break
		}

		return e.complexity.Pod.Namespace(childComplexity), true

	case "Pod.restartCount":
		if e.complexity.Pod.RestartCount == nil {
			break
		}

		return e.complexity.Pod.RestartCount(childComplexity), true

	case "Pod.creationTimestamp":
		if e.complexity.Pod.CreationTimestamp == nil {
			break
		}

		return e.complexity.Pod.CreationTimestamp(childComplexity), true

	case "Pod.labels":
		if e.complexity.Pod.Labels == nil {
			break
		}

		return e.complexity.Pod.Labels(childComplexity), true

	case "Pod.status":
		if e.complexity.Pod.Status == nil {
			break
		}

		return e.complexity.Pod.Status(childComplexity), true

	case "Pod.containerStates":
		if e.complexity.Pod.ContainerStates == nil {
			break
		}

		return e.complexity.Pod.ContainerStates(childComplexity), true

	case "Pod.json":
		if e.complexity.Pod.Json == nil {
			break
		}

		return e.complexity.Pod.Json(childComplexity), true

	case "PodEvent.type":
		if e.complexity.PodEvent.Type == nil {
			break
		}

		return e.complexity.PodEvent.Type(childComplexity), true

	case "PodEvent.pod":
		if e.complexity.PodEvent.Pod == nil {
			break
		}

		return e.complexity.PodEvent.Pod(childComplexity), true

	case "Query.clusterAssetGroups":
		if e.complexity.Query.ClusterAssetGroups == nil {
			break
		}

		args, err := field_Query_clusterAssetGroups_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ClusterAssetGroups(childComplexity, args["viewContext"].(*string), args["groupName"].(*string)), true

	case "Query.serviceInstance":
		if e.complexity.Query.ServiceInstance == nil {
			break
		}

		args, err := field_Query_serviceInstance_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ServiceInstance(childComplexity, args["name"].(string), args["namespace"].(string)), true

	case "Query.serviceInstances":
		if e.complexity.Query.ServiceInstances == nil {
			break
		}

		args, err := field_Query_serviceInstances_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ServiceInstances(childComplexity, args["namespace"].(string), args["first"].(*int), args["offset"].(*int), args["status"].(*InstanceStatusType)), true

	case "Query.clusterServiceClasses":
		if e.complexity.Query.ClusterServiceClasses == nil {
			break
		}

		args, err := field_Query_clusterServiceClasses_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ClusterServiceClasses(childComplexity, args["first"].(*int), args["offset"].(*int)), true

	case "Query.clusterServiceClass":
		if e.complexity.Query.ClusterServiceClass == nil {
			break
		}

		args, err := field_Query_clusterServiceClass_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ClusterServiceClass(childComplexity, args["name"].(string)), true

	case "Query.serviceClasses":
		if e.complexity.Query.ServiceClasses == nil {
			break
		}

		args, err := field_Query_serviceClasses_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ServiceClasses(childComplexity, args["namespace"].(string), args["first"].(*int), args["offset"].(*int)), true

	case "Query.serviceClass":
		if e.complexity.Query.ServiceClass == nil {
			break
		}

		args, err := field_Query_serviceClass_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ServiceClass(childComplexity, args["namespace"].(string), args["name"].(string)), true

	case "Query.clusterServiceBrokers":
		if e.complexity.Query.ClusterServiceBrokers == nil {
			break
		}

		args, err := field_Query_clusterServiceBrokers_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ClusterServiceBrokers(childComplexity, args["first"].(*int), args["offset"].(*int)), true

	case "Query.clusterServiceBroker":
		if e.complexity.Query.ClusterServiceBroker == nil {
			break
		}

		args, err := field_Query_clusterServiceBroker_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ClusterServiceBroker(childComplexity, args["name"].(string)), true

	case "Query.serviceBrokers":
		if e.complexity.Query.ServiceBrokers == nil {
			break
		}

		args, err := field_Query_serviceBrokers_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ServiceBrokers(childComplexity, args["namespace"].(string), args["first"].(*int), args["offset"].(*int)), true

	case "Query.serviceBroker":
		if e.complexity.Query.ServiceBroker == nil {
			break
		}

		args, err := field_Query_serviceBroker_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ServiceBroker(childComplexity, args["name"].(string), args["namespace"].(string)), true

	case "Query.serviceBindingUsage":
		if e.complexity.Query.ServiceBindingUsage == nil {
			break
		}

		args, err := field_Query_serviceBindingUsage_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ServiceBindingUsage(childComplexity, args["name"].(string), args["namespace"].(string)), true

	case "Query.serviceBindingUsages":
		if e.complexity.Query.ServiceBindingUsages == nil {
			break
		}

		args, err := field_Query_serviceBindingUsages_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ServiceBindingUsages(childComplexity, args["namespace"].(string), args["resourceKind"].(*string), args["resourceName"].(*string)), true

	case "Query.serviceBinding":
		if e.complexity.Query.ServiceBinding == nil {
			break
		}

		args, err := field_Query_serviceBinding_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ServiceBinding(childComplexity, args["name"].(string), args["namespace"].(string)), true

	case "Query.usageKinds":
		if e.complexity.Query.UsageKinds == nil {
			break
		}

		args, err := field_Query_usageKinds_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UsageKinds(childComplexity, args["first"].(*int), args["offset"].(*int)), true

	case "Query.clusterAddonsConfigurations":
		if e.complexity.Query.ClusterAddonsConfigurations == nil {
			break
		}

		args, err := field_Query_clusterAddonsConfigurations_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ClusterAddonsConfigurations(childComplexity, args["first"].(*int), args["offset"].(*int)), true

	case "Query.addonsConfigurations":
		if e.complexity.Query.AddonsConfigurations == nil {
			break
		}

		args, err := field_Query_addonsConfigurations_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AddonsConfigurations(childComplexity, args["namespace"].(string), args["first"].(*int), args["offset"].(*int)), true

	case "Query.bindableResources":
		if e.complexity.Query.BindableResources == nil {
			break
		}

		args, err := field_Query_bindableResources_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.BindableResources(childComplexity, args["namespace"].(string)), true

	case "Query.APIRules":
		if e.complexity.Query.Apirules == nil {
			break
		}

		args, err := field_Query_APIRules_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Apirules(childComplexity, args["namespace"].(string), args["serviceName"].(*string), args["hostname"].(*string)), true

	case "Query.APIRule":
		if e.complexity.Query.Apirule == nil {
			break
		}

		args, err := field_Query_APIRule_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Apirule(childComplexity, args["name"].(string), args["namespace"].(string)), true

	case "Query.application":
		if e.complexity.Query.Application == nil {
			break
		}

		args, err := field_Query_application_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Application(childComplexity, args["name"].(string)), true

	case "Query.applications":
		if e.complexity.Query.Applications == nil {
			break
		}

		args, err := field_Query_applications_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Applications(childComplexity, args["namespace"].(*string), args["first"].(*int), args["offset"].(*int)), true

	case "Query.connectorService":
		if e.complexity.Query.ConnectorService == nil {
			break
		}

		args, err := field_Query_connectorService_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ConnectorService(childComplexity, args["application"].(string)), true

	case "Query.namespaces":
		if e.complexity.Query.Namespaces == nil {
			break
		}

		args, err := field_Query_namespaces_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Namespaces(childComplexity, args["withSystemNamespaces"].(*bool), args["withInactiveStatus"].(*bool)), true

	case "Query.namespace":
		if e.complexity.Query.Namespace == nil {
			break
		}

		args, err := field_Query_namespace_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Namespace(childComplexity, args["name"].(string)), true

	case "Query.deployments":
		if e.complexity.Query.Deployments == nil {
			break
		}

		args, err := field_Query_deployments_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Deployments(childComplexity, args["namespace"].(string), args["excludeFunctions"].(*bool)), true

	case "Query.versionInfo":
		if e.complexity.Query.VersionInfo == nil {
			break
		}

		return e.complexity.Query.VersionInfo(childComplexity), true

	case "Query.pod":
		if e.complexity.Query.Pod == nil {
			break
		}

		args, err := field_Query_pod_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Pod(childComplexity, args["name"].(string), args["namespace"].(string)), true

	case "Query.pods":
		if e.complexity.Query.Pods == nil {
			break
		}

		args, err := field_Query_pods_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Pods(childComplexity, args["namespace"].(string), args["first"].(*int), args["offset"].(*int)), true

	case "Query.service":
		if e.complexity.Query.Service == nil {
			break
		}

		args, err := field_Query_service_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Service(childComplexity, args["name"].(string), args["namespace"].(string)), true

	case "Query.services":
		if e.complexity.Query.Services == nil {
			break
		}

		args, err := field_Query_services_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Services(childComplexity, args["namespace"].(string), args["excludedLabels"].([]string), args["first"].(*int), args["offset"].(*int)), true

	case "Query.configMap":
		if e.complexity.Query.ConfigMap == nil {
			break
		}

		args, err := field_Query_configMap_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ConfigMap(childComplexity, args["name"].(string), args["namespace"].(string)), true

	case "Query.configMaps":
		if e.complexity.Query.ConfigMaps == nil {
			break
		}

		args, err := field_Query_configMaps_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ConfigMaps(childComplexity, args["namespace"].(string), args["first"].(*int), args["offset"].(*int)), true

	case "Query.replicaSet":
		if e.complexity.Query.ReplicaSet == nil {
			break
		}

		args, err := field_Query_replicaSet_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ReplicaSet(childComplexity, args["name"].(string), args["namespace"].(string)), true

	case "Query.replicaSets":
		if e.complexity.Query.ReplicaSets == nil {
			break
		}

		args, err := field_Query_replicaSets_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ReplicaSets(childComplexity, args["namespace"].(string), args["first"].(*int), args["offset"].(*int)), true

	case "Query.resourceQuotas":
		if e.complexity.Query.ResourceQuotas == nil {
			break
		}

		args, err := field_Query_resourceQuotas_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ResourceQuotas(childComplexity, args["namespace"].(string)), true

	case "Query.resourceQuotasStatus":
		if e.complexity.Query.ResourceQuotasStatus == nil {
			break
		}

		args, err := field_Query_resourceQuotasStatus_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ResourceQuotasStatus(childComplexity, args["namespace"].(string)), true

	case "Query.eventActivations":
		if e.complexity.Query.EventActivations == nil {
			break
		}

		args, err := field_Query_eventActivations_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.EventActivations(childComplexity, args["namespace"].(string)), true

	case "Query.limitRanges":
		if e.complexity.Query.LimitRanges == nil {
			break
		}

		args, err := field_Query_limitRanges_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.LimitRanges(childComplexity, args["namespace"].(string)), true

	case "Query.backendModules":
		if e.complexity.Query.BackendModules == nil {
			break
		}

		return e.complexity.Query.BackendModules(childComplexity), true

	case "Query.secret":
		if e.complexity.Query.Secret == nil {
			break
		}

		args, err := field_Query_secret_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Secret(childComplexity, args["name"].(string), args["namespace"].(string)), true

	case "Query.secrets":
		if e.complexity.Query.Secrets == nil {
			break
		}

		args, err := field_Query_secrets_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Secrets(childComplexity, args["namespace"].(string), args["first"].(*int), args["offset"].(*int)), true

	case "Query.IDPPreset":
		if e.complexity.Query.Idppreset == nil {
			break
		}

		args, err := field_Query_IDPPreset_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Idppreset(childComplexity, args["name"].(string)), true

	case "Query.IDPPresets":
		if e.complexity.Query.Idppresets == nil {
			break
		}

		args, err := field_Query_IDPPresets_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Idppresets(childComplexity, args["first"].(*int), args["offset"].(*int)), true

	case "Query.microFrontends":
		if e.complexity.Query.MicroFrontends == nil {
			break
		}

		args, err := field_Query_microFrontends_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MicroFrontends(childComplexity, args["namespace"].(string)), true

	case "Query.clusterMicroFrontends":
		if e.complexity.Query.ClusterMicroFrontends == nil {
			break
		}

		return e.complexity.Query.ClusterMicroFrontends(childComplexity), true

	case "Query.selfSubjectRules":
		if e.complexity.Query.SelfSubjectRules == nil {
			break
		}

		args, err := field_Query_selfSubjectRules_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SelfSubjectRules(childComplexity, args["namespace"].(*string)), true

	case "Query.function":
		if e.complexity.Query.Function == nil {
			break
		}

		args, err := field_Query_function_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Function(childComplexity, args["name"].(string), args["namespace"].(string)), true

	case "Query.functions":
		if e.complexity.Query.Functions == nil {
			break
		}

		args, err := field_Query_functions_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Functions(childComplexity, args["namespace"].(string)), true

	case "Query.triggers":
		if e.complexity.Query.Triggers == nil {
			break
		}

		args, err := field_Query_triggers_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Triggers(childComplexity, args["namespace"].(string), args["subscriber"].(*SubscriberInput)), true

	case "ReplicaSet.name":
		if e.complexity.ReplicaSet.Name == nil {
			break
		}

		return e.complexity.ReplicaSet.Name(childComplexity), true

	case "ReplicaSet.pods":
		if e.complexity.ReplicaSet.Pods == nil {
			break
		}

		return e.complexity.ReplicaSet.Pods(childComplexity), true

	case "ReplicaSet.namespace":
		if e.complexity.ReplicaSet.Namespace == nil {
			break
		}

		return e.complexity.ReplicaSet.Namespace(childComplexity), true

	case "ReplicaSet.images":
		if e.complexity.ReplicaSet.Images == nil {
			break
		}

		return e.complexity.ReplicaSet.Images(childComplexity), true

	case "ReplicaSet.creationTimestamp":
		if e.complexity.ReplicaSet.CreationTimestamp == nil {
			break
		}

		return e.complexity.ReplicaSet.CreationTimestamp(childComplexity), true

	case "ReplicaSet.labels":
		if e.complexity.ReplicaSet.Labels == nil {
			break
		}

		return e.complexity.ReplicaSet.Labels(childComplexity), true

	case "ReplicaSet.json":
		if e.complexity.ReplicaSet.Json == nil {
			break
		}

		return e.complexity.ReplicaSet.Json(childComplexity), true

	case "RequiredPermission.verbs":
		if e.complexity.RequiredPermission.Verbs == nil {
			break
		}

		return e.complexity.RequiredPermission.Verbs(childComplexity), true

	case "RequiredPermission.apiGroup":
		if e.complexity.RequiredPermission.ApiGroup == nil {
			break
		}

		return e.complexity.RequiredPermission.ApiGroup(childComplexity), true

	case "RequiredPermission.resource":
		if e.complexity.RequiredPermission.Resource == nil {
			break
		}

		return e.complexity.RequiredPermission.Resource(childComplexity), true

	case "ResourceQuota.name":
		if e.complexity.ResourceQuota.Name == nil {
			break
		}

		return e.complexity.ResourceQuota.Name(childComplexity), true

	case "ResourceQuota.pods":
		if e.complexity.ResourceQuota.Pods == nil {
			break
		}

		return e.complexity.ResourceQuota.Pods(childComplexity), true

	case "ResourceQuota.limits":
		if e.complexity.ResourceQuota.Limits == nil {
			break
		}

		return e.complexity.ResourceQuota.Limits(childComplexity), true

	case "ResourceQuota.requests":
		if e.complexity.ResourceQuota.Requests == nil {
			break
		}

		return e.complexity.ResourceQuota.Requests(childComplexity), true

	case "ResourceQuotasStatus.exceeded":
		if e.complexity.ResourceQuotasStatus.Exceeded == nil {
			break
		}

		return e.complexity.ResourceQuotasStatus.Exceeded(childComplexity), true

	case "ResourceQuotasStatus.exceededQuotas":
		if e.complexity.ResourceQuotasStatus.ExceededQuotas == nil {
			break
		}

		return e.complexity.ResourceQuotasStatus.ExceededQuotas(childComplexity), true

	case "ResourceRef.name":
		if e.complexity.ResourceRef.Name == nil {
			break
		}

		return e.complexity.ResourceRef.Name(childComplexity), true

	case "ResourceRef.namespace":
		if e.complexity.ResourceRef.Namespace == nil {
			break
		}

		return e.complexity.ResourceRef.Namespace(childComplexity), true

	case "ResourceRule.verbs":
		if e.complexity.ResourceRule.Verbs == nil {
			break
		}

		return e.complexity.ResourceRule.Verbs(childComplexity), true

	case "ResourceRule.apiGroups":
		if e.complexity.ResourceRule.ApiGroups == nil {
			break
		}

		return e.complexity.ResourceRule.ApiGroups(childComplexity), true

	case "ResourceRule.resources":
		if e.complexity.ResourceRule.Resources == nil {
			break
		}

		return e.complexity.ResourceRule.Resources(childComplexity), true

	case "ResourceType.memory":
		if e.complexity.ResourceType.Memory == nil {
			break
		}

		return e.complexity.ResourceType.Memory(childComplexity), true

	case "ResourceType.cpu":
		if e.complexity.ResourceType.Cpu == nil {
			break
		}

		return e.complexity.ResourceType.Cpu(childComplexity), true

	case "ResourceValues.memory":
		if e.complexity.ResourceValues.Memory == nil {
			break
		}

		return e.complexity.ResourceValues.Memory(childComplexity), true

	case "ResourceValues.cpu":
		if e.complexity.ResourceValues.Cpu == nil {
			break
		}

		return e.complexity.ResourceValues.Cpu(childComplexity), true

	case "Rule.path":
		if e.complexity.Rule.Path == nil {
			break
		}

		return e.complexity.Rule.Path(childComplexity), true

	case "Rule.methods":
		if e.complexity.Rule.Methods == nil {
			break
		}

		return e.complexity.Rule.Methods(childComplexity), true

	case "Rule.accessStrategies":
		if e.complexity.Rule.AccessStrategies == nil {
			break
		}

		return e.complexity.Rule.AccessStrategies(childComplexity), true

	case "Rule.mutators":
		if e.complexity.Rule.Mutators == nil {
			break
		}

		return e.complexity.Rule.Mutators(childComplexity), true

	case "Secret.name":
		if e.complexity.Secret.Name == nil {
			break
		}

		return e.complexity.Secret.Name(childComplexity), true

	case "Secret.namespace":
		if e.complexity.Secret.Namespace == nil {
			break
		}

		return e.complexity.Secret.Namespace(childComplexity), true

	case "Secret.data":
		if e.complexity.Secret.Data == nil {
			break
		}

		return e.complexity.Secret.Data(childComplexity), true

	case "Secret.type":
		if e.complexity.Secret.Type == nil {
			break
		}

		return e.complexity.Secret.Type(childComplexity), true

	case "Secret.creationTime":
		if e.complexity.Secret.CreationTime == nil {
			break
		}

		return e.complexity.Secret.CreationTime(childComplexity), true

	case "Secret.labels":
		if e.complexity.Secret.Labels == nil {
			break
		}

		return e.complexity.Secret.Labels(childComplexity), true

	case "Secret.annotations":
		if e.complexity.Secret.Annotations == nil {
			break
		}

		return e.complexity.Secret.Annotations(childComplexity), true

	case "Secret.json":
		if e.complexity.Secret.Json == nil {
			break
		}

		return e.complexity.Secret.Json(childComplexity), true

	case "SecretEvent.type":
		if e.complexity.SecretEvent.Type == nil {
			break
		}

		return e.complexity.SecretEvent.Type(childComplexity), true

	case "SecretEvent.secret":
		if e.complexity.SecretEvent.Secret == nil {
			break
		}

		return e.complexity.SecretEvent.Secret(childComplexity), true

	case "Service.name":
		if e.complexity.Service.Name == nil {
			break
		}

		return e.complexity.Service.Name(childComplexity), true

	case "Service.clusterIP":
		if e.complexity.Service.ClusterIp == nil {
			break
		}

		return e.complexity.Service.ClusterIp(childComplexity), true

	case "Service.creationTimestamp":
		if e.complexity.Service.CreationTimestamp == nil {
			break
		}

		return e.complexity.Service.CreationTimestamp(childComplexity), true

	case "Service.labels":
		if e.complexity.Service.Labels == nil {
			break
		}

		return e.complexity.Service.Labels(childComplexity), true

	case "Service.ports":
		if e.complexity.Service.Ports == nil {
			break
		}

		return e.complexity.Service.Ports(childComplexity), true

	case "Service.status":
		if e.complexity.Service.Status == nil {
			break
		}

		return e.complexity.Service.Status(childComplexity), true

	case "Service.json":
		if e.complexity.Service.Json == nil {
			break
		}

		return e.complexity.Service.Json(childComplexity), true

	case "ServiceBinding.name":
		if e.complexity.ServiceBinding.Name == nil {
			break
		}

		return e.complexity.ServiceBinding.Name(childComplexity), true

	case "ServiceBinding.serviceInstanceName":
		if e.complexity.ServiceBinding.ServiceInstanceName == nil {
			break
		}

		return e.complexity.ServiceBinding.ServiceInstanceName(childComplexity), true

	case "ServiceBinding.namespace":
		if e.complexity.ServiceBinding.Namespace == nil {
			break
		}

		return e.complexity.ServiceBinding.Namespace(childComplexity), true

	case "ServiceBinding.secret":
		if e.complexity.ServiceBinding.Secret == nil {
			break
		}

		return e.complexity.ServiceBinding.Secret(childComplexity), true

	case "ServiceBinding.status":
		if e.complexity.ServiceBinding.Status == nil {
			break
		}

		return e.complexity.ServiceBinding.Status(childComplexity), true

	case "ServiceBinding.parameters":
		if e.complexity.ServiceBinding.Parameters == nil {
			break
		}

		return e.complexity.ServiceBinding.Parameters(childComplexity), true

	case "ServiceBindingEvent.type":
		if e.complexity.ServiceBindingEvent.Type == nil {
			break
		}

		return e.complexity.ServiceBindingEvent.Type(childComplexity), true

	case "ServiceBindingEvent.serviceBinding":
		if e.complexity.ServiceBindingEvent.ServiceBinding == nil {
			break
		}

		return e.complexity.ServiceBindingEvent.ServiceBinding(childComplexity), true

	case "ServiceBindingStatus.type":
		if e.complexity.ServiceBindingStatus.Type == nil {
			break
		}

		return e.complexity.ServiceBindingStatus.Type(childComplexity), true

	case "ServiceBindingStatus.reason":
		if e.complexity.ServiceBindingStatus.Reason == nil {
			break
		}

		return e.complexity.ServiceBindingStatus.Reason(childComplexity), true

	case "ServiceBindingStatus.message":
		if e.complexity.ServiceBindingStatus.Message == nil {
			break
		}

		return e.complexity.ServiceBindingStatus.Message(childComplexity), true

	case "ServiceBindingUsage.name":
		if e.complexity.ServiceBindingUsage.Name == nil {
			break
		}

		return e.complexity.ServiceBindingUsage.Name(childComplexity), true

	case "ServiceBindingUsage.namespace":
		if e.complexity.ServiceBindingUsage.Namespace == nil {
			break
		}

		return e.complexity.ServiceBindingUsage.Namespace(childComplexity), true

	case "ServiceBindingUsage.serviceBinding":
		if e.complexity.ServiceBindingUsage.ServiceBinding == nil {
			break
		}

		return e.complexity.ServiceBindingUsage.ServiceBinding(childComplexity), true

	case "ServiceBindingUsage.usedBy":
		if e.complexity.ServiceBindingUsage.UsedBy == nil {
			break
		}

		return e.complexity.ServiceBindingUsage.UsedBy(childComplexity), true

	case "ServiceBindingUsage.parameters":
		if e.complexity.ServiceBindingUsage.Parameters == nil {
			break
		}

		return e.complexity.ServiceBindingUsage.Parameters(childComplexity), true

	case "ServiceBindingUsage.status":
		if e.complexity.ServiceBindingUsage.Status == nil {
			break
		}

		return e.complexity.ServiceBindingUsage.Status(childComplexity), true

	case "ServiceBindingUsageEvent.type":
		if e.complexity.ServiceBindingUsageEvent.Type == nil {
			break
		}

		return e.complexity.ServiceBindingUsageEvent.Type(childComplexity), true

	case "ServiceBindingUsageEvent.serviceBindingUsage":
		if e.complexity.ServiceBindingUsageEvent.ServiceBindingUsage == nil {
			break
		}

		return e.complexity.ServiceBindingUsageEvent.ServiceBindingUsage(childComplexity), true

	case "ServiceBindingUsageParameters.envPrefix":
		if e.complexity.ServiceBindingUsageParameters.EnvPrefix == nil {
			break
		}

		return e.complexity.ServiceBindingUsageParameters.EnvPrefix(childComplexity), true

	case "ServiceBindingUsageStatus.type":
		if e.complexity.ServiceBindingUsageStatus.Type == nil {
			break
		}

		return e.complexity.ServiceBindingUsageStatus.Type(childComplexity), true

	case "ServiceBindingUsageStatus.reason":
		if e.complexity.ServiceBindingUsageStatus.Reason == nil {
			break
		}

		return e.complexity.ServiceBindingUsageStatus.Reason(childComplexity), true

	case "ServiceBindingUsageStatus.message":
		if e.complexity.ServiceBindingUsageStatus.Message == nil {
			break
		}

		return e.complexity.ServiceBindingUsageStatus.Message(childComplexity), true

	case "ServiceBindings.items":
		if e.complexity.ServiceBindings.Items == nil {
			break
		}

		return e.complexity.ServiceBindings.Items(childComplexity), true

	case "ServiceBindings.stats":
		if e.complexity.ServiceBindings.Stats == nil {
			break
		}

		return e.complexity.ServiceBindings.Stats(childComplexity), true

	case "ServiceBindingsStats.ready":
		if e.complexity.ServiceBindingsStats.Ready == nil {
			break
		}

		return e.complexity.ServiceBindingsStats.Ready(childComplexity), true

	case "ServiceBindingsStats.failed":
		if e.complexity.ServiceBindingsStats.Failed == nil {
			break
		}

		return e.complexity.ServiceBindingsStats.Failed(childComplexity), true

	case "ServiceBindingsStats.pending":
		if e.complexity.ServiceBindingsStats.Pending == nil {
			break
		}

		return e.complexity.ServiceBindingsStats.Pending(childComplexity), true

	case "ServiceBindingsStats.unknown":
		if e.complexity.ServiceBindingsStats.Unknown == nil {
			break
		}

		return e.complexity.ServiceBindingsStats.Unknown(childComplexity), true

	case "ServiceBroker.name":
		if e.complexity.ServiceBroker.Name == nil {
			break
		}

		return e.complexity.ServiceBroker.Name(childComplexity), true

	case "ServiceBroker.namespace":
		if e.complexity.ServiceBroker.Namespace == nil {
			break
		}

		return e.complexity.ServiceBroker.Namespace(childComplexity), true

	case "ServiceBroker.status":
		if e.complexity.ServiceBroker.Status == nil {
			break
		}

		return e.complexity.ServiceBroker.Status(childComplexity), true

	case "ServiceBroker.creationTimestamp":
		if e.complexity.ServiceBroker.CreationTimestamp == nil {
			break
		}

		return e.complexity.ServiceBroker.CreationTimestamp(childComplexity), true

	case "ServiceBroker.url":
		if e.complexity.ServiceBroker.Url == nil {
			break
		}

		return e.complexity.ServiceBroker.Url(childComplexity), true

	case "ServiceBroker.labels":
		if e.complexity.ServiceBroker.Labels == nil {
			break
		}

		return e.complexity.ServiceBroker.Labels(childComplexity), true

	case "ServiceBrokerEvent.type":
		if e.complexity.ServiceBrokerEvent.Type == nil {
			break
		}

		return e.complexity.ServiceBrokerEvent.Type(childComplexity), true

	case "ServiceBrokerEvent.serviceBroker":
		if e.complexity.ServiceBrokerEvent.ServiceBroker == nil {
			break
		}

		return e.complexity.ServiceBrokerEvent.ServiceBroker(childComplexity), true

	case "ServiceBrokerStatus.ready":
		if e.complexity.ServiceBrokerStatus.Ready == nil {
			break
		}

		return e.complexity.ServiceBrokerStatus.Ready(childComplexity), true

	case "ServiceBrokerStatus.reason":
		if e.complexity.ServiceBrokerStatus.Reason == nil {
			break
		}

		return e.complexity.ServiceBrokerStatus.Reason(childComplexity), true

	case "ServiceBrokerStatus.message":
		if e.complexity.ServiceBrokerStatus.Message == nil {
			break
		}

		return e.complexity.ServiceBrokerStatus.Message(childComplexity), true

	case "ServiceClass.name":
		if e.complexity.ServiceClass.Name == nil {
			break
		}

		return e.complexity.ServiceClass.Name(childComplexity), true

	case "ServiceClass.namespace":
		if e.complexity.ServiceClass.Namespace == nil {
			break
		}

		return e.complexity.ServiceClass.Namespace(childComplexity), true

	case "ServiceClass.externalName":
		if e.complexity.ServiceClass.ExternalName == nil {
			break
		}

		return e.complexity.ServiceClass.ExternalName(childComplexity), true

	case "ServiceClass.displayName":
		if e.complexity.ServiceClass.DisplayName == nil {
			break
		}

		return e.complexity.ServiceClass.DisplayName(childComplexity), true

	case "ServiceClass.creationTimestamp":
		if e.complexity.ServiceClass.CreationTimestamp == nil {
			break
		}

		return e.complexity.ServiceClass.CreationTimestamp(childComplexity), true

	case "ServiceClass.description":
		if e.complexity.ServiceClass.Description == nil {
			break
		}

		return e.complexity.ServiceClass.Description(childComplexity), true

	case "ServiceClass.longDescription":
		if e.complexity.ServiceClass.LongDescription == nil {
			break
		}

		return e.complexity.ServiceClass.LongDescription(childComplexity), true

	case "ServiceClass.imageUrl":
		if e.complexity.ServiceClass.ImageUrl == nil {
			break
		}

		return e.complexity.ServiceClass.ImageUrl(childComplexity), true

	case "ServiceClass.documentationUrl":
		if e.complexity.ServiceClass.DocumentationUrl == nil {
			break
		}

		return e.complexity.ServiceClass.DocumentationUrl(childComplexity), true

	case "ServiceClass.supportUrl":
		if e.complexity.ServiceClass.SupportUrl == nil {
			break
		}

		return e.complexity.ServiceClass.SupportUrl(childComplexity), true

	case "ServiceClass.providerDisplayName":
		if e.complexity.ServiceClass.ProviderDisplayName == nil {
			break
		}

		return e.complexity.ServiceClass.ProviderDisplayName(childComplexity), true

	case "ServiceClass.tags":
		if e.complexity.ServiceClass.Tags == nil {
			break
		}

		return e.complexity.ServiceClass.Tags(childComplexity), true

	case "ServiceClass.labels":
		if e.complexity.ServiceClass.Labels == nil {
			break
		}

		return e.complexity.ServiceClass.Labels(childComplexity), true

	case "ServiceClass.plans":
		if e.complexity.ServiceClass.Plans == nil {
			break
		}

		return e.complexity.ServiceClass.Plans(childComplexity), true

	case "ServiceClass.activated":
		if e.complexity.ServiceClass.Activated == nil {
			break
		}

		return e.complexity.ServiceClass.Activated(childComplexity), true

	case "ServiceClass.instances":
		if e.complexity.ServiceClass.Instances == nil {
			break
		}

		return e.complexity.ServiceClass.Instances(childComplexity), true

	case "ServiceClass.clusterAssetGroup":
		if e.complexity.ServiceClass.ClusterAssetGroup == nil {
			break
		}

		return e.complexity.ServiceClass.ClusterAssetGroup(childComplexity), true

	case "ServiceClass.assetGroup":
		if e.complexity.ServiceClass.AssetGroup == nil {
			break
		}

		return e.complexity.ServiceClass.AssetGroup(childComplexity), true

	case "ServiceEvent.type":
		if e.complexity.ServiceEvent.Type == nil {
			break
		}

		return e.complexity.ServiceEvent.Type(childComplexity), true

	case "ServiceEvent.service":
		if e.complexity.ServiceEvent.Service == nil {
			break
		}

		return e.complexity.ServiceEvent.Service(childComplexity), true

	case "ServiceInstance.name":
		if e.complexity.ServiceInstance.Name == nil {
			break
		}

		return e.complexity.ServiceInstance.Name(childComplexity), true

	case "ServiceInstance.namespace":
		if e.complexity.ServiceInstance.Namespace == nil {
			break
		}

		return e.complexity.ServiceInstance.Namespace(childComplexity), true

	case "ServiceInstance.planSpec":
		if e.complexity.ServiceInstance.PlanSpec == nil {
			break
		}

		return e.complexity.ServiceInstance.PlanSpec(childComplexity), true

	case "ServiceInstance.creationTimestamp":
		if e.complexity.ServiceInstance.CreationTimestamp == nil {
			break
		}

		return e.complexity.ServiceInstance.CreationTimestamp(childComplexity), true

	case "ServiceInstance.labels":
		if e.complexity.ServiceInstance.Labels == nil {
			break
		}

		return e.complexity.ServiceInstance.Labels(childComplexity), true

	case "ServiceInstance.status":
		if e.complexity.ServiceInstance.Status == nil {
			break
		}

		return e.complexity.ServiceInstance.Status(childComplexity), true

	case "ServiceInstance.classReference":
		if e.complexity.ServiceInstance.ClassReference == nil {
			break
		}

		return e.complexity.ServiceInstance.ClassReference(childComplexity), true

	case "ServiceInstance.planReference":
		if e.complexity.ServiceInstance.PlanReference == nil {
			break
		}

		return e.complexity.ServiceInstance.PlanReference(childComplexity), true

	case "ServiceInstance.serviceClass":
		if e.complexity.ServiceInstance.ServiceClass == nil {
			break
		}

		return e.complexity.ServiceInstance.ServiceClass(childComplexity), true

	case "ServiceInstance.clusterServiceClass":
		if e.complexity.ServiceInstance.ClusterServiceClass == nil {
			break
		}

		return e.complexity.ServiceInstance.ClusterServiceClass(childComplexity), true

	case "ServiceInstance.servicePlan":
		if e.complexity.ServiceInstance.ServicePlan == nil {
			break
		}

		return e.complexity.ServiceInstance.ServicePlan(childComplexity), true

	case "ServiceInstance.clusterServicePlan":
		if e.complexity.ServiceInstance.ClusterServicePlan == nil {
			break
		}

		return e.complexity.ServiceInstance.ClusterServicePlan(childComplexity), true

	case "ServiceInstance.bindable":
		if e.complexity.ServiceInstance.Bindable == nil {
			break
		}

		return e.complexity.ServiceInstance.Bindable(childComplexity), true

	case "ServiceInstance.serviceBindings":
		if e.complexity.ServiceInstance.ServiceBindings == nil {
			break
		}

		return e.complexity.ServiceInstance.ServiceBindings(childComplexity), true

	case "ServiceInstance.serviceBindingUsages":
		if e.complexity.ServiceInstance.ServiceBindingUsages == nil {
			break
		}

		return e.complexity.ServiceInstance.ServiceBindingUsages(childComplexity), true

	case "ServiceInstanceEvent.type":
		if e.complexity.ServiceInstanceEvent.Type == nil {
			break
		}

		return e.complexity.ServiceInstanceEvent.Type(childComplexity), true

	case "ServiceInstanceEvent.serviceInstance":
		if e.complexity.ServiceInstanceEvent.ServiceInstance == nil {
			break
		}

		return e.complexity.ServiceInstanceEvent.ServiceInstance(childComplexity), true

	case "ServiceInstanceResourceRef.name":
		if e.complexity.ServiceInstanceResourceRef.Name == nil {
			break
		}

		return e.complexity.ServiceInstanceResourceRef.Name(childComplexity), true

	case "ServiceInstanceResourceRef.displayName":
		if e.complexity.ServiceInstanceResourceRef.DisplayName == nil {
			break
		}

		return e.complexity.ServiceInstanceResourceRef.DisplayName(childComplexity), true

	case "ServiceInstanceResourceRef.clusterWide":
		if e.complexity.ServiceInstanceResourceRef.ClusterWide == nil {
			break
		}

		return e.complexity.ServiceInstanceResourceRef.ClusterWide(childComplexity), true

	case "ServiceInstanceStatus.type":
		if e.complexity.ServiceInstanceStatus.Type == nil {
			break
		}

		return e.complexity.ServiceInstanceStatus.Type(childComplexity), true

	case "ServiceInstanceStatus.reason":
		if e.complexity.ServiceInstanceStatus.Reason == nil {
			break
		}

		return e.complexity.ServiceInstanceStatus.Reason(childComplexity), true

	case "ServiceInstanceStatus.message":
		if e.complexity.ServiceInstanceStatus.Message == nil {
			break
		}

		return e.complexity.ServiceInstanceStatus.Message(childComplexity), true

	case "ServicePlan.name":
		if e.complexity.ServicePlan.Name == nil {
			break
		}

		return e.complexity.ServicePlan.Name(childComplexity), true

	case "ServicePlan.namespace":
		if e.complexity.ServicePlan.Namespace == nil {
			break
		}

		return e.complexity.ServicePlan.Namespace(childComplexity), true

	case "ServicePlan.displayName":
		if e.complexity.ServicePlan.DisplayName == nil {
			break
		}

		return e.complexity.ServicePlan.DisplayName(childComplexity), true

	case "ServicePlan.externalName":
		if e.complexity.ServicePlan.ExternalName == nil {
			break
		}

		return e.complexity.ServicePlan.ExternalName(childComplexity), true

	case "ServicePlan.description":
		if e.complexity.ServicePlan.Description == nil {
			break
		}

		return e.complexity.ServicePlan.Description(childComplexity), true

	case "ServicePlan.relatedServiceClassName":
		if e.complexity.ServicePlan.RelatedServiceClassName == nil {
			break
		}

		return e.complexity.ServicePlan.RelatedServiceClassName(childComplexity), true

	case "ServicePlan.instanceCreateParameterSchema":
		if e.complexity.ServicePlan.InstanceCreateParameterSchema == nil {
			break
		}

		return e.complexity.ServicePlan.InstanceCreateParameterSchema(childComplexity), true

	case "ServicePlan.bindingCreateParameterSchema":
		if e.complexity.ServicePlan.BindingCreateParameterSchema == nil {
			break
		}

		return e.complexity.ServicePlan.BindingCreateParameterSchema(childComplexity), true

	case "ServicePlan.clusterAssetGroup":
		if e.complexity.ServicePlan.ClusterAssetGroup == nil {
			break
		}

		return e.complexity.ServicePlan.ClusterAssetGroup(childComplexity), true

	case "ServicePlan.assetGroup":
		if e.complexity.ServicePlan.AssetGroup == nil {
			break
		}

		return e.complexity.ServicePlan.AssetGroup(childComplexity), true

	case "ServicePort.name":
		if e.complexity.ServicePort.Name == nil {
			break
		}

		return e.complexity.ServicePort.Name(childComplexity), true

	case "ServicePort.serviceProtocol":
		if e.complexity.ServicePort.ServiceProtocol == nil {
			break
		}

		return e.complexity.ServicePort.ServiceProtocol(childComplexity), true

	case "ServicePort.port":
		if e.complexity.ServicePort.Port == nil {
			break
		}

		return e.complexity.ServicePort.Port(childComplexity), true

	case "ServicePort.nodePort":
		if e.complexity.ServicePort.NodePort == nil {
			break
		}

		return e.complexity.ServicePort.NodePort(childComplexity), true

	case "ServicePort.targetPort":
		if e.complexity.ServicePort.TargetPort == nil {
			break
		}

		return e.complexity.ServicePort.TargetPort(childComplexity), true

	case "ServiceStatus.loadBalancer":
		if e.complexity.ServiceStatus.LoadBalancer == nil {
			break
		}

		return e.complexity.ServiceStatus.LoadBalancer(childComplexity), true

	case "Subscriber.uri":
		if e.complexity.Subscriber.Uri == nil {
			break
		}

		return e.complexity.Subscriber.Uri(childComplexity), true

	case "Subscriber.ref":
		if e.complexity.Subscriber.Ref == nil {
			break
		}

		return e.complexity.Subscriber.Ref(childComplexity), true

	case "SubscriberRef.apiVersion":
		if e.complexity.SubscriberRef.ApiVersion == nil {
			break
		}

		return e.complexity.SubscriberRef.ApiVersion(childComplexity), true

	case "SubscriberRef.kind":
		if e.complexity.SubscriberRef.Kind == nil {
			break
		}

		return e.complexity.SubscriberRef.Kind(childComplexity), true

	case "SubscriberRef.name":
		if e.complexity.SubscriberRef.Name == nil {
			break
		}

		return e.complexity.SubscriberRef.Name(childComplexity), true

	case "SubscriberRef.namespace":
		if e.complexity.SubscriberRef.Namespace == nil {
			break
		}

		return e.complexity.SubscriberRef.Namespace(childComplexity), true

	case "Subscription.clusterAssetEvent":
		if e.complexity.Subscription.ClusterAssetEvent == nil {
			break
		}

		return e.complexity.Subscription.ClusterAssetEvent(childComplexity), true

	case "Subscription.assetEvent":
		if e.complexity.Subscription.AssetEvent == nil {
			break
		}

		args, err := field_Subscription_assetEvent_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.AssetEvent(childComplexity, args["namespace"].(string)), true

	case "Subscription.clusterAssetGroupEvent":
		if e.complexity.Subscription.ClusterAssetGroupEvent == nil {
			break
		}

		return e.complexity.Subscription.ClusterAssetGroupEvent(childComplexity), true

	case "Subscription.assetGroupEvent":
		if e.complexity.Subscription.AssetGroupEvent == nil {
			break
		}

		args, err := field_Subscription_assetGroupEvent_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.AssetGroupEvent(childComplexity, args["namespace"].(string)), true

	case "Subscription.serviceInstanceEvent":
		if e.complexity.Subscription.ServiceInstanceEvent == nil {
			break
		}

		args, err := field_Subscription_serviceInstanceEvent_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.ServiceInstanceEvent(childComplexity, args["namespace"].(string)), true

	case "Subscription.serviceBindingEvent":
		if e.complexity.Subscription.ServiceBindingEvent == nil {
			break
		}

		args, err := field_Subscription_serviceBindingEvent_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.ServiceBindingEvent(childComplexity, args["namespace"].(string)), true

	case "Subscription.serviceBindingUsageEvent":
		if e.complexity.Subscription.ServiceBindingUsageEvent == nil {
			break
		}

		args, err := field_Subscription_serviceBindingUsageEvent_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.ServiceBindingUsageEvent(childComplexity, args["namespace"].(string), args["resourceKind"].(*string), args["resourceName"].(*string)), true

	case "Subscription.serviceBrokerEvent":
		if e.complexity.Subscription.ServiceBrokerEvent == nil {
			break
		}

		args, err := field_Subscription_serviceBrokerEvent_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.ServiceBrokerEvent(childComplexity, args["namespace"].(string)), true

	case "Subscription.clusterServiceBrokerEvent":
		if e.complexity.Subscription.ClusterServiceBrokerEvent == nil {
			break
		}

		return e.complexity.Subscription.ClusterServiceBrokerEvent(childComplexity), true

	case "Subscription.applicationEvent":
		if e.complexity.Subscription.ApplicationEvent == nil {
			break
		}

		return e.complexity.Subscription.ApplicationEvent(childComplexity), true

	case "Subscription.podEvent":
		if e.complexity.Subscription.PodEvent == nil {
			break
		}

		args, err := field_Subscription_podEvent_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.PodEvent(childComplexity, args["namespace"].(string)), true

	case "Subscription.serviceEvent":
		if e.complexity.Subscription.ServiceEvent == nil {
			break
		}

		args, err := field_Subscription_serviceEvent_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.ServiceEvent(childComplexity, args["namespace"].(string)), true

	case "Subscription.configMapEvent":
		if e.complexity.Subscription.ConfigMapEvent == nil {
			break
		}

		args, err := field_Subscription_configMapEvent_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.ConfigMapEvent(childComplexity, args["namespace"].(string)), true

	case "Subscription.clusterAddonsConfigurationEvent":
		if e.complexity.Subscription.ClusterAddonsConfigurationEvent == nil {
			break
		}

		return e.complexity.Subscription.ClusterAddonsConfigurationEvent(childComplexity), true

	case "Subscription.addonsConfigurationEvent":
		if e.complexity.Subscription.AddonsConfigurationEvent == nil {
			break
		}

		args, err := field_Subscription_addonsConfigurationEvent_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.AddonsConfigurationEvent(childComplexity, args["namespace"].(string)), true

	case "Subscription.apiRuleEvent":
		if e.complexity.Subscription.ApiRuleEvent == nil {
			break
		}

		args, err := field_Subscription_apiRuleEvent_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.ApiRuleEvent(childComplexity, args["namespace"].(string), args["serviceName"].(*string)), true

	case "Subscription.namespaceEvent":
		if e.complexity.Subscription.NamespaceEvent == nil {
			break
		}

		args, err := field_Subscription_namespaceEvent_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.NamespaceEvent(childComplexity, args["withSystemNamespaces"].(*bool)), true

	case "Subscription.functionEvent":
		if e.complexity.Subscription.FunctionEvent == nil {
			break
		}

		args, err := field_Subscription_functionEvent_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.FunctionEvent(childComplexity, args["namespace"].(string), args["functionName"].(*string)), true

	case "Subscription.triggerEvent":
		if e.complexity.Subscription.TriggerEvent == nil {
			break
		}

		args, err := field_Subscription_triggerEvent_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.TriggerEvent(childComplexity, args["namespace"].(string), args["subscriber"].(*SubscriberInput)), true

	case "Trigger.name":
		if e.complexity.Trigger.Name == nil {
			break
		}

		return e.complexity.Trigger.Name(childComplexity), true

	case "Trigger.namespace":
		if e.complexity.Trigger.Namespace == nil {
			break
		}

		return e.complexity.Trigger.Namespace(childComplexity), true

	case "Trigger.broker":
		if e.complexity.Trigger.Broker == nil {
			break
		}

		return e.complexity.Trigger.Broker(childComplexity), true

	case "Trigger.filterAttributes":
		if e.complexity.Trigger.FilterAttributes == nil {
			break
		}

		return e.complexity.Trigger.FilterAttributes(childComplexity), true

	case "Trigger.subscriber":
		if e.complexity.Trigger.Subscriber == nil {
			break
		}

		return e.complexity.Trigger.Subscriber(childComplexity), true

	case "Trigger.status":
		if e.complexity.Trigger.Status == nil {
			break
		}

		return e.complexity.Trigger.Status(childComplexity), true

	case "TriggerEvent.type":
		if e.complexity.TriggerEvent.Type == nil {
			break
		}

		return e.complexity.TriggerEvent.Type(childComplexity), true

	case "TriggerEvent.trigger":
		if e.complexity.TriggerEvent.Trigger == nil {
			break
		}

		return e.complexity.TriggerEvent.Trigger(childComplexity), true

	case "TriggerMetadata.name":
		if e.complexity.TriggerMetadata.Name == nil {
			break
		}

		return e.complexity.TriggerMetadata.Name(childComplexity), true

	case "TriggerMetadata.namespace":
		if e.complexity.TriggerMetadata.Namespace == nil {
			break
		}

		return e.complexity.TriggerMetadata.Namespace(childComplexity), true

	case "TriggerStatus.reason":
		if e.complexity.TriggerStatus.Reason == nil {
			break
		}

		return e.complexity.TriggerStatus.Reason(childComplexity), true

	case "TriggerStatus.status":
		if e.complexity.TriggerStatus.Status == nil {
			break
		}

		return e.complexity.TriggerStatus.Status(childComplexity), true

	case "UsageKind.name":
		if e.complexity.UsageKind.Name == nil {
			break
		}

		return e.complexity.UsageKind.Name(childComplexity), true

	case "UsageKind.group":
		if e.complexity.UsageKind.Group == nil {
			break
		}

		return e.complexity.UsageKind.Group(childComplexity), true

	case "UsageKind.kind":
		if e.complexity.UsageKind.Kind == nil {
			break
		}

		return e.complexity.UsageKind.Kind(childComplexity), true

	case "UsageKind.version":
		if e.complexity.UsageKind.Version == nil {
			break
		}

		return e.complexity.UsageKind.Version(childComplexity), true

	case "UsageKind.displayName":
		if e.complexity.UsageKind.DisplayName == nil {
			break
		}

		return e.complexity.UsageKind.DisplayName(childComplexity), true

	case "UsageKindResource.name":
		if e.complexity.UsageKindResource.Name == nil {
			break
		}

		return e.complexity.UsageKindResource.Name(childComplexity), true

	case "UsageKindResource.namespace":
		if e.complexity.UsageKindResource.Namespace == nil {
			break
		}

		return e.complexity.UsageKindResource.Namespace(childComplexity), true

	case "VersionInfo.kymaVersion":
		if e.complexity.VersionInfo.KymaVersion == nil {
			break
		}

		return e.complexity.VersionInfo.KymaVersion(childComplexity), true

	case "compassMetadata.applicationId":
		if e.complexity.CompassMetadata.ApplicationId == nil {
			break
		}

		return e.complexity.CompassMetadata.ApplicationId(childComplexity), true

	case "enabledMappingService.namespace":
		if e.complexity.EnabledMappingService.Namespace == nil {
			break
		}

		return e.complexity.EnabledMappingService.Namespace(childComplexity), true

	case "enabledMappingService.allServices":
		if e.complexity.EnabledMappingService.AllServices == nil {
			break
		}

		return e.complexity.EnabledMappingService.AllServices(childComplexity), true

	case "enabledMappingService.services":
		if e.complexity.EnabledMappingService.Services == nil {
			break
		}

		return e.complexity.EnabledMappingService.Services(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Query(ctx context.Context, op *ast.OperationDefinition) *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e}

	buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
		data := ec._Query(ctx, op.SelectionSet)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)
		return buf.Bytes()
	})

	return &graphql.Response{
		Data:       buf,
		Errors:     ec.Errors,
		Extensions: ec.Extensions}
}

func (e *executableSchema) Mutation(ctx context.Context, op *ast.OperationDefinition) *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e}

	buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
		data := ec._Mutation(ctx, op.SelectionSet)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)
		return buf.Bytes()
	})

	return &graphql.Response{
		Data:       buf,
		Errors:     ec.Errors,
		Extensions: ec.Extensions,
	}
}

func (e *executableSchema) Subscription(ctx context.Context, op *ast.OperationDefinition) func() *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e}

	next := ec._Subscription(ctx, op.SelectionSet)
	if ec.Errors != nil {
		return graphql.OneShot(&graphql.Response{Data: []byte("null"), Errors: ec.Errors})
	}

	var buf bytes.Buffer
	return func() *graphql.Response {
		buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
			buf.Reset()
			data := next()

			if data == nil {
				return nil
			}
			data.MarshalGQL(&buf)
			return buf.Bytes()
		})

		if buf == nil {
			return nil
		}

		return &graphql.Response{
			Data:       buf,
			Errors:     ec.Errors,
			Extensions: ec.Extensions,
		}
	}
}

type executionContext struct {
	*graphql.RequestContext
	*executableSchema
}

var aPIRuleImplementors = []string{"APIRule"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _APIRule(ctx context.Context, sel ast.SelectionSet, obj *APIRule) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, aPIRuleImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("APIRule")
		case "name":
			out.Values[i] = ec._APIRule_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "service":
			out.Values[i] = ec._APIRule_service(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "gateway":
			out.Values[i] = ec._APIRule_gateway(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "rules":
			out.Values[i] = ec._APIRule_rules(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "status":
			out.Values[i] = ec._APIRule_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _APIRule_name(ctx context.Context, field graphql.CollectedField, obj *APIRule) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "APIRule",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _APIRule_service(ctx context.Context, field graphql.CollectedField, obj *APIRule) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "APIRule",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Service, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(APIRuleService)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._APIRuleService(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _APIRule_gateway(ctx context.Context, field graphql.CollectedField, obj *APIRule) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "APIRule",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Gateway, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _APIRule_rules(ctx context.Context, field graphql.CollectedField, obj *APIRule) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "APIRule",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Rules, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]Rule)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Rule(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _APIRule_status(ctx context.Context, field graphql.CollectedField, obj *APIRule) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "APIRule",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(APIRuleStatuses)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._APIRuleStatuses(ctx, field.Selections, &res)
}

var aPIRuleConfigImplementors = []string{"APIRuleConfig"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _APIRuleConfig(ctx context.Context, sel ast.SelectionSet, obj *APIRuleConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, aPIRuleConfigImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("APIRuleConfig")
		case "name":
			out.Values[i] = ec._APIRuleConfig_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "config":
			out.Values[i] = ec._APIRuleConfig_config(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _APIRuleConfig_name(ctx context.Context, field graphql.CollectedField, obj *APIRuleConfig) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "APIRuleConfig",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _APIRuleConfig_config(ctx context.Context, field graphql.CollectedField, obj *APIRuleConfig) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "APIRuleConfig",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Config, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(JSON)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

var aPIRuleServiceImplementors = []string{"APIRuleService"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _APIRuleService(ctx context.Context, sel ast.SelectionSet, obj *APIRuleService) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, aPIRuleServiceImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("APIRuleService")
		case "host":
			out.Values[i] = ec._APIRuleService_host(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "name":
			out.Values[i] = ec._APIRuleService_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "port":
			out.Values[i] = ec._APIRuleService_port(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _APIRuleService_host(ctx context.Context, field graphql.CollectedField, obj *APIRuleService) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "APIRuleService",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Host, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _APIRuleService_name(ctx context.Context, field graphql.CollectedField, obj *APIRuleService) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "APIRuleService",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _APIRuleService_port(ctx context.Context, field graphql.CollectedField, obj *APIRuleService) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "APIRuleService",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Port, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

var aPIRuleStatusImplementors = []string{"APIRuleStatus"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _APIRuleStatus(ctx context.Context, sel ast.SelectionSet, obj *APIRuleStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, aPIRuleStatusImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("APIRuleStatus")
		case "code":
			out.Values[i] = ec._APIRuleStatus_code(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "desc":
			out.Values[i] = ec._APIRuleStatus_desc(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _APIRuleStatus_code(ctx context.Context, field graphql.CollectedField, obj *APIRuleStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "APIRuleStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Code, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _APIRuleStatus_desc(ctx context.Context, field graphql.CollectedField, obj *APIRuleStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "APIRuleStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Desc, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var aPIRuleStatusesImplementors = []string{"APIRuleStatuses"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _APIRuleStatuses(ctx context.Context, sel ast.SelectionSet, obj *APIRuleStatuses) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, aPIRuleStatusesImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("APIRuleStatuses")
		case "apiRuleStatus":
			out.Values[i] = ec._APIRuleStatuses_apiRuleStatus(ctx, field, obj)
		case "accessRuleStatus":
			out.Values[i] = ec._APIRuleStatuses_accessRuleStatus(ctx, field, obj)
		case "virtualServiceStatus":
			out.Values[i] = ec._APIRuleStatuses_virtualServiceStatus(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _APIRuleStatuses_apiRuleStatus(ctx context.Context, field graphql.CollectedField, obj *APIRuleStatuses) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "APIRuleStatuses",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.APIRuleStatus, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*APIRuleStatus)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._APIRuleStatus(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _APIRuleStatuses_accessRuleStatus(ctx context.Context, field graphql.CollectedField, obj *APIRuleStatuses) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "APIRuleStatuses",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccessRuleStatus, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*APIRuleStatus)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._APIRuleStatus(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _APIRuleStatuses_virtualServiceStatus(ctx context.Context, field graphql.CollectedField, obj *APIRuleStatuses) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "APIRuleStatuses",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VirtualServiceStatus, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*APIRuleStatus)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._APIRuleStatus(ctx, field.Selections, res)
}

var addonsConfigurationImplementors = []string{"AddonsConfiguration"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _AddonsConfiguration(ctx context.Context, sel ast.SelectionSet, obj *AddonsConfiguration) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, addonsConfigurationImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AddonsConfiguration")
		case "name":
			out.Values[i] = ec._AddonsConfiguration_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "urls":
			out.Values[i] = ec._AddonsConfiguration_urls(ctx, field, obj)
		case "repositories":
			out.Values[i] = ec._AddonsConfiguration_repositories(ctx, field, obj)
		case "labels":
			out.Values[i] = ec._AddonsConfiguration_labels(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "status":
			out.Values[i] = ec._AddonsConfiguration_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _AddonsConfiguration_name(ctx context.Context, field graphql.CollectedField, obj *AddonsConfiguration) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AddonsConfiguration",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _AddonsConfiguration_urls(ctx context.Context, field graphql.CollectedField, obj *AddonsConfiguration) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AddonsConfiguration",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Urls, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return graphql.MarshalString(res[idx1])
		}()
	}

	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _AddonsConfiguration_repositories(ctx context.Context, field graphql.CollectedField, obj *AddonsConfiguration) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AddonsConfiguration",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Repositories, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]AddonsConfigurationRepository)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._AddonsConfigurationRepository(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _AddonsConfiguration_labels(ctx context.Context, field graphql.CollectedField, obj *AddonsConfiguration) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AddonsConfiguration",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Labels)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _AddonsConfiguration_status(ctx context.Context, field graphql.CollectedField, obj *AddonsConfiguration) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AddonsConfiguration",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(AddonsConfigurationStatus)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._AddonsConfigurationStatus(ctx, field.Selections, &res)
}

var addonsConfigurationEventImplementors = []string{"AddonsConfigurationEvent"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _AddonsConfigurationEvent(ctx context.Context, sel ast.SelectionSet, obj *AddonsConfigurationEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, addonsConfigurationEventImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AddonsConfigurationEvent")
		case "type":
			out.Values[i] = ec._AddonsConfigurationEvent_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "addonsConfiguration":
			out.Values[i] = ec._AddonsConfigurationEvent_addonsConfiguration(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _AddonsConfigurationEvent_type(ctx context.Context, field graphql.CollectedField, obj *AddonsConfigurationEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AddonsConfigurationEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SubscriptionEventType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _AddonsConfigurationEvent_addonsConfiguration(ctx context.Context, field graphql.CollectedField, obj *AddonsConfigurationEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AddonsConfigurationEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AddonsConfiguration, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(AddonsConfiguration)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._AddonsConfiguration(ctx, field.Selections, &res)
}

var addonsConfigurationRepositoryImplementors = []string{"AddonsConfigurationRepository"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _AddonsConfigurationRepository(ctx context.Context, sel ast.SelectionSet, obj *AddonsConfigurationRepository) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, addonsConfigurationRepositoryImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AddonsConfigurationRepository")
		case "url":
			out.Values[i] = ec._AddonsConfigurationRepository_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "secretRef":
			out.Values[i] = ec._AddonsConfigurationRepository_secretRef(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _AddonsConfigurationRepository_url(ctx context.Context, field graphql.CollectedField, obj *AddonsConfigurationRepository) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AddonsConfigurationRepository",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _AddonsConfigurationRepository_secretRef(ctx context.Context, field graphql.CollectedField, obj *AddonsConfigurationRepository) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AddonsConfigurationRepository",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SecretRef, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ResourceRef)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ResourceRef(ctx, field.Selections, res)
}

var addonsConfigurationStatusImplementors = []string{"AddonsConfigurationStatus"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _AddonsConfigurationStatus(ctx context.Context, sel ast.SelectionSet, obj *AddonsConfigurationStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, addonsConfigurationStatusImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AddonsConfigurationStatus")
		case "phase":
			out.Values[i] = ec._AddonsConfigurationStatus_phase(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "repositories":
			out.Values[i] = ec._AddonsConfigurationStatus_repositories(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _AddonsConfigurationStatus_phase(ctx context.Context, field graphql.CollectedField, obj *AddonsConfigurationStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AddonsConfigurationStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Phase, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _AddonsConfigurationStatus_repositories(ctx context.Context, field graphql.CollectedField, obj *AddonsConfigurationStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AddonsConfigurationStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Repositories, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]AddonsConfigurationStatusRepository)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._AddonsConfigurationStatusRepository(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var addonsConfigurationStatusAddonsImplementors = []string{"AddonsConfigurationStatusAddons"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _AddonsConfigurationStatusAddons(ctx context.Context, sel ast.SelectionSet, obj *AddonsConfigurationStatusAddons) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, addonsConfigurationStatusAddonsImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AddonsConfigurationStatusAddons")
		case "name":
			out.Values[i] = ec._AddonsConfigurationStatusAddons_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "version":
			out.Values[i] = ec._AddonsConfigurationStatusAddons_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "status":
			out.Values[i] = ec._AddonsConfigurationStatusAddons_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "reason":
			out.Values[i] = ec._AddonsConfigurationStatusAddons_reason(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "message":
			out.Values[i] = ec._AddonsConfigurationStatusAddons_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _AddonsConfigurationStatusAddons_name(ctx context.Context, field graphql.CollectedField, obj *AddonsConfigurationStatusAddons) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AddonsConfigurationStatusAddons",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _AddonsConfigurationStatusAddons_version(ctx context.Context, field graphql.CollectedField, obj *AddonsConfigurationStatusAddons) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AddonsConfigurationStatusAddons",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _AddonsConfigurationStatusAddons_status(ctx context.Context, field graphql.CollectedField, obj *AddonsConfigurationStatusAddons) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AddonsConfigurationStatusAddons",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _AddonsConfigurationStatusAddons_reason(ctx context.Context, field graphql.CollectedField, obj *AddonsConfigurationStatusAddons) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AddonsConfigurationStatusAddons",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reason, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _AddonsConfigurationStatusAddons_message(ctx context.Context, field graphql.CollectedField, obj *AddonsConfigurationStatusAddons) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AddonsConfigurationStatusAddons",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var addonsConfigurationStatusRepositoryImplementors = []string{"AddonsConfigurationStatusRepository"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _AddonsConfigurationStatusRepository(ctx context.Context, sel ast.SelectionSet, obj *AddonsConfigurationStatusRepository) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, addonsConfigurationStatusRepositoryImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AddonsConfigurationStatusRepository")
		case "url":
			out.Values[i] = ec._AddonsConfigurationStatusRepository_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "status":
			out.Values[i] = ec._AddonsConfigurationStatusRepository_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "addons":
			out.Values[i] = ec._AddonsConfigurationStatusRepository_addons(ctx, field, obj)
		case "reason":
			out.Values[i] = ec._AddonsConfigurationStatusRepository_reason(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "message":
			out.Values[i] = ec._AddonsConfigurationStatusRepository_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _AddonsConfigurationStatusRepository_url(ctx context.Context, field graphql.CollectedField, obj *AddonsConfigurationStatusRepository) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AddonsConfigurationStatusRepository",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _AddonsConfigurationStatusRepository_status(ctx context.Context, field graphql.CollectedField, obj *AddonsConfigurationStatusRepository) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AddonsConfigurationStatusRepository",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _AddonsConfigurationStatusRepository_addons(ctx context.Context, field graphql.CollectedField, obj *AddonsConfigurationStatusRepository) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AddonsConfigurationStatusRepository",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Addons, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]AddonsConfigurationStatusAddons)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._AddonsConfigurationStatusAddons(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _AddonsConfigurationStatusRepository_reason(ctx context.Context, field graphql.CollectedField, obj *AddonsConfigurationStatusRepository) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AddonsConfigurationStatusRepository",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reason, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _AddonsConfigurationStatusRepository_message(ctx context.Context, field graphql.CollectedField, obj *AddonsConfigurationStatusRepository) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AddonsConfigurationStatusRepository",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var apiRuleEventImplementors = []string{"ApiRuleEvent"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ApiRuleEvent(ctx context.Context, sel ast.SelectionSet, obj *ApiRuleEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, apiRuleEventImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApiRuleEvent")
		case "type":
			out.Values[i] = ec._ApiRuleEvent_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "apiRule":
			out.Values[i] = ec._ApiRuleEvent_apiRule(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ApiRuleEvent_type(ctx context.Context, field graphql.CollectedField, obj *ApiRuleEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ApiRuleEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SubscriptionEventType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _ApiRuleEvent_apiRule(ctx context.Context, field graphql.CollectedField, obj *ApiRuleEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ApiRuleEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.APIRule, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(APIRule)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._APIRule(ctx, field.Selections, &res)
}

var applicationImplementors = []string{"Application"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Application(ctx context.Context, sel ast.SelectionSet, obj *Application) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, applicationImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Application")
		case "name":
			out.Values[i] = ec._Application_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec._Application_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "labels":
			out.Values[i] = ec._Application_labels(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "services":
			out.Values[i] = ec._Application_services(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "enabledInNamespaces":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Application_enabledInNamespaces(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "enabledMappingServices":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Application_enabledMappingServices(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "status":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Application_status(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "compassMetadata":
			out.Values[i] = ec._Application_compassMetadata(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Application_name(ctx context.Context, field graphql.CollectedField, obj *Application) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Application",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Application_description(ctx context.Context, field graphql.CollectedField, obj *Application) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Application",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Application_labels(ctx context.Context, field graphql.CollectedField, obj *Application) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Application",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Labels)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _Application_services(ctx context.Context, field graphql.CollectedField, obj *Application) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Application",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Services, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]ApplicationService)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._ApplicationService(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Application_enabledInNamespaces(ctx context.Context, field graphql.CollectedField, obj *Application) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Application",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Application().EnabledInNamespaces(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return graphql.MarshalString(res[idx1])
		}()
	}

	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Application_enabledMappingServices(ctx context.Context, field graphql.CollectedField, obj *Application) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Application",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Application().EnabledMappingServices(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*EnabledMappingService)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				if res[idx1] == nil {
					return graphql.Null
				}

				return ec._enabledMappingService(ctx, field.Selections, res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Application_status(ctx context.Context, field graphql.CollectedField, obj *Application) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Application",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Application().Status(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ApplicationStatus)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _Application_compassMetadata(ctx context.Context, field graphql.CollectedField, obj *Application) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Application",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CompassMetadata, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*CompassMetadata)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._compassMetadata(ctx, field.Selections, res)
}

var applicationEntryImplementors = []string{"ApplicationEntry"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ApplicationEntry(ctx context.Context, sel ast.SelectionSet, obj *ApplicationEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, applicationEntryImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationEntry")
		case "type":
			out.Values[i] = ec._ApplicationEntry_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "gatewayUrl":
			out.Values[i] = ec._ApplicationEntry_gatewayUrl(ctx, field, obj)
		case "accessLabel":
			out.Values[i] = ec._ApplicationEntry_accessLabel(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ApplicationEntry_type(ctx context.Context, field graphql.CollectedField, obj *ApplicationEntry) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ApplicationEntry",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ApplicationEntry_gatewayUrl(ctx context.Context, field graphql.CollectedField, obj *ApplicationEntry) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ApplicationEntry",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GatewayURL, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ApplicationEntry_accessLabel(ctx context.Context, field graphql.CollectedField, obj *ApplicationEntry) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ApplicationEntry",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccessLabel, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var applicationEventImplementors = []string{"ApplicationEvent"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ApplicationEvent(ctx context.Context, sel ast.SelectionSet, obj *ApplicationEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, applicationEventImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationEvent")
		case "type":
			out.Values[i] = ec._ApplicationEvent_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "application":
			out.Values[i] = ec._ApplicationEvent_application(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ApplicationEvent_type(ctx context.Context, field graphql.CollectedField, obj *ApplicationEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ApplicationEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SubscriptionEventType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _ApplicationEvent_application(ctx context.Context, field graphql.CollectedField, obj *ApplicationEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ApplicationEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Application, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Application)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Application(ctx, field.Selections, &res)
}

var applicationMappingImplementors = []string{"ApplicationMapping"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ApplicationMapping(ctx context.Context, sel ast.SelectionSet, obj *ApplicationMapping) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, applicationMappingImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationMapping")
		case "namespace":
			out.Values[i] = ec._ApplicationMapping_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "application":
			out.Values[i] = ec._ApplicationMapping_application(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "allServices":
			out.Values[i] = ec._ApplicationMapping_allServices(ctx, field, obj)
		case "services":
			out.Values[i] = ec._ApplicationMapping_services(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ApplicationMapping_namespace(ctx context.Context, field graphql.CollectedField, obj *ApplicationMapping) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ApplicationMapping",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ApplicationMapping_application(ctx context.Context, field graphql.CollectedField, obj *ApplicationMapping) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ApplicationMapping",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Application, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ApplicationMapping_allServices(ctx context.Context, field graphql.CollectedField, obj *ApplicationMapping) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ApplicationMapping",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AllServices, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalBoolean(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ApplicationMapping_services(ctx context.Context, field graphql.CollectedField, obj *ApplicationMapping) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ApplicationMapping",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Services, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ApplicationMappingService)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {

			if res[idx1] == nil {
				return graphql.Null
			}
			return *res[idx1]
		}()
	}

	return arr1
}

var applicationMutationOutputImplementors = []string{"ApplicationMutationOutput"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ApplicationMutationOutput(ctx context.Context, sel ast.SelectionSet, obj *ApplicationMutationOutput) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, applicationMutationOutputImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationMutationOutput")
		case "name":
			out.Values[i] = ec._ApplicationMutationOutput_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec._ApplicationMutationOutput_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "labels":
			out.Values[i] = ec._ApplicationMutationOutput_labels(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ApplicationMutationOutput_name(ctx context.Context, field graphql.CollectedField, obj *ApplicationMutationOutput) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ApplicationMutationOutput",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ApplicationMutationOutput_description(ctx context.Context, field graphql.CollectedField, obj *ApplicationMutationOutput) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ApplicationMutationOutput",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ApplicationMutationOutput_labels(ctx context.Context, field graphql.CollectedField, obj *ApplicationMutationOutput) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ApplicationMutationOutput",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Labels)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

var applicationServiceImplementors = []string{"ApplicationService"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ApplicationService(ctx context.Context, sel ast.SelectionSet, obj *ApplicationService) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, applicationServiceImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationService")
		case "id":
			out.Values[i] = ec._ApplicationService_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "displayName":
			out.Values[i] = ec._ApplicationService_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "longDescription":
			out.Values[i] = ec._ApplicationService_longDescription(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "providerDisplayName":
			out.Values[i] = ec._ApplicationService_providerDisplayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "tags":
			out.Values[i] = ec._ApplicationService_tags(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "entries":
			out.Values[i] = ec._ApplicationService_entries(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ApplicationService_id(ctx context.Context, field graphql.CollectedField, obj *ApplicationService) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ApplicationService",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ApplicationService_displayName(ctx context.Context, field graphql.CollectedField, obj *ApplicationService) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ApplicationService",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ApplicationService_longDescription(ctx context.Context, field graphql.CollectedField, obj *ApplicationService) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ApplicationService",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LongDescription, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ApplicationService_providerDisplayName(ctx context.Context, field graphql.CollectedField, obj *ApplicationService) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ApplicationService",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProviderDisplayName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ApplicationService_tags(ctx context.Context, field graphql.CollectedField, obj *ApplicationService) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ApplicationService",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tags, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return graphql.MarshalString(res[idx1])
		}()
	}

	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _ApplicationService_entries(ctx context.Context, field graphql.CollectedField, obj *ApplicationService) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ApplicationService",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Entries, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]ApplicationEntry)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._ApplicationEntry(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var assetImplementors = []string{"Asset"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Asset(ctx context.Context, sel ast.SelectionSet, obj *Asset) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, assetImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Asset")
		case "name":
			out.Values[i] = ec._Asset_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "namespace":
			out.Values[i] = ec._Asset_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "parameters":
			out.Values[i] = ec._Asset_parameters(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "type":
			out.Values[i] = ec._Asset_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "files":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Asset_files(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "status":
			out.Values[i] = ec._Asset_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "displayName":
			out.Values[i] = ec._Asset_displayName(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Asset_name(ctx context.Context, field graphql.CollectedField, obj *Asset) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Asset",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Asset_namespace(ctx context.Context, field graphql.CollectedField, obj *Asset) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Asset",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Asset_parameters(ctx context.Context, field graphql.CollectedField, obj *Asset) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Asset",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Parameters, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(JSON)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _Asset_type(ctx context.Context, field graphql.CollectedField, obj *Asset) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Asset",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Asset_files(ctx context.Context, field graphql.CollectedField, obj *Asset) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Asset_files_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Asset",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Asset().Files(rctx, obj, args["filterExtensions"].([]string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]File)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._File(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Asset_status(ctx context.Context, field graphql.CollectedField, obj *Asset) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Asset",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(AssetStatus)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._AssetStatus(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Asset_displayName(ctx context.Context, field graphql.CollectedField, obj *Asset) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Asset",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var assetEventImplementors = []string{"AssetEvent"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _AssetEvent(ctx context.Context, sel ast.SelectionSet, obj *AssetEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, assetEventImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AssetEvent")
		case "type":
			out.Values[i] = ec._AssetEvent_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "asset":
			out.Values[i] = ec._AssetEvent_asset(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _AssetEvent_type(ctx context.Context, field graphql.CollectedField, obj *AssetEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AssetEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SubscriptionEventType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _AssetEvent_asset(ctx context.Context, field graphql.CollectedField, obj *AssetEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AssetEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Asset, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Asset)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Asset(ctx, field.Selections, &res)
}

var assetGroupImplementors = []string{"AssetGroup"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _AssetGroup(ctx context.Context, sel ast.SelectionSet, obj *AssetGroup) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, assetGroupImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AssetGroup")
		case "name":
			out.Values[i] = ec._AssetGroup_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "namespace":
			out.Values[i] = ec._AssetGroup_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "groupName":
			out.Values[i] = ec._AssetGroup_groupName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "assets":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._AssetGroup_assets(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "displayName":
			out.Values[i] = ec._AssetGroup_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec._AssetGroup_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "status":
			out.Values[i] = ec._AssetGroup_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _AssetGroup_name(ctx context.Context, field graphql.CollectedField, obj *AssetGroup) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AssetGroup",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _AssetGroup_namespace(ctx context.Context, field graphql.CollectedField, obj *AssetGroup) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AssetGroup",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _AssetGroup_groupName(ctx context.Context, field graphql.CollectedField, obj *AssetGroup) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AssetGroup",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GroupName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _AssetGroup_assets(ctx context.Context, field graphql.CollectedField, obj *AssetGroup) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_AssetGroup_assets_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "AssetGroup",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.AssetGroup().Assets(rctx, obj, args["types"].([]string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]Asset)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Asset(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _AssetGroup_displayName(ctx context.Context, field graphql.CollectedField, obj *AssetGroup) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AssetGroup",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _AssetGroup_description(ctx context.Context, field graphql.CollectedField, obj *AssetGroup) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AssetGroup",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _AssetGroup_status(ctx context.Context, field graphql.CollectedField, obj *AssetGroup) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AssetGroup",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(AssetGroupStatus)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._AssetGroupStatus(ctx, field.Selections, &res)
}

var assetGroupEventImplementors = []string{"AssetGroupEvent"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _AssetGroupEvent(ctx context.Context, sel ast.SelectionSet, obj *AssetGroupEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, assetGroupEventImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AssetGroupEvent")
		case "type":
			out.Values[i] = ec._AssetGroupEvent_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "assetGroup":
			out.Values[i] = ec._AssetGroupEvent_assetGroup(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _AssetGroupEvent_type(ctx context.Context, field graphql.CollectedField, obj *AssetGroupEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AssetGroupEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SubscriptionEventType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _AssetGroupEvent_assetGroup(ctx context.Context, field graphql.CollectedField, obj *AssetGroupEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AssetGroupEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AssetGroup, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(AssetGroup)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._AssetGroup(ctx, field.Selections, &res)
}

var assetGroupStatusImplementors = []string{"AssetGroupStatus"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _AssetGroupStatus(ctx context.Context, sel ast.SelectionSet, obj *AssetGroupStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, assetGroupStatusImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AssetGroupStatus")
		case "phase":
			out.Values[i] = ec._AssetGroupStatus_phase(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "reason":
			out.Values[i] = ec._AssetGroupStatus_reason(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "message":
			out.Values[i] = ec._AssetGroupStatus_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _AssetGroupStatus_phase(ctx context.Context, field graphql.CollectedField, obj *AssetGroupStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AssetGroupStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Phase, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(AssetGroupPhaseType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _AssetGroupStatus_reason(ctx context.Context, field graphql.CollectedField, obj *AssetGroupStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AssetGroupStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reason, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _AssetGroupStatus_message(ctx context.Context, field graphql.CollectedField, obj *AssetGroupStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AssetGroupStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var assetStatusImplementors = []string{"AssetStatus"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _AssetStatus(ctx context.Context, sel ast.SelectionSet, obj *AssetStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, assetStatusImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AssetStatus")
		case "phase":
			out.Values[i] = ec._AssetStatus_phase(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "reason":
			out.Values[i] = ec._AssetStatus_reason(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "message":
			out.Values[i] = ec._AssetStatus_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _AssetStatus_phase(ctx context.Context, field graphql.CollectedField, obj *AssetStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AssetStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Phase, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(AssetPhaseType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _AssetStatus_reason(ctx context.Context, field graphql.CollectedField, obj *AssetStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AssetStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reason, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _AssetStatus_message(ctx context.Context, field graphql.CollectedField, obj *AssetStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AssetStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var backendModuleImplementors = []string{"BackendModule"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _BackendModule(ctx context.Context, sel ast.SelectionSet, obj *BackendModule) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, backendModuleImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BackendModule")
		case "name":
			out.Values[i] = ec._BackendModule_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _BackendModule_name(ctx context.Context, field graphql.CollectedField, obj *BackendModule) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "BackendModule",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var bindableResourcesOutputItemImplementors = []string{"BindableResourcesOutputItem"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _BindableResourcesOutputItem(ctx context.Context, sel ast.SelectionSet, obj *BindableResourcesOutputItem) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, bindableResourcesOutputItemImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BindableResourcesOutputItem")
		case "kind":
			out.Values[i] = ec._BindableResourcesOutputItem_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "displayName":
			out.Values[i] = ec._BindableResourcesOutputItem_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "resources":
			out.Values[i] = ec._BindableResourcesOutputItem_resources(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _BindableResourcesOutputItem_kind(ctx context.Context, field graphql.CollectedField, obj *BindableResourcesOutputItem) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "BindableResourcesOutputItem",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _BindableResourcesOutputItem_displayName(ctx context.Context, field graphql.CollectedField, obj *BindableResourcesOutputItem) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "BindableResourcesOutputItem",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _BindableResourcesOutputItem_resources(ctx context.Context, field graphql.CollectedField, obj *BindableResourcesOutputItem) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "BindableResourcesOutputItem",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Resources, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]UsageKindResource)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._UsageKindResource(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var clusterAddonsConfigurationEventImplementors = []string{"ClusterAddonsConfigurationEvent"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ClusterAddonsConfigurationEvent(ctx context.Context, sel ast.SelectionSet, obj *ClusterAddonsConfigurationEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, clusterAddonsConfigurationEventImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ClusterAddonsConfigurationEvent")
		case "type":
			out.Values[i] = ec._ClusterAddonsConfigurationEvent_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "addonsConfiguration":
			out.Values[i] = ec._ClusterAddonsConfigurationEvent_addonsConfiguration(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ClusterAddonsConfigurationEvent_type(ctx context.Context, field graphql.CollectedField, obj *ClusterAddonsConfigurationEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterAddonsConfigurationEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SubscriptionEventType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _ClusterAddonsConfigurationEvent_addonsConfiguration(ctx context.Context, field graphql.CollectedField, obj *ClusterAddonsConfigurationEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterAddonsConfigurationEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AddonsConfiguration, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(AddonsConfiguration)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._AddonsConfiguration(ctx, field.Selections, &res)
}

var clusterAssetImplementors = []string{"ClusterAsset"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ClusterAsset(ctx context.Context, sel ast.SelectionSet, obj *ClusterAsset) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, clusterAssetImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ClusterAsset")
		case "name":
			out.Values[i] = ec._ClusterAsset_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "parameters":
			out.Values[i] = ec._ClusterAsset_parameters(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "type":
			out.Values[i] = ec._ClusterAsset_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "files":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ClusterAsset_files(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "status":
			out.Values[i] = ec._ClusterAsset_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "displayName":
			out.Values[i] = ec._ClusterAsset_displayName(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ClusterAsset_name(ctx context.Context, field graphql.CollectedField, obj *ClusterAsset) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterAsset",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterAsset_parameters(ctx context.Context, field graphql.CollectedField, obj *ClusterAsset) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterAsset",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Parameters, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(JSON)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _ClusterAsset_type(ctx context.Context, field graphql.CollectedField, obj *ClusterAsset) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterAsset",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterAsset_files(ctx context.Context, field graphql.CollectedField, obj *ClusterAsset) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_ClusterAsset_files_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "ClusterAsset",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ClusterAsset().Files(rctx, obj, args["filterExtensions"].([]string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]File)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._File(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _ClusterAsset_status(ctx context.Context, field graphql.CollectedField, obj *ClusterAsset) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterAsset",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(AssetStatus)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._AssetStatus(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterAsset_displayName(ctx context.Context, field graphql.CollectedField, obj *ClusterAsset) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterAsset",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var clusterAssetEventImplementors = []string{"ClusterAssetEvent"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ClusterAssetEvent(ctx context.Context, sel ast.SelectionSet, obj *ClusterAssetEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, clusterAssetEventImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ClusterAssetEvent")
		case "type":
			out.Values[i] = ec._ClusterAssetEvent_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "clusterAsset":
			out.Values[i] = ec._ClusterAssetEvent_clusterAsset(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ClusterAssetEvent_type(ctx context.Context, field graphql.CollectedField, obj *ClusterAssetEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterAssetEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SubscriptionEventType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _ClusterAssetEvent_clusterAsset(ctx context.Context, field graphql.CollectedField, obj *ClusterAssetEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterAssetEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClusterAsset, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ClusterAsset)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ClusterAsset(ctx, field.Selections, &res)
}

var clusterAssetGroupImplementors = []string{"ClusterAssetGroup"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ClusterAssetGroup(ctx context.Context, sel ast.SelectionSet, obj *ClusterAssetGroup) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, clusterAssetGroupImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ClusterAssetGroup")
		case "name":
			out.Values[i] = ec._ClusterAssetGroup_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "groupName":
			out.Values[i] = ec._ClusterAssetGroup_groupName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "assets":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ClusterAssetGroup_assets(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "displayName":
			out.Values[i] = ec._ClusterAssetGroup_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec._ClusterAssetGroup_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "status":
			out.Values[i] = ec._ClusterAssetGroup_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ClusterAssetGroup_name(ctx context.Context, field graphql.CollectedField, obj *ClusterAssetGroup) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterAssetGroup",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterAssetGroup_groupName(ctx context.Context, field graphql.CollectedField, obj *ClusterAssetGroup) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterAssetGroup",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GroupName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterAssetGroup_assets(ctx context.Context, field graphql.CollectedField, obj *ClusterAssetGroup) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_ClusterAssetGroup_assets_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "ClusterAssetGroup",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ClusterAssetGroup().Assets(rctx, obj, args["types"].([]string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]ClusterAsset)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._ClusterAsset(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _ClusterAssetGroup_displayName(ctx context.Context, field graphql.CollectedField, obj *ClusterAssetGroup) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterAssetGroup",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterAssetGroup_description(ctx context.Context, field graphql.CollectedField, obj *ClusterAssetGroup) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterAssetGroup",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterAssetGroup_status(ctx context.Context, field graphql.CollectedField, obj *ClusterAssetGroup) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterAssetGroup",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(AssetGroupStatus)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._AssetGroupStatus(ctx, field.Selections, &res)
}

var clusterAssetGroupEventImplementors = []string{"ClusterAssetGroupEvent"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ClusterAssetGroupEvent(ctx context.Context, sel ast.SelectionSet, obj *ClusterAssetGroupEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, clusterAssetGroupEventImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ClusterAssetGroupEvent")
		case "type":
			out.Values[i] = ec._ClusterAssetGroupEvent_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "clusterAssetGroup":
			out.Values[i] = ec._ClusterAssetGroupEvent_clusterAssetGroup(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ClusterAssetGroupEvent_type(ctx context.Context, field graphql.CollectedField, obj *ClusterAssetGroupEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterAssetGroupEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SubscriptionEventType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _ClusterAssetGroupEvent_clusterAssetGroup(ctx context.Context, field graphql.CollectedField, obj *ClusterAssetGroupEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterAssetGroupEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClusterAssetGroup, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ClusterAssetGroup)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ClusterAssetGroup(ctx, field.Selections, &res)
}

var clusterMicroFrontendImplementors = []string{"ClusterMicroFrontend"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ClusterMicroFrontend(ctx context.Context, sel ast.SelectionSet, obj *ClusterMicroFrontend) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, clusterMicroFrontendImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ClusterMicroFrontend")
		case "name":
			out.Values[i] = ec._ClusterMicroFrontend_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "version":
			out.Values[i] = ec._ClusterMicroFrontend_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "category":
			out.Values[i] = ec._ClusterMicroFrontend_category(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "viewBaseUrl":
			out.Values[i] = ec._ClusterMicroFrontend_viewBaseUrl(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "placement":
			out.Values[i] = ec._ClusterMicroFrontend_placement(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "preloadUrl":
			out.Values[i] = ec._ClusterMicroFrontend_preloadUrl(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "navigationNodes":
			out.Values[i] = ec._ClusterMicroFrontend_navigationNodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ClusterMicroFrontend_name(ctx context.Context, field graphql.CollectedField, obj *ClusterMicroFrontend) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterMicroFrontend",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterMicroFrontend_version(ctx context.Context, field graphql.CollectedField, obj *ClusterMicroFrontend) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterMicroFrontend",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterMicroFrontend_category(ctx context.Context, field graphql.CollectedField, obj *ClusterMicroFrontend) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterMicroFrontend",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Category, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterMicroFrontend_viewBaseUrl(ctx context.Context, field graphql.CollectedField, obj *ClusterMicroFrontend) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterMicroFrontend",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ViewBaseURL, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterMicroFrontend_placement(ctx context.Context, field graphql.CollectedField, obj *ClusterMicroFrontend) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterMicroFrontend",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Placement, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterMicroFrontend_preloadUrl(ctx context.Context, field graphql.CollectedField, obj *ClusterMicroFrontend) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterMicroFrontend",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreloadURL, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterMicroFrontend_navigationNodes(ctx context.Context, field graphql.CollectedField, obj *ClusterMicroFrontend) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterMicroFrontend",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NavigationNodes, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]NavigationNode)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._NavigationNode(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var clusterServiceBrokerImplementors = []string{"ClusterServiceBroker"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ClusterServiceBroker(ctx context.Context, sel ast.SelectionSet, obj *ClusterServiceBroker) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, clusterServiceBrokerImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ClusterServiceBroker")
		case "name":
			out.Values[i] = ec._ClusterServiceBroker_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "status":
			out.Values[i] = ec._ClusterServiceBroker_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "creationTimestamp":
			out.Values[i] = ec._ClusterServiceBroker_creationTimestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "url":
			out.Values[i] = ec._ClusterServiceBroker_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "labels":
			out.Values[i] = ec._ClusterServiceBroker_labels(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServiceBroker_name(ctx context.Context, field graphql.CollectedField, obj *ClusterServiceBroker) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServiceBroker",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServiceBroker_status(ctx context.Context, field graphql.CollectedField, obj *ClusterServiceBroker) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServiceBroker",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ServiceBrokerStatus)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ServiceBrokerStatus(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServiceBroker_creationTimestamp(ctx context.Context, field graphql.CollectedField, obj *ClusterServiceBroker) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServiceBroker",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTimestamp, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return MarshalTimestamp(res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServiceBroker_url(ctx context.Context, field graphql.CollectedField, obj *ClusterServiceBroker) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServiceBroker",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServiceBroker_labels(ctx context.Context, field graphql.CollectedField, obj *ClusterServiceBroker) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServiceBroker",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Labels)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

var clusterServiceBrokerEventImplementors = []string{"ClusterServiceBrokerEvent"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ClusterServiceBrokerEvent(ctx context.Context, sel ast.SelectionSet, obj *ClusterServiceBrokerEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, clusterServiceBrokerEventImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ClusterServiceBrokerEvent")
		case "type":
			out.Values[i] = ec._ClusterServiceBrokerEvent_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "clusterServiceBroker":
			out.Values[i] = ec._ClusterServiceBrokerEvent_clusterServiceBroker(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServiceBrokerEvent_type(ctx context.Context, field graphql.CollectedField, obj *ClusterServiceBrokerEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServiceBrokerEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SubscriptionEventType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServiceBrokerEvent_clusterServiceBroker(ctx context.Context, field graphql.CollectedField, obj *ClusterServiceBrokerEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServiceBrokerEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClusterServiceBroker, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ClusterServiceBroker)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ClusterServiceBroker(ctx, field.Selections, &res)
}

var clusterServiceClassImplementors = []string{"ClusterServiceClass"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ClusterServiceClass(ctx context.Context, sel ast.SelectionSet, obj *ClusterServiceClass) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, clusterServiceClassImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ClusterServiceClass")
		case "name":
			out.Values[i] = ec._ClusterServiceClass_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "externalName":
			out.Values[i] = ec._ClusterServiceClass_externalName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "displayName":
			out.Values[i] = ec._ClusterServiceClass_displayName(ctx, field, obj)
		case "creationTimestamp":
			out.Values[i] = ec._ClusterServiceClass_creationTimestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec._ClusterServiceClass_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "longDescription":
			out.Values[i] = ec._ClusterServiceClass_longDescription(ctx, field, obj)
		case "imageUrl":
			out.Values[i] = ec._ClusterServiceClass_imageUrl(ctx, field, obj)
		case "documentationUrl":
			out.Values[i] = ec._ClusterServiceClass_documentationUrl(ctx, field, obj)
		case "supportUrl":
			out.Values[i] = ec._ClusterServiceClass_supportUrl(ctx, field, obj)
		case "providerDisplayName":
			out.Values[i] = ec._ClusterServiceClass_providerDisplayName(ctx, field, obj)
		case "tags":
			out.Values[i] = ec._ClusterServiceClass_tags(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "labels":
			out.Values[i] = ec._ClusterServiceClass_labels(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "plans":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ClusterServiceClass_plans(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "activated":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ClusterServiceClass_activated(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "instances":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ClusterServiceClass_instances(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "clusterAssetGroup":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ClusterServiceClass_clusterAssetGroup(ctx, field, obj)
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServiceClass_name(ctx context.Context, field graphql.CollectedField, obj *ClusterServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServiceClass_externalName(ctx context.Context, field graphql.CollectedField, obj *ClusterServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExternalName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServiceClass_displayName(ctx context.Context, field graphql.CollectedField, obj *ClusterServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServiceClass_creationTimestamp(ctx context.Context, field graphql.CollectedField, obj *ClusterServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTimestamp, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return MarshalTimestamp(res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServiceClass_description(ctx context.Context, field graphql.CollectedField, obj *ClusterServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServiceClass_longDescription(ctx context.Context, field graphql.CollectedField, obj *ClusterServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LongDescription, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServiceClass_imageUrl(ctx context.Context, field graphql.CollectedField, obj *ClusterServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImageURL, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServiceClass_documentationUrl(ctx context.Context, field graphql.CollectedField, obj *ClusterServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DocumentationURL, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServiceClass_supportUrl(ctx context.Context, field graphql.CollectedField, obj *ClusterServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SupportURL, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServiceClass_providerDisplayName(ctx context.Context, field graphql.CollectedField, obj *ClusterServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProviderDisplayName, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServiceClass_tags(ctx context.Context, field graphql.CollectedField, obj *ClusterServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tags, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return graphql.MarshalString(res[idx1])
		}()
	}

	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServiceClass_labels(ctx context.Context, field graphql.CollectedField, obj *ClusterServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Labels)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServiceClass_plans(ctx context.Context, field graphql.CollectedField, obj *ClusterServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ClusterServiceClass().Plans(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]ClusterServicePlan)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._ClusterServicePlan(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServiceClass_activated(ctx context.Context, field graphql.CollectedField, obj *ClusterServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_ClusterServiceClass_activated_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "ClusterServiceClass",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ClusterServiceClass().Activated(rctx, obj, args["namespace"].(*string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServiceClass_instances(ctx context.Context, field graphql.CollectedField, obj *ClusterServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_ClusterServiceClass_instances_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "ClusterServiceClass",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ClusterServiceClass().Instances(rctx, obj, args["namespace"].(*string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]ServiceInstance)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._ServiceInstance(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServiceClass_clusterAssetGroup(ctx context.Context, field graphql.CollectedField, obj *ClusterServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ClusterServiceClass().ClusterAssetGroup(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ClusterAssetGroup)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ClusterAssetGroup(ctx, field.Selections, res)
}

var clusterServicePlanImplementors = []string{"ClusterServicePlan"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ClusterServicePlan(ctx context.Context, sel ast.SelectionSet, obj *ClusterServicePlan) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, clusterServicePlanImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ClusterServicePlan")
		case "name":
			out.Values[i] = ec._ClusterServicePlan_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "displayName":
			out.Values[i] = ec._ClusterServicePlan_displayName(ctx, field, obj)
		case "externalName":
			out.Values[i] = ec._ClusterServicePlan_externalName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec._ClusterServicePlan_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "relatedClusterServiceClassName":
			out.Values[i] = ec._ClusterServicePlan_relatedClusterServiceClassName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "instanceCreateParameterSchema":
			out.Values[i] = ec._ClusterServicePlan_instanceCreateParameterSchema(ctx, field, obj)
		case "bindingCreateParameterSchema":
			out.Values[i] = ec._ClusterServicePlan_bindingCreateParameterSchema(ctx, field, obj)
		case "clusterAssetGroup":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ClusterServicePlan_clusterAssetGroup(ctx, field, obj)
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServicePlan_name(ctx context.Context, field graphql.CollectedField, obj *ClusterServicePlan) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServicePlan",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServicePlan_displayName(ctx context.Context, field graphql.CollectedField, obj *ClusterServicePlan) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServicePlan",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServicePlan_externalName(ctx context.Context, field graphql.CollectedField, obj *ClusterServicePlan) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServicePlan",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExternalName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServicePlan_description(ctx context.Context, field graphql.CollectedField, obj *ClusterServicePlan) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServicePlan",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServicePlan_relatedClusterServiceClassName(ctx context.Context, field graphql.CollectedField, obj *ClusterServicePlan) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServicePlan",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RelatedClusterServiceClassName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServicePlan_instanceCreateParameterSchema(ctx context.Context, field graphql.CollectedField, obj *ClusterServicePlan) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServicePlan",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InstanceCreateParameterSchema, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*JSON)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return *res
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServicePlan_bindingCreateParameterSchema(ctx context.Context, field graphql.CollectedField, obj *ClusterServicePlan) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServicePlan",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BindingCreateParameterSchema, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*JSON)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return *res
}

// nolint: vetshadow
func (ec *executionContext) _ClusterServicePlan_clusterAssetGroup(ctx context.Context, field graphql.CollectedField, obj *ClusterServicePlan) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ClusterServicePlan",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ClusterServicePlan().ClusterAssetGroup(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ClusterAssetGroup)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ClusterAssetGroup(ctx, field.Selections, res)
}

var configMapImplementors = []string{"ConfigMap"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ConfigMap(ctx context.Context, sel ast.SelectionSet, obj *ConfigMap) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, configMapImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ConfigMap")
		case "name":
			out.Values[i] = ec._ConfigMap_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "namespace":
			out.Values[i] = ec._ConfigMap_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "creationTimestamp":
			out.Values[i] = ec._ConfigMap_creationTimestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "labels":
			out.Values[i] = ec._ConfigMap_labels(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "json":
			out.Values[i] = ec._ConfigMap_json(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ConfigMap_name(ctx context.Context, field graphql.CollectedField, obj *ConfigMap) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ConfigMap",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ConfigMap_namespace(ctx context.Context, field graphql.CollectedField, obj *ConfigMap) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ConfigMap",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ConfigMap_creationTimestamp(ctx context.Context, field graphql.CollectedField, obj *ConfigMap) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ConfigMap",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTimestamp, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return MarshalTimestamp(res)
}

// nolint: vetshadow
func (ec *executionContext) _ConfigMap_labels(ctx context.Context, field graphql.CollectedField, obj *ConfigMap) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ConfigMap",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Labels)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _ConfigMap_json(ctx context.Context, field graphql.CollectedField, obj *ConfigMap) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ConfigMap",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JSON, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(JSON)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

var configMapEventImplementors = []string{"ConfigMapEvent"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ConfigMapEvent(ctx context.Context, sel ast.SelectionSet, obj *ConfigMapEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, configMapEventImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ConfigMapEvent")
		case "type":
			out.Values[i] = ec._ConfigMapEvent_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "configMap":
			out.Values[i] = ec._ConfigMapEvent_configMap(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ConfigMapEvent_type(ctx context.Context, field graphql.CollectedField, obj *ConfigMapEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ConfigMapEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SubscriptionEventType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _ConfigMapEvent_configMap(ctx context.Context, field graphql.CollectedField, obj *ConfigMapEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ConfigMapEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConfigMap, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ConfigMap)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ConfigMap(ctx, field.Selections, &res)
}

var connectorServiceImplementors = []string{"ConnectorService"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ConnectorService(ctx context.Context, sel ast.SelectionSet, obj *ConnectorService) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, connectorServiceImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ConnectorService")
		case "url":
			out.Values[i] = ec._ConnectorService_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ConnectorService_url(ctx context.Context, field graphql.CollectedField, obj *ConnectorService) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ConnectorService",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var containerImplementors = []string{"Container"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Container(ctx context.Context, sel ast.SelectionSet, obj *Container) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, containerImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Container")
		case "name":
			out.Values[i] = ec._Container_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "image":
			out.Values[i] = ec._Container_image(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Container_name(ctx context.Context, field graphql.CollectedField, obj *Container) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Container",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Container_image(ctx context.Context, field graphql.CollectedField, obj *Container) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Container",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Image, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var containerStateImplementors = []string{"ContainerState"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ContainerState(ctx context.Context, sel ast.SelectionSet, obj *ContainerState) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, containerStateImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ContainerState")
		case "state":
			out.Values[i] = ec._ContainerState_state(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "reason":
			out.Values[i] = ec._ContainerState_reason(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "message":
			out.Values[i] = ec._ContainerState_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ContainerState_state(ctx context.Context, field graphql.CollectedField, obj *ContainerState) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ContainerState",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.State, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ContainerStateType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _ContainerState_reason(ctx context.Context, field graphql.CollectedField, obj *ContainerState) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ContainerState",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reason, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ContainerState_message(ctx context.Context, field graphql.CollectedField, obj *ContainerState) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ContainerState",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var createServiceBindingOutputImplementors = []string{"CreateServiceBindingOutput"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _CreateServiceBindingOutput(ctx context.Context, sel ast.SelectionSet, obj *CreateServiceBindingOutput) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, createServiceBindingOutputImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreateServiceBindingOutput")
		case "name":
			out.Values[i] = ec._CreateServiceBindingOutput_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "serviceInstanceName":
			out.Values[i] = ec._CreateServiceBindingOutput_serviceInstanceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "namespace":
			out.Values[i] = ec._CreateServiceBindingOutput_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _CreateServiceBindingOutput_name(ctx context.Context, field graphql.CollectedField, obj *CreateServiceBindingOutput) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "CreateServiceBindingOutput",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _CreateServiceBindingOutput_serviceInstanceName(ctx context.Context, field graphql.CollectedField, obj *CreateServiceBindingOutput) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "CreateServiceBindingOutput",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServiceInstanceName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _CreateServiceBindingOutput_namespace(ctx context.Context, field graphql.CollectedField, obj *CreateServiceBindingOutput) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "CreateServiceBindingOutput",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var deleteApplicationOutputImplementors = []string{"DeleteApplicationOutput"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _DeleteApplicationOutput(ctx context.Context, sel ast.SelectionSet, obj *DeleteApplicationOutput) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, deleteApplicationOutputImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeleteApplicationOutput")
		case "name":
			out.Values[i] = ec._DeleteApplicationOutput_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _DeleteApplicationOutput_name(ctx context.Context, field graphql.CollectedField, obj *DeleteApplicationOutput) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "DeleteApplicationOutput",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var deleteServiceBindingOutputImplementors = []string{"DeleteServiceBindingOutput"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _DeleteServiceBindingOutput(ctx context.Context, sel ast.SelectionSet, obj *DeleteServiceBindingOutput) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, deleteServiceBindingOutputImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeleteServiceBindingOutput")
		case "name":
			out.Values[i] = ec._DeleteServiceBindingOutput_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "namespace":
			out.Values[i] = ec._DeleteServiceBindingOutput_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _DeleteServiceBindingOutput_name(ctx context.Context, field graphql.CollectedField, obj *DeleteServiceBindingOutput) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "DeleteServiceBindingOutput",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _DeleteServiceBindingOutput_namespace(ctx context.Context, field graphql.CollectedField, obj *DeleteServiceBindingOutput) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "DeleteServiceBindingOutput",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var deleteServiceBindingUsageOutputImplementors = []string{"DeleteServiceBindingUsageOutput"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _DeleteServiceBindingUsageOutput(ctx context.Context, sel ast.SelectionSet, obj *DeleteServiceBindingUsageOutput) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, deleteServiceBindingUsageOutputImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeleteServiceBindingUsageOutput")
		case "name":
			out.Values[i] = ec._DeleteServiceBindingUsageOutput_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "namespace":
			out.Values[i] = ec._DeleteServiceBindingUsageOutput_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _DeleteServiceBindingUsageOutput_name(ctx context.Context, field graphql.CollectedField, obj *DeleteServiceBindingUsageOutput) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "DeleteServiceBindingUsageOutput",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _DeleteServiceBindingUsageOutput_namespace(ctx context.Context, field graphql.CollectedField, obj *DeleteServiceBindingUsageOutput) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "DeleteServiceBindingUsageOutput",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var deploymentImplementors = []string{"Deployment"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Deployment(ctx context.Context, sel ast.SelectionSet, obj *Deployment) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, deploymentImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Deployment")
		case "name":
			out.Values[i] = ec._Deployment_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "namespace":
			out.Values[i] = ec._Deployment_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "creationTimestamp":
			out.Values[i] = ec._Deployment_creationTimestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "status":
			out.Values[i] = ec._Deployment_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "labels":
			out.Values[i] = ec._Deployment_labels(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "containers":
			out.Values[i] = ec._Deployment_containers(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "boundServiceInstanceNames":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Deployment_boundServiceInstanceNames(ctx, field, obj)
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Deployment_name(ctx context.Context, field graphql.CollectedField, obj *Deployment) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Deployment",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Deployment_namespace(ctx context.Context, field graphql.CollectedField, obj *Deployment) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Deployment",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Deployment_creationTimestamp(ctx context.Context, field graphql.CollectedField, obj *Deployment) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Deployment",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTimestamp, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return MarshalTimestamp(res)
}

// nolint: vetshadow
func (ec *executionContext) _Deployment_status(ctx context.Context, field graphql.CollectedField, obj *Deployment) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Deployment",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(DeploymentStatus)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._DeploymentStatus(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Deployment_labels(ctx context.Context, field graphql.CollectedField, obj *Deployment) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Deployment",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Labels)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _Deployment_containers(ctx context.Context, field graphql.CollectedField, obj *Deployment) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Deployment",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Containers, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]Container)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Container(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Deployment_boundServiceInstanceNames(ctx context.Context, field graphql.CollectedField, obj *Deployment) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Deployment",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Deployment().BoundServiceInstanceNames(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return graphql.MarshalString(res[idx1])
		}()
	}

	return arr1
}

var deploymentConditionImplementors = []string{"DeploymentCondition"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _DeploymentCondition(ctx context.Context, sel ast.SelectionSet, obj *DeploymentCondition) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, deploymentConditionImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeploymentCondition")
		case "status":
			out.Values[i] = ec._DeploymentCondition_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "type":
			out.Values[i] = ec._DeploymentCondition_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "lastTransitionTimestamp":
			out.Values[i] = ec._DeploymentCondition_lastTransitionTimestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "lastUpdateTimestamp":
			out.Values[i] = ec._DeploymentCondition_lastUpdateTimestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "message":
			out.Values[i] = ec._DeploymentCondition_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "reason":
			out.Values[i] = ec._DeploymentCondition_reason(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _DeploymentCondition_status(ctx context.Context, field graphql.CollectedField, obj *DeploymentCondition) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "DeploymentCondition",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _DeploymentCondition_type(ctx context.Context, field graphql.CollectedField, obj *DeploymentCondition) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "DeploymentCondition",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _DeploymentCondition_lastTransitionTimestamp(ctx context.Context, field graphql.CollectedField, obj *DeploymentCondition) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "DeploymentCondition",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastTransitionTimestamp, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return MarshalTimestamp(res)
}

// nolint: vetshadow
func (ec *executionContext) _DeploymentCondition_lastUpdateTimestamp(ctx context.Context, field graphql.CollectedField, obj *DeploymentCondition) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "DeploymentCondition",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastUpdateTimestamp, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return MarshalTimestamp(res)
}

// nolint: vetshadow
func (ec *executionContext) _DeploymentCondition_message(ctx context.Context, field graphql.CollectedField, obj *DeploymentCondition) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "DeploymentCondition",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _DeploymentCondition_reason(ctx context.Context, field graphql.CollectedField, obj *DeploymentCondition) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "DeploymentCondition",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reason, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var deploymentStatusImplementors = []string{"DeploymentStatus"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _DeploymentStatus(ctx context.Context, sel ast.SelectionSet, obj *DeploymentStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, deploymentStatusImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeploymentStatus")
		case "replicas":
			out.Values[i] = ec._DeploymentStatus_replicas(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "updatedReplicas":
			out.Values[i] = ec._DeploymentStatus_updatedReplicas(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "readyReplicas":
			out.Values[i] = ec._DeploymentStatus_readyReplicas(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "availableReplicas":
			out.Values[i] = ec._DeploymentStatus_availableReplicas(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "conditions":
			out.Values[i] = ec._DeploymentStatus_conditions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _DeploymentStatus_replicas(ctx context.Context, field graphql.CollectedField, obj *DeploymentStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "DeploymentStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Replicas, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

// nolint: vetshadow
func (ec *executionContext) _DeploymentStatus_updatedReplicas(ctx context.Context, field graphql.CollectedField, obj *DeploymentStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "DeploymentStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedReplicas, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

// nolint: vetshadow
func (ec *executionContext) _DeploymentStatus_readyReplicas(ctx context.Context, field graphql.CollectedField, obj *DeploymentStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "DeploymentStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReadyReplicas, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

// nolint: vetshadow
func (ec *executionContext) _DeploymentStatus_availableReplicas(ctx context.Context, field graphql.CollectedField, obj *DeploymentStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "DeploymentStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AvailableReplicas, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

// nolint: vetshadow
func (ec *executionContext) _DeploymentStatus_conditions(ctx context.Context, field graphql.CollectedField, obj *DeploymentStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "DeploymentStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Conditions, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]DeploymentCondition)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._DeploymentCondition(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var enabledApplicationServiceImplementors = []string{"EnabledApplicationService"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _EnabledApplicationService(ctx context.Context, sel ast.SelectionSet, obj *EnabledApplicationService) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, enabledApplicationServiceImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EnabledApplicationService")
		case "id":
			out.Values[i] = ec._EnabledApplicationService_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "displayName":
			out.Values[i] = ec._EnabledApplicationService_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "exist":
			out.Values[i] = ec._EnabledApplicationService_exist(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _EnabledApplicationService_id(ctx context.Context, field graphql.CollectedField, obj *EnabledApplicationService) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "EnabledApplicationService",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _EnabledApplicationService_displayName(ctx context.Context, field graphql.CollectedField, obj *EnabledApplicationService) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "EnabledApplicationService",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _EnabledApplicationService_exist(ctx context.Context, field graphql.CollectedField, obj *EnabledApplicationService) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "EnabledApplicationService",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Exist, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

var envPrefixImplementors = []string{"EnvPrefix"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _EnvPrefix(ctx context.Context, sel ast.SelectionSet, obj *EnvPrefix) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, envPrefixImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EnvPrefix")
		case "name":
			out.Values[i] = ec._EnvPrefix_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _EnvPrefix_name(ctx context.Context, field graphql.CollectedField, obj *EnvPrefix) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "EnvPrefix",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var eventActivationImplementors = []string{"EventActivation"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _EventActivation(ctx context.Context, sel ast.SelectionSet, obj *EventActivation) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, eventActivationImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EventActivation")
		case "name":
			out.Values[i] = ec._EventActivation_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "displayName":
			out.Values[i] = ec._EventActivation_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "sourceId":
			out.Values[i] = ec._EventActivation_sourceId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "events":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._EventActivation_events(ctx, field, obj)
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _EventActivation_name(ctx context.Context, field graphql.CollectedField, obj *EventActivation) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "EventActivation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _EventActivation_displayName(ctx context.Context, field graphql.CollectedField, obj *EventActivation) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "EventActivation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _EventActivation_sourceId(ctx context.Context, field graphql.CollectedField, obj *EventActivation) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "EventActivation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SourceID, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _EventActivation_events(ctx context.Context, field graphql.CollectedField, obj *EventActivation) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "EventActivation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.EventActivation().Events(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]EventActivationEvent)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._EventActivationEvent(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var eventActivationEventImplementors = []string{"EventActivationEvent"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _EventActivationEvent(ctx context.Context, sel ast.SelectionSet, obj *EventActivationEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, eventActivationEventImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EventActivationEvent")
		case "eventType":
			out.Values[i] = ec._EventActivationEvent_eventType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "version":
			out.Values[i] = ec._EventActivationEvent_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec._EventActivationEvent_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "schema":
			out.Values[i] = ec._EventActivationEvent_schema(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _EventActivationEvent_eventType(ctx context.Context, field graphql.CollectedField, obj *EventActivationEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "EventActivationEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventType, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _EventActivationEvent_version(ctx context.Context, field graphql.CollectedField, obj *EventActivationEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "EventActivationEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _EventActivationEvent_description(ctx context.Context, field graphql.CollectedField, obj *EventActivationEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "EventActivationEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _EventActivationEvent_schema(ctx context.Context, field graphql.CollectedField, obj *EventActivationEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "EventActivationEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Schema, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(JSON)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

var exceededQuotaImplementors = []string{"ExceededQuota"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ExceededQuota(ctx context.Context, sel ast.SelectionSet, obj *ExceededQuota) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, exceededQuotaImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ExceededQuota")
		case "quotaName":
			out.Values[i] = ec._ExceededQuota_quotaName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "resourceName":
			out.Values[i] = ec._ExceededQuota_resourceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "affectedResources":
			out.Values[i] = ec._ExceededQuota_affectedResources(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ExceededQuota_quotaName(ctx context.Context, field graphql.CollectedField, obj *ExceededQuota) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ExceededQuota",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QuotaName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ExceededQuota_resourceName(ctx context.Context, field graphql.CollectedField, obj *ExceededQuota) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ExceededQuota",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ExceededQuota_affectedResources(ctx context.Context, field graphql.CollectedField, obj *ExceededQuota) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ExceededQuota",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AffectedResources, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return graphql.MarshalString(res[idx1])
		}()
	}

	return arr1
}

var fileImplementors = []string{"File"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _File(ctx context.Context, sel ast.SelectionSet, obj *File) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, fileImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("File")
		case "url":
			out.Values[i] = ec._File_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "metadata":
			out.Values[i] = ec._File_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _File_url(ctx context.Context, field graphql.CollectedField, obj *File) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "File",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _File_metadata(ctx context.Context, field graphql.CollectedField, obj *File) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "File",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metadata, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(JSON)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

var functionImplementors = []string{"Function"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Function(ctx context.Context, sel ast.SelectionSet, obj *Function) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, functionImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Function")
		case "name":
			out.Values[i] = ec._Function_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "namespace":
			out.Values[i] = ec._Function_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "UID":
			out.Values[i] = ec._Function_UID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "labels":
			out.Values[i] = ec._Function_labels(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "source":
			out.Values[i] = ec._Function_source(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "dependencies":
			out.Values[i] = ec._Function_dependencies(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "env":
			out.Values[i] = ec._Function_env(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "replicas":
			out.Values[i] = ec._Function_replicas(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "resources":
			out.Values[i] = ec._Function_resources(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "status":
			out.Values[i] = ec._Function_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Function_name(ctx context.Context, field graphql.CollectedField, obj *Function) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Function",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Function_namespace(ctx context.Context, field graphql.CollectedField, obj *Function) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Function",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Function_UID(ctx context.Context, field graphql.CollectedField, obj *Function) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Function",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UID, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Function_labels(ctx context.Context, field graphql.CollectedField, obj *Function) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Function",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Labels)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _Function_source(ctx context.Context, field graphql.CollectedField, obj *Function) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Function",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Source, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Function_dependencies(ctx context.Context, field graphql.CollectedField, obj *Function) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Function",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dependencies, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Function_env(ctx context.Context, field graphql.CollectedField, obj *Function) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Function",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Env, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]FunctionEnv)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._FunctionEnv(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Function_replicas(ctx context.Context, field graphql.CollectedField, obj *Function) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Function",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Replicas, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(FunctionReplicas)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._FunctionReplicas(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Function_resources(ctx context.Context, field graphql.CollectedField, obj *Function) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Function",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Resources, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(FunctionResources)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._FunctionResources(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Function_status(ctx context.Context, field graphql.CollectedField, obj *Function) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Function",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(FunctionStatus)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._FunctionStatus(ctx, field.Selections, &res)
}

var functionEnvImplementors = []string{"FunctionEnv"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _FunctionEnv(ctx context.Context, sel ast.SelectionSet, obj *FunctionEnv) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, functionEnvImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FunctionEnv")
		case "name":
			out.Values[i] = ec._FunctionEnv_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "value":
			out.Values[i] = ec._FunctionEnv_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "valueFrom":
			out.Values[i] = ec._FunctionEnv_valueFrom(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _FunctionEnv_name(ctx context.Context, field graphql.CollectedField, obj *FunctionEnv) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "FunctionEnv",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _FunctionEnv_value(ctx context.Context, field graphql.CollectedField, obj *FunctionEnv) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "FunctionEnv",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _FunctionEnv_valueFrom(ctx context.Context, field graphql.CollectedField, obj *FunctionEnv) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "FunctionEnv",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ValueFrom, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*FunctionEnvValueFrom)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._FunctionEnvValueFrom(ctx, field.Selections, res)
}

var functionEnvValueFromImplementors = []string{"FunctionEnvValueFrom"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _FunctionEnvValueFrom(ctx context.Context, sel ast.SelectionSet, obj *FunctionEnvValueFrom) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, functionEnvValueFromImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FunctionEnvValueFrom")
		case "type":
			out.Values[i] = ec._FunctionEnvValueFrom_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "name":
			out.Values[i] = ec._FunctionEnvValueFrom_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "key":
			out.Values[i] = ec._FunctionEnvValueFrom_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "optional":
			out.Values[i] = ec._FunctionEnvValueFrom_optional(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _FunctionEnvValueFrom_type(ctx context.Context, field graphql.CollectedField, obj *FunctionEnvValueFrom) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "FunctionEnvValueFrom",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(FunctionEnvValueFromType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _FunctionEnvValueFrom_name(ctx context.Context, field graphql.CollectedField, obj *FunctionEnvValueFrom) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "FunctionEnvValueFrom",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _FunctionEnvValueFrom_key(ctx context.Context, field graphql.CollectedField, obj *FunctionEnvValueFrom) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "FunctionEnvValueFrom",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _FunctionEnvValueFrom_optional(ctx context.Context, field graphql.CollectedField, obj *FunctionEnvValueFrom) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "FunctionEnvValueFrom",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Optional, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalBoolean(*res)
}

var functionEventImplementors = []string{"FunctionEvent"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _FunctionEvent(ctx context.Context, sel ast.SelectionSet, obj *FunctionEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, functionEventImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FunctionEvent")
		case "type":
			out.Values[i] = ec._FunctionEvent_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "function":
			out.Values[i] = ec._FunctionEvent_function(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _FunctionEvent_type(ctx context.Context, field graphql.CollectedField, obj *FunctionEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "FunctionEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SubscriptionEventType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _FunctionEvent_function(ctx context.Context, field graphql.CollectedField, obj *FunctionEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "FunctionEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Function, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Function)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Function(ctx, field.Selections, &res)
}

var functionMetadataImplementors = []string{"FunctionMetadata"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _FunctionMetadata(ctx context.Context, sel ast.SelectionSet, obj *FunctionMetadata) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, functionMetadataImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FunctionMetadata")
		case "name":
			out.Values[i] = ec._FunctionMetadata_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "namespace":
			out.Values[i] = ec._FunctionMetadata_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _FunctionMetadata_name(ctx context.Context, field graphql.CollectedField, obj *FunctionMetadata) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "FunctionMetadata",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _FunctionMetadata_namespace(ctx context.Context, field graphql.CollectedField, obj *FunctionMetadata) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "FunctionMetadata",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var functionReplicasImplementors = []string{"FunctionReplicas"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _FunctionReplicas(ctx context.Context, sel ast.SelectionSet, obj *FunctionReplicas) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, functionReplicasImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FunctionReplicas")
		case "min":
			out.Values[i] = ec._FunctionReplicas_min(ctx, field, obj)
		case "max":
			out.Values[i] = ec._FunctionReplicas_max(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _FunctionReplicas_min(ctx context.Context, field graphql.CollectedField, obj *FunctionReplicas) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "FunctionReplicas",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Min, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalInt(*res)
}

// nolint: vetshadow
func (ec *executionContext) _FunctionReplicas_max(ctx context.Context, field graphql.CollectedField, obj *FunctionReplicas) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "FunctionReplicas",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Max, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalInt(*res)
}

var functionResourcesImplementors = []string{"FunctionResources"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _FunctionResources(ctx context.Context, sel ast.SelectionSet, obj *FunctionResources) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, functionResourcesImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FunctionResources")
		case "limits":
			out.Values[i] = ec._FunctionResources_limits(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "requests":
			out.Values[i] = ec._FunctionResources_requests(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _FunctionResources_limits(ctx context.Context, field graphql.CollectedField, obj *FunctionResources) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "FunctionResources",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Limits, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ResourceValues)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ResourceValues(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _FunctionResources_requests(ctx context.Context, field graphql.CollectedField, obj *FunctionResources) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "FunctionResources",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Requests, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ResourceValues)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ResourceValues(ctx, field.Selections, &res)
}

var functionStatusImplementors = []string{"FunctionStatus"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _FunctionStatus(ctx context.Context, sel ast.SelectionSet, obj *FunctionStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, functionStatusImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FunctionStatus")
		case "phase":
			out.Values[i] = ec._FunctionStatus_phase(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "reason":
			out.Values[i] = ec._FunctionStatus_reason(ctx, field, obj)
		case "message":
			out.Values[i] = ec._FunctionStatus_message(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _FunctionStatus_phase(ctx context.Context, field graphql.CollectedField, obj *FunctionStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "FunctionStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Phase, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(FunctionPhaseType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _FunctionStatus_reason(ctx context.Context, field graphql.CollectedField, obj *FunctionStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "FunctionStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reason, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*FunctionReasonType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return *res
}

// nolint: vetshadow
func (ec *executionContext) _FunctionStatus_message(ctx context.Context, field graphql.CollectedField, obj *FunctionStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "FunctionStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var iDPPresetImplementors = []string{"IDPPreset"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _IDPPreset(ctx context.Context, sel ast.SelectionSet, obj *IDPPreset) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, iDPPresetImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("IDPPreset")
		case "name":
			out.Values[i] = ec._IDPPreset_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "issuer":
			out.Values[i] = ec._IDPPreset_issuer(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "jwksUri":
			out.Values[i] = ec._IDPPreset_jwksUri(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _IDPPreset_name(ctx context.Context, field graphql.CollectedField, obj *IDPPreset) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "IDPPreset",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _IDPPreset_issuer(ctx context.Context, field graphql.CollectedField, obj *IDPPreset) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "IDPPreset",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Issuer, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _IDPPreset_jwksUri(ctx context.Context, field graphql.CollectedField, obj *IDPPreset) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "IDPPreset",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JwksURI, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var limitRangeImplementors = []string{"LimitRange"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _LimitRange(ctx context.Context, sel ast.SelectionSet, obj *LimitRange) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, limitRangeImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LimitRange")
		case "name":
			out.Values[i] = ec._LimitRange_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "limits":
			out.Values[i] = ec._LimitRange_limits(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _LimitRange_name(ctx context.Context, field graphql.CollectedField, obj *LimitRange) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "LimitRange",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _LimitRange_limits(ctx context.Context, field graphql.CollectedField, obj *LimitRange) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "LimitRange",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Limits, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]LimitRangeItem)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._LimitRangeItem(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var limitRangeItemImplementors = []string{"LimitRangeItem"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _LimitRangeItem(ctx context.Context, sel ast.SelectionSet, obj *LimitRangeItem) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, limitRangeItemImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LimitRangeItem")
		case "limitType":
			out.Values[i] = ec._LimitRangeItem_limitType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "max":
			out.Values[i] = ec._LimitRangeItem_max(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "default":
			out.Values[i] = ec._LimitRangeItem_default(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "defaultRequest":
			out.Values[i] = ec._LimitRangeItem_defaultRequest(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _LimitRangeItem_limitType(ctx context.Context, field graphql.CollectedField, obj *LimitRangeItem) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "LimitRangeItem",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LimitType, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(LimitType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _LimitRangeItem_max(ctx context.Context, field graphql.CollectedField, obj *LimitRangeItem) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "LimitRangeItem",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Max, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ResourceType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ResourceType(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _LimitRangeItem_default(ctx context.Context, field graphql.CollectedField, obj *LimitRangeItem) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "LimitRangeItem",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Default, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ResourceType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ResourceType(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _LimitRangeItem_defaultRequest(ctx context.Context, field graphql.CollectedField, obj *LimitRangeItem) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "LimitRangeItem",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultRequest, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ResourceType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ResourceType(ctx, field.Selections, &res)
}

var loadBalancerIngressImplementors = []string{"LoadBalancerIngress"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _LoadBalancerIngress(ctx context.Context, sel ast.SelectionSet, obj *LoadBalancerIngress) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, loadBalancerIngressImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LoadBalancerIngress")
		case "ip":
			out.Values[i] = ec._LoadBalancerIngress_ip(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "hostName":
			out.Values[i] = ec._LoadBalancerIngress_hostName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _LoadBalancerIngress_ip(ctx context.Context, field graphql.CollectedField, obj *LoadBalancerIngress) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "LoadBalancerIngress",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IP, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _LoadBalancerIngress_hostName(ctx context.Context, field graphql.CollectedField, obj *LoadBalancerIngress) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "LoadBalancerIngress",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HostName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var loadBalancerStatusImplementors = []string{"LoadBalancerStatus"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _LoadBalancerStatus(ctx context.Context, sel ast.SelectionSet, obj *LoadBalancerStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, loadBalancerStatusImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LoadBalancerStatus")
		case "ingress":
			out.Values[i] = ec._LoadBalancerStatus_ingress(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _LoadBalancerStatus_ingress(ctx context.Context, field graphql.CollectedField, obj *LoadBalancerStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "LoadBalancerStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ingress, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]LoadBalancerIngress)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._LoadBalancerIngress(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var localObjectReferenceImplementors = []string{"LocalObjectReference"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _LocalObjectReference(ctx context.Context, sel ast.SelectionSet, obj *LocalObjectReference) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, localObjectReferenceImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LocalObjectReference")
		case "kind":
			out.Values[i] = ec._LocalObjectReference_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "name":
			out.Values[i] = ec._LocalObjectReference_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _LocalObjectReference_kind(ctx context.Context, field graphql.CollectedField, obj *LocalObjectReference) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "LocalObjectReference",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _LocalObjectReference_name(ctx context.Context, field graphql.CollectedField, obj *LocalObjectReference) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "LocalObjectReference",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var microFrontendImplementors = []string{"MicroFrontend"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _MicroFrontend(ctx context.Context, sel ast.SelectionSet, obj *MicroFrontend) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, microFrontendImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MicroFrontend")
		case "name":
			out.Values[i] = ec._MicroFrontend_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "version":
			out.Values[i] = ec._MicroFrontend_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "category":
			out.Values[i] = ec._MicroFrontend_category(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "viewBaseUrl":
			out.Values[i] = ec._MicroFrontend_viewBaseUrl(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "navigationNodes":
			out.Values[i] = ec._MicroFrontend_navigationNodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _MicroFrontend_name(ctx context.Context, field graphql.CollectedField, obj *MicroFrontend) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "MicroFrontend",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _MicroFrontend_version(ctx context.Context, field graphql.CollectedField, obj *MicroFrontend) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "MicroFrontend",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _MicroFrontend_category(ctx context.Context, field graphql.CollectedField, obj *MicroFrontend) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "MicroFrontend",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Category, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _MicroFrontend_viewBaseUrl(ctx context.Context, field graphql.CollectedField, obj *MicroFrontend) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "MicroFrontend",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ViewBaseURL, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _MicroFrontend_navigationNodes(ctx context.Context, field graphql.CollectedField, obj *MicroFrontend) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "MicroFrontend",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NavigationNodes, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]NavigationNode)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._NavigationNode(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var mutationImplementors = []string{"Mutation"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, mutationImplementors)

	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Mutation",
	})

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "createResource":
			out.Values[i] = ec._Mutation_createResource(ctx, field)
		case "createServiceInstance":
			out.Values[i] = ec._Mutation_createServiceInstance(ctx, field)
		case "deleteServiceInstance":
			out.Values[i] = ec._Mutation_deleteServiceInstance(ctx, field)
		case "createServiceBinding":
			out.Values[i] = ec._Mutation_createServiceBinding(ctx, field)
		case "deleteServiceBinding":
			out.Values[i] = ec._Mutation_deleteServiceBinding(ctx, field)
		case "createServiceBindingUsage":
			out.Values[i] = ec._Mutation_createServiceBindingUsage(ctx, field)
		case "deleteServiceBindingUsage":
			out.Values[i] = ec._Mutation_deleteServiceBindingUsage(ctx, field)
		case "deleteServiceBindingUsages":
			out.Values[i] = ec._Mutation_deleteServiceBindingUsages(ctx, field)
		case "createClusterAddonsConfiguration":
			out.Values[i] = ec._Mutation_createClusterAddonsConfiguration(ctx, field)
		case "updateClusterAddonsConfiguration":
			out.Values[i] = ec._Mutation_updateClusterAddonsConfiguration(ctx, field)
		case "deleteClusterAddonsConfiguration":
			out.Values[i] = ec._Mutation_deleteClusterAddonsConfiguration(ctx, field)
		case "addClusterAddonsConfigurationURLs":
			out.Values[i] = ec._Mutation_addClusterAddonsConfigurationURLs(ctx, field)
		case "removeClusterAddonsConfigurationURLs":
			out.Values[i] = ec._Mutation_removeClusterAddonsConfigurationURLs(ctx, field)
		case "addClusterAddonsConfigurationRepository":
			out.Values[i] = ec._Mutation_addClusterAddonsConfigurationRepository(ctx, field)
		case "removeClusterAddonsConfigurationRepository":
			out.Values[i] = ec._Mutation_removeClusterAddonsConfigurationRepository(ctx, field)
		case "resyncClusterAddonsConfiguration":
			out.Values[i] = ec._Mutation_resyncClusterAddonsConfiguration(ctx, field)
		case "createAddonsConfiguration":
			out.Values[i] = ec._Mutation_createAddonsConfiguration(ctx, field)
		case "updateAddonsConfiguration":
			out.Values[i] = ec._Mutation_updateAddonsConfiguration(ctx, field)
		case "deleteAddonsConfiguration":
			out.Values[i] = ec._Mutation_deleteAddonsConfiguration(ctx, field)
		case "addAddonsConfigurationURLs":
			out.Values[i] = ec._Mutation_addAddonsConfigurationURLs(ctx, field)
		case "removeAddonsConfigurationURLs":
			out.Values[i] = ec._Mutation_removeAddonsConfigurationURLs(ctx, field)
		case "addAddonsConfigurationRepository":
			out.Values[i] = ec._Mutation_addAddonsConfigurationRepository(ctx, field)
		case "removeAddonsConfigurationRepository":
			out.Values[i] = ec._Mutation_removeAddonsConfigurationRepository(ctx, field)
		case "resyncAddonsConfiguration":
			out.Values[i] = ec._Mutation_resyncAddonsConfiguration(ctx, field)
		case "createApplication":
			out.Values[i] = ec._Mutation_createApplication(ctx, field)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "updateApplication":
			out.Values[i] = ec._Mutation_updateApplication(ctx, field)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "deleteApplication":
			out.Values[i] = ec._Mutation_deleteApplication(ctx, field)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "enableApplication":
			out.Values[i] = ec._Mutation_enableApplication(ctx, field)
		case "overloadApplication":
			out.Values[i] = ec._Mutation_overloadApplication(ctx, field)
		case "disableApplication":
			out.Values[i] = ec._Mutation_disableApplication(ctx, field)
		case "updatePod":
			out.Values[i] = ec._Mutation_updatePod(ctx, field)
		case "deletePod":
			out.Values[i] = ec._Mutation_deletePod(ctx, field)
		case "updateSecret":
			out.Values[i] = ec._Mutation_updateSecret(ctx, field)
		case "deleteSecret":
			out.Values[i] = ec._Mutation_deleteSecret(ctx, field)
		case "updateReplicaSet":
			out.Values[i] = ec._Mutation_updateReplicaSet(ctx, field)
		case "deleteReplicaSet":
			out.Values[i] = ec._Mutation_deleteReplicaSet(ctx, field)
		case "createResourceQuota":
			out.Values[i] = ec._Mutation_createResourceQuota(ctx, field)
		case "updateConfigMap":
			out.Values[i] = ec._Mutation_updateConfigMap(ctx, field)
		case "deleteConfigMap":
			out.Values[i] = ec._Mutation_deleteConfigMap(ctx, field)
		case "createIDPPreset":
			out.Values[i] = ec._Mutation_createIDPPreset(ctx, field)
		case "deleteIDPPreset":
			out.Values[i] = ec._Mutation_deleteIDPPreset(ctx, field)
		case "updateService":
			out.Values[i] = ec._Mutation_updateService(ctx, field)
		case "deleteService":
			out.Values[i] = ec._Mutation_deleteService(ctx, field)
		case "createNamespace":
			out.Values[i] = ec._Mutation_createNamespace(ctx, field)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "updateNamespace":
			out.Values[i] = ec._Mutation_updateNamespace(ctx, field)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "deleteNamespace":
			out.Values[i] = ec._Mutation_deleteNamespace(ctx, field)
		case "createAPIRule":
			out.Values[i] = ec._Mutation_createAPIRule(ctx, field)
		case "updateAPIRule":
			out.Values[i] = ec._Mutation_updateAPIRule(ctx, field)
		case "deleteAPIRule":
			out.Values[i] = ec._Mutation_deleteAPIRule(ctx, field)
		case "createLimitRange":
			out.Values[i] = ec._Mutation_createLimitRange(ctx, field)
		case "createFunction":
			out.Values[i] = ec._Mutation_createFunction(ctx, field)
		case "updateFunction":
			out.Values[i] = ec._Mutation_updateFunction(ctx, field)
		case "deleteFunction":
			out.Values[i] = ec._Mutation_deleteFunction(ctx, field)
		case "deleteManyFunctions":
			out.Values[i] = ec._Mutation_deleteManyFunctions(ctx, field)
		case "createTrigger":
			out.Values[i] = ec._Mutation_createTrigger(ctx, field)
		case "createManyTriggers":
			out.Values[i] = ec._Mutation_createManyTriggers(ctx, field)
		case "deleteTrigger":
			out.Values[i] = ec._Mutation_deleteTrigger(ctx, field)
		case "deleteManyTriggers":
			out.Values[i] = ec._Mutation_deleteManyTriggers(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_createResource(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_createResource_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateResource(rctx, args["namespace"].(string), args["resource"].(JSON))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*JSON)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return *res
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_createServiceInstance(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_createServiceInstance_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateServiceInstance(rctx, args["namespace"].(string), args["params"].(ServiceInstanceCreateInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ServiceInstance)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ServiceInstance(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_deleteServiceInstance(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_deleteServiceInstance_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteServiceInstance(rctx, args["name"].(string), args["namespace"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ServiceInstance)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ServiceInstance(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_createServiceBinding(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_createServiceBinding_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateServiceBinding(rctx, args["serviceBindingName"].(*string), args["serviceInstanceName"].(string), args["namespace"].(string), args["parameters"].(*JSON))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*CreateServiceBindingOutput)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._CreateServiceBindingOutput(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_deleteServiceBinding(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_deleteServiceBinding_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteServiceBinding(rctx, args["serviceBindingName"].(string), args["namespace"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*DeleteServiceBindingOutput)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._DeleteServiceBindingOutput(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_createServiceBindingUsage(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_createServiceBindingUsage_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateServiceBindingUsage(rctx, args["namespace"].(string), args["createServiceBindingUsageInput"].(*CreateServiceBindingUsageInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ServiceBindingUsage)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ServiceBindingUsage(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_deleteServiceBindingUsage(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_deleteServiceBindingUsage_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteServiceBindingUsage(rctx, args["serviceBindingUsageName"].(string), args["namespace"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*DeleteServiceBindingUsageOutput)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._DeleteServiceBindingUsageOutput(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_deleteServiceBindingUsages(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_deleteServiceBindingUsages_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteServiceBindingUsages(rctx, args["serviceBindingUsageNames"].([]string), args["namespace"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*DeleteServiceBindingUsageOutput)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				if res[idx1] == nil {
					return graphql.Null
				}

				return ec._DeleteServiceBindingUsageOutput(ctx, field.Selections, res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_createClusterAddonsConfiguration(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_createClusterAddonsConfiguration_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateClusterAddonsConfiguration(rctx, args["name"].(string), args["repositories"].([]AddonsConfigurationRepositoryInput), args["urls"].([]string), args["labels"].(*Labels))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*AddonsConfiguration)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._AddonsConfiguration(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_updateClusterAddonsConfiguration(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_updateClusterAddonsConfiguration_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateClusterAddonsConfiguration(rctx, args["name"].(string), args["repositories"].([]AddonsConfigurationRepositoryInput), args["urls"].([]string), args["labels"].(*Labels))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*AddonsConfiguration)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._AddonsConfiguration(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_deleteClusterAddonsConfiguration(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_deleteClusterAddonsConfiguration_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteClusterAddonsConfiguration(rctx, args["name"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*AddonsConfiguration)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._AddonsConfiguration(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_addClusterAddonsConfigurationURLs(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_addClusterAddonsConfigurationURLs_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AddClusterAddonsConfigurationURLs(rctx, args["name"].(string), args["urls"].([]string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*AddonsConfiguration)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._AddonsConfiguration(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_removeClusterAddonsConfigurationURLs(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_removeClusterAddonsConfigurationURLs_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RemoveClusterAddonsConfigurationURLs(rctx, args["name"].(string), args["urls"].([]string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*AddonsConfiguration)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._AddonsConfiguration(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_addClusterAddonsConfigurationRepository(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_addClusterAddonsConfigurationRepository_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AddClusterAddonsConfigurationRepository(rctx, args["name"].(string), args["repositories"].([]AddonsConfigurationRepositoryInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*AddonsConfiguration)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._AddonsConfiguration(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_removeClusterAddonsConfigurationRepository(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_removeClusterAddonsConfigurationRepository_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RemoveClusterAddonsConfigurationRepository(rctx, args["name"].(string), args["urls"].([]string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*AddonsConfiguration)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._AddonsConfiguration(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_resyncClusterAddonsConfiguration(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_resyncClusterAddonsConfiguration_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ResyncClusterAddonsConfiguration(rctx, args["name"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*AddonsConfiguration)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._AddonsConfiguration(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_createAddonsConfiguration(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_createAddonsConfiguration_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateAddonsConfiguration(rctx, args["name"].(string), args["namespace"].(string), args["repositories"].([]AddonsConfigurationRepositoryInput), args["urls"].([]string), args["labels"].(*Labels))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*AddonsConfiguration)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._AddonsConfiguration(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_updateAddonsConfiguration(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_updateAddonsConfiguration_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateAddonsConfiguration(rctx, args["name"].(string), args["namespace"].(string), args["repositories"].([]AddonsConfigurationRepositoryInput), args["urls"].([]string), args["labels"].(*Labels))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*AddonsConfiguration)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._AddonsConfiguration(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_deleteAddonsConfiguration(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_deleteAddonsConfiguration_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteAddonsConfiguration(rctx, args["name"].(string), args["namespace"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*AddonsConfiguration)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._AddonsConfiguration(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_addAddonsConfigurationURLs(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_addAddonsConfigurationURLs_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AddAddonsConfigurationURLs(rctx, args["name"].(string), args["namespace"].(string), args["urls"].([]string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*AddonsConfiguration)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._AddonsConfiguration(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_removeAddonsConfigurationURLs(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_removeAddonsConfigurationURLs_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RemoveAddonsConfigurationURLs(rctx, args["name"].(string), args["namespace"].(string), args["urls"].([]string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*AddonsConfiguration)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._AddonsConfiguration(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_addAddonsConfigurationRepository(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_addAddonsConfigurationRepository_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AddAddonsConfigurationRepository(rctx, args["name"].(string), args["namespace"].(string), args["repositories"].([]AddonsConfigurationRepositoryInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*AddonsConfiguration)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._AddonsConfiguration(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_removeAddonsConfigurationRepository(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_removeAddonsConfigurationRepository_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RemoveAddonsConfigurationRepository(rctx, args["name"].(string), args["namespace"].(string), args["urls"].([]string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*AddonsConfiguration)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._AddonsConfiguration(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_resyncAddonsConfiguration(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_resyncAddonsConfiguration_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ResyncAddonsConfiguration(rctx, args["name"].(string), args["namespace"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*AddonsConfiguration)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._AddonsConfiguration(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_createApplication(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_createApplication_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateApplication(rctx, args["name"].(string), args["description"].(*string), args["labels"].(*Labels))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ApplicationMutationOutput)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ApplicationMutationOutput(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_updateApplication(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_updateApplication_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateApplication(rctx, args["name"].(string), args["description"].(*string), args["labels"].(*Labels))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ApplicationMutationOutput)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ApplicationMutationOutput(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_deleteApplication(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_deleteApplication_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteApplication(rctx, args["name"].(string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(DeleteApplicationOutput)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._DeleteApplicationOutput(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_enableApplication(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_enableApplication_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().EnableApplication(rctx, args["application"].(string), args["namespace"].(string), args["allServices"].(*bool), args["services"].([]*ApplicationMappingService))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ApplicationMapping)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ApplicationMapping(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_overloadApplication(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_overloadApplication_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().OverloadApplication(rctx, args["application"].(string), args["namespace"].(string), args["allServices"].(*bool), args["services"].([]*ApplicationMappingService))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ApplicationMapping)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ApplicationMapping(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_disableApplication(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_disableApplication_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DisableApplication(rctx, args["application"].(string), args["namespace"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ApplicationMapping)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ApplicationMapping(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_updatePod(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_updatePod_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdatePod(rctx, args["name"].(string), args["namespace"].(string), args["pod"].(JSON))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Pod)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Pod(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_deletePod(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_deletePod_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeletePod(rctx, args["name"].(string), args["namespace"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Pod)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Pod(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_updateSecret(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_updateSecret_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateSecret(rctx, args["name"].(string), args["namespace"].(string), args["secret"].(JSON))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Secret)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Secret(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_deleteSecret(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_deleteSecret_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteSecret(rctx, args["name"].(string), args["namespace"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Secret)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Secret(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_updateReplicaSet(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_updateReplicaSet_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateReplicaSet(rctx, args["name"].(string), args["namespace"].(string), args["replicaSet"].(JSON))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ReplicaSet)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ReplicaSet(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_deleteReplicaSet(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_deleteReplicaSet_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteReplicaSet(rctx, args["name"].(string), args["namespace"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ReplicaSet)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ReplicaSet(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_createResourceQuota(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_createResourceQuota_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateResourceQuota(rctx, args["namespace"].(string), args["name"].(string), args["resourceQuota"].(ResourceQuotaInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ResourceQuota)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ResourceQuota(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_updateConfigMap(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_updateConfigMap_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateConfigMap(rctx, args["name"].(string), args["namespace"].(string), args["configMap"].(JSON))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ConfigMap)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ConfigMap(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_deleteConfigMap(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_deleteConfigMap_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteConfigMap(rctx, args["name"].(string), args["namespace"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ConfigMap)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ConfigMap(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_createIDPPreset(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_createIDPPreset_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateIDPPreset(rctx, args["name"].(string), args["issuer"].(string), args["jwksUri"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*IDPPreset)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._IDPPreset(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_deleteIDPPreset(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_deleteIDPPreset_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteIDPPreset(rctx, args["name"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*IDPPreset)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._IDPPreset(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_updateService(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_updateService_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateService(rctx, args["name"].(string), args["namespace"].(string), args["service"].(JSON))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Service)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Service(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_deleteService(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_deleteService_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteService(rctx, args["name"].(string), args["namespace"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Service)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Service(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_createNamespace(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_createNamespace_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateNamespace(rctx, args["name"].(string), args["labels"].(*Labels))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(NamespaceMutationOutput)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._NamespaceMutationOutput(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_updateNamespace(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_updateNamespace_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateNamespace(rctx, args["name"].(string), args["labels"].(Labels))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(NamespaceMutationOutput)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._NamespaceMutationOutput(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_deleteNamespace(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_deleteNamespace_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteNamespace(rctx, args["name"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Namespace)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Namespace(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_createAPIRule(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_createAPIRule_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateAPIRule(rctx, args["name"].(string), args["namespace"].(string), args["params"].(APIRuleInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*APIRule)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._APIRule(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_updateAPIRule(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_updateAPIRule_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateAPIRule(rctx, args["name"].(string), args["namespace"].(string), args["params"].(APIRuleInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*APIRule)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._APIRule(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_deleteAPIRule(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_deleteAPIRule_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteAPIRule(rctx, args["name"].(string), args["namespace"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*APIRule)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._APIRule(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_createLimitRange(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_createLimitRange_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateLimitRange(rctx, args["namespace"].(string), args["name"].(string), args["limitRange"].(LimitRangeInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*LimitRange)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._LimitRange(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_createFunction(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_createFunction_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateFunction(rctx, args["name"].(string), args["namespace"].(string), args["params"].(FunctionMutationInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Function)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Function(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_updateFunction(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_updateFunction_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateFunction(rctx, args["name"].(string), args["namespace"].(string), args["params"].(FunctionMutationInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Function)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Function(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_deleteFunction(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_deleteFunction_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteFunction(rctx, args["function"].(FunctionMetadataInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*FunctionMetadata)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._FunctionMetadata(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_deleteManyFunctions(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_deleteManyFunctions_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteManyFunctions(rctx, args["functions"].([]FunctionMetadataInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]FunctionMetadata)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._FunctionMetadata(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_createTrigger(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_createTrigger_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateTrigger(rctx, args["trigger"].(TriggerCreateInput), args["ownerRef"].([]OwnerReference))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Trigger)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Trigger(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_createManyTriggers(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_createManyTriggers_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateManyTriggers(rctx, args["triggers"].([]TriggerCreateInput), args["ownerRef"].([]OwnerReference))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]Trigger)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Trigger(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_deleteTrigger(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_deleteTrigger_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteTrigger(rctx, args["trigger"].(TriggerMetadataInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*TriggerMetadata)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._TriggerMetadata(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_deleteManyTriggers(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_deleteManyTriggers_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteManyTriggers(rctx, args["triggers"].([]TriggerMetadataInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]TriggerMetadata)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._TriggerMetadata(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var namespaceImplementors = []string{"Namespace"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Namespace(ctx context.Context, sel ast.SelectionSet, obj *Namespace) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, namespaceImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Namespace")
		case "name":
			out.Values[i] = ec._Namespace_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "labels":
			out.Values[i] = ec._Namespace_labels(ctx, field, obj)
		case "status":
			out.Values[i] = ec._Namespace_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "isSystemNamespace":
			out.Values[i] = ec._Namespace_isSystemNamespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "pods":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Namespace_pods(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "applications":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Namespace_applications(ctx, field, obj)
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Namespace_name(ctx context.Context, field graphql.CollectedField, obj *Namespace) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Namespace",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Namespace_labels(ctx context.Context, field graphql.CollectedField, obj *Namespace) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Namespace",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(Labels)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _Namespace_status(ctx context.Context, field graphql.CollectedField, obj *Namespace) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Namespace",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Namespace_isSystemNamespace(ctx context.Context, field graphql.CollectedField, obj *Namespace) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Namespace",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsSystemNamespace, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) _Namespace_pods(ctx context.Context, field graphql.CollectedField, obj *Namespace) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Namespace",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Namespace().Pods(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]Pod)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Pod(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Namespace_applications(ctx context.Context, field graphql.CollectedField, obj *Namespace) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Namespace",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Namespace().Applications(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return graphql.MarshalString(res[idx1])
		}()
	}

	return arr1
}

var namespaceEventImplementors = []string{"NamespaceEvent"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _NamespaceEvent(ctx context.Context, sel ast.SelectionSet, obj *NamespaceEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, namespaceEventImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NamespaceEvent")
		case "type":
			out.Values[i] = ec._NamespaceEvent_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "namespace":
			out.Values[i] = ec._NamespaceEvent_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _NamespaceEvent_type(ctx context.Context, field graphql.CollectedField, obj *NamespaceEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "NamespaceEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SubscriptionEventType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _NamespaceEvent_namespace(ctx context.Context, field graphql.CollectedField, obj *NamespaceEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "NamespaceEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Namespace)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Namespace(ctx, field.Selections, &res)
}

var namespaceMutationOutputImplementors = []string{"NamespaceMutationOutput"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _NamespaceMutationOutput(ctx context.Context, sel ast.SelectionSet, obj *NamespaceMutationOutput) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, namespaceMutationOutputImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NamespaceMutationOutput")
		case "name":
			out.Values[i] = ec._NamespaceMutationOutput_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "labels":
			out.Values[i] = ec._NamespaceMutationOutput_labels(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _NamespaceMutationOutput_name(ctx context.Context, field graphql.CollectedField, obj *NamespaceMutationOutput) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "NamespaceMutationOutput",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _NamespaceMutationOutput_labels(ctx context.Context, field graphql.CollectedField, obj *NamespaceMutationOutput) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "NamespaceMutationOutput",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Labels)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

var navigationNodeImplementors = []string{"NavigationNode"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _NavigationNode(ctx context.Context, sel ast.SelectionSet, obj *NavigationNode) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, navigationNodeImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NavigationNode")
		case "label":
			out.Values[i] = ec._NavigationNode_label(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "navigationPath":
			out.Values[i] = ec._NavigationNode_navigationPath(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "viewUrl":
			out.Values[i] = ec._NavigationNode_viewUrl(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "showInNavigation":
			out.Values[i] = ec._NavigationNode_showInNavigation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "order":
			out.Values[i] = ec._NavigationNode_order(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "settings":
			out.Values[i] = ec._NavigationNode_settings(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "externalLink":
			out.Values[i] = ec._NavigationNode_externalLink(ctx, field, obj)
		case "requiredPermissions":
			out.Values[i] = ec._NavigationNode_requiredPermissions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _NavigationNode_label(ctx context.Context, field graphql.CollectedField, obj *NavigationNode) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "NavigationNode",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Label, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _NavigationNode_navigationPath(ctx context.Context, field graphql.CollectedField, obj *NavigationNode) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "NavigationNode",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NavigationPath, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _NavigationNode_viewUrl(ctx context.Context, field graphql.CollectedField, obj *NavigationNode) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "NavigationNode",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ViewURL, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _NavigationNode_showInNavigation(ctx context.Context, field graphql.CollectedField, obj *NavigationNode) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "NavigationNode",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ShowInNavigation, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) _NavigationNode_order(ctx context.Context, field graphql.CollectedField, obj *NavigationNode) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "NavigationNode",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Order, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

// nolint: vetshadow
func (ec *executionContext) _NavigationNode_settings(ctx context.Context, field graphql.CollectedField, obj *NavigationNode) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "NavigationNode",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Settings, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Settings)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _NavigationNode_externalLink(ctx context.Context, field graphql.CollectedField, obj *NavigationNode) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "NavigationNode",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExternalLink, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _NavigationNode_requiredPermissions(ctx context.Context, field graphql.CollectedField, obj *NavigationNode) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "NavigationNode",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequiredPermissions, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]RequiredPermission)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._RequiredPermission(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var podImplementors = []string{"Pod"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Pod(ctx context.Context, sel ast.SelectionSet, obj *Pod) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, podImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Pod")
		case "name":
			out.Values[i] = ec._Pod_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "nodeName":
			out.Values[i] = ec._Pod_nodeName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "namespace":
			out.Values[i] = ec._Pod_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "restartCount":
			out.Values[i] = ec._Pod_restartCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "creationTimestamp":
			out.Values[i] = ec._Pod_creationTimestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "labels":
			out.Values[i] = ec._Pod_labels(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "status":
			out.Values[i] = ec._Pod_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "containerStates":
			out.Values[i] = ec._Pod_containerStates(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "json":
			out.Values[i] = ec._Pod_json(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Pod_name(ctx context.Context, field graphql.CollectedField, obj *Pod) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Pod",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Pod_nodeName(ctx context.Context, field graphql.CollectedField, obj *Pod) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Pod",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NodeName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Pod_namespace(ctx context.Context, field graphql.CollectedField, obj *Pod) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Pod",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Pod_restartCount(ctx context.Context, field graphql.CollectedField, obj *Pod) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Pod",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RestartCount, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

// nolint: vetshadow
func (ec *executionContext) _Pod_creationTimestamp(ctx context.Context, field graphql.CollectedField, obj *Pod) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Pod",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTimestamp, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return MarshalTimestamp(res)
}

// nolint: vetshadow
func (ec *executionContext) _Pod_labels(ctx context.Context, field graphql.CollectedField, obj *Pod) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Pod",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Labels)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _Pod_status(ctx context.Context, field graphql.CollectedField, obj *Pod) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Pod",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(PodStatusType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _Pod_containerStates(ctx context.Context, field graphql.CollectedField, obj *Pod) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Pod",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContainerStates, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]ContainerState)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._ContainerState(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Pod_json(ctx context.Context, field graphql.CollectedField, obj *Pod) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Pod",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JSON, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(JSON)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

var podEventImplementors = []string{"PodEvent"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _PodEvent(ctx context.Context, sel ast.SelectionSet, obj *PodEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, podEventImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PodEvent")
		case "type":
			out.Values[i] = ec._PodEvent_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "pod":
			out.Values[i] = ec._PodEvent_pod(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _PodEvent_type(ctx context.Context, field graphql.CollectedField, obj *PodEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "PodEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SubscriptionEventType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _PodEvent_pod(ctx context.Context, field graphql.CollectedField, obj *PodEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "PodEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Pod, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Pod)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Pod(ctx, field.Selections, &res)
}

var queryImplementors = []string{"Query"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, queryImplementors)

	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Query",
	})

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "clusterAssetGroups":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_clusterAssetGroups(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "serviceInstance":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_serviceInstance(ctx, field)
				wg.Done()
			}(i, field)
		case "serviceInstances":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_serviceInstances(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "clusterServiceClasses":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_clusterServiceClasses(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "clusterServiceClass":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_clusterServiceClass(ctx, field)
				wg.Done()
			}(i, field)
		case "serviceClasses":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_serviceClasses(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "serviceClass":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_serviceClass(ctx, field)
				wg.Done()
			}(i, field)
		case "clusterServiceBrokers":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_clusterServiceBrokers(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "clusterServiceBroker":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_clusterServiceBroker(ctx, field)
				wg.Done()
			}(i, field)
		case "serviceBrokers":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_serviceBrokers(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "serviceBroker":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_serviceBroker(ctx, field)
				wg.Done()
			}(i, field)
		case "serviceBindingUsage":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_serviceBindingUsage(ctx, field)
				wg.Done()
			}(i, field)
		case "serviceBindingUsages":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_serviceBindingUsages(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "serviceBinding":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_serviceBinding(ctx, field)
				wg.Done()
			}(i, field)
		case "usageKinds":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_usageKinds(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "clusterAddonsConfigurations":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_clusterAddonsConfigurations(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "addonsConfigurations":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_addonsConfigurations(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "bindableResources":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_bindableResources(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "APIRules":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_APIRules(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "APIRule":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_APIRule(ctx, field)
				wg.Done()
			}(i, field)
		case "application":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_application(ctx, field)
				wg.Done()
			}(i, field)
		case "applications":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_applications(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "connectorService":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_connectorService(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "namespaces":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_namespaces(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "namespace":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_namespace(ctx, field)
				wg.Done()
			}(i, field)
		case "deployments":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_deployments(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "versionInfo":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_versionInfo(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "pod":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_pod(ctx, field)
				wg.Done()
			}(i, field)
		case "pods":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_pods(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "service":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_service(ctx, field)
				wg.Done()
			}(i, field)
		case "services":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_services(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "configMap":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_configMap(ctx, field)
				wg.Done()
			}(i, field)
		case "configMaps":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_configMaps(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "replicaSet":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_replicaSet(ctx, field)
				wg.Done()
			}(i, field)
		case "replicaSets":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_replicaSets(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "resourceQuotas":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_resourceQuotas(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "resourceQuotasStatus":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_resourceQuotasStatus(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "eventActivations":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_eventActivations(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "limitRanges":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_limitRanges(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "backendModules":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_backendModules(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "secret":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_secret(ctx, field)
				wg.Done()
			}(i, field)
		case "secrets":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_secrets(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "IDPPreset":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_IDPPreset(ctx, field)
				wg.Done()
			}(i, field)
		case "IDPPresets":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_IDPPresets(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "microFrontends":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_microFrontends(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "clusterMicroFrontends":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_clusterMicroFrontends(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "selfSubjectRules":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_selfSubjectRules(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "function":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_function(ctx, field)
				wg.Done()
			}(i, field)
		case "functions":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_functions(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "triggers":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_triggers(ctx, field)
				wg.Done()
			}(i, field)
		case "__type":
			out.Values[i] = ec._Query___type(ctx, field)
		case "__schema":
			out.Values[i] = ec._Query___schema(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Query_clusterAssetGroups(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_clusterAssetGroups_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ClusterAssetGroups(rctx, args["viewContext"].(*string), args["groupName"].(*string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]ClusterAssetGroup)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._ClusterAssetGroup(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_serviceInstance(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_serviceInstance_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ServiceInstance(rctx, args["name"].(string), args["namespace"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ServiceInstance)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ServiceInstance(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_serviceInstances(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_serviceInstances_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ServiceInstances(rctx, args["namespace"].(string), args["first"].(*int), args["offset"].(*int), args["status"].(*InstanceStatusType))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]ServiceInstance)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._ServiceInstance(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_clusterServiceClasses(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_clusterServiceClasses_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ClusterServiceClasses(rctx, args["first"].(*int), args["offset"].(*int))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]ClusterServiceClass)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._ClusterServiceClass(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_clusterServiceClass(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_clusterServiceClass_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ClusterServiceClass(rctx, args["name"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ClusterServiceClass)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ClusterServiceClass(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_serviceClasses(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_serviceClasses_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ServiceClasses(rctx, args["namespace"].(string), args["first"].(*int), args["offset"].(*int))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]ServiceClass)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._ServiceClass(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_serviceClass(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_serviceClass_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ServiceClass(rctx, args["namespace"].(string), args["name"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ServiceClass)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ServiceClass(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_clusterServiceBrokers(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_clusterServiceBrokers_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ClusterServiceBrokers(rctx, args["first"].(*int), args["offset"].(*int))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]ClusterServiceBroker)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._ClusterServiceBroker(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_clusterServiceBroker(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_clusterServiceBroker_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ClusterServiceBroker(rctx, args["name"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ClusterServiceBroker)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ClusterServiceBroker(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_serviceBrokers(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_serviceBrokers_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ServiceBrokers(rctx, args["namespace"].(string), args["first"].(*int), args["offset"].(*int))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]ServiceBroker)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._ServiceBroker(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_serviceBroker(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_serviceBroker_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ServiceBroker(rctx, args["name"].(string), args["namespace"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ServiceBroker)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ServiceBroker(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_serviceBindingUsage(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_serviceBindingUsage_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ServiceBindingUsage(rctx, args["name"].(string), args["namespace"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ServiceBindingUsage)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ServiceBindingUsage(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_serviceBindingUsages(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_serviceBindingUsages_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ServiceBindingUsages(rctx, args["namespace"].(string), args["resourceKind"].(*string), args["resourceName"].(*string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]ServiceBindingUsage)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._ServiceBindingUsage(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_serviceBinding(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_serviceBinding_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ServiceBinding(rctx, args["name"].(string), args["namespace"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ServiceBinding)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ServiceBinding(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_usageKinds(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_usageKinds_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UsageKinds(rctx, args["first"].(*int), args["offset"].(*int))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]UsageKind)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._UsageKind(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_clusterAddonsConfigurations(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_clusterAddonsConfigurations_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ClusterAddonsConfigurations(rctx, args["first"].(*int), args["offset"].(*int))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]AddonsConfiguration)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._AddonsConfiguration(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_addonsConfigurations(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_addonsConfigurations_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AddonsConfigurations(rctx, args["namespace"].(string), args["first"].(*int), args["offset"].(*int))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]AddonsConfiguration)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._AddonsConfiguration(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_bindableResources(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_bindableResources_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().BindableResources(rctx, args["namespace"].(string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]BindableResourcesOutputItem)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._BindableResourcesOutputItem(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_APIRules(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_APIRules_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().APIRules(rctx, args["namespace"].(string), args["serviceName"].(*string), args["hostname"].(*string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]APIRule)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._APIRule(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_APIRule(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_APIRule_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().APIRule(rctx, args["name"].(string), args["namespace"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*APIRule)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._APIRule(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_application(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_application_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Application(rctx, args["name"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Application)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Application(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_applications(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_applications_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Applications(rctx, args["namespace"].(*string), args["first"].(*int), args["offset"].(*int))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]Application)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Application(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_connectorService(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_connectorService_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ConnectorService(rctx, args["application"].(string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ConnectorService)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ConnectorService(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_namespaces(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_namespaces_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Namespaces(rctx, args["withSystemNamespaces"].(*bool), args["withInactiveStatus"].(*bool))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]Namespace)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Namespace(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_namespace(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_namespace_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Namespace(rctx, args["name"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Namespace)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Namespace(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_deployments(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_deployments_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Deployments(rctx, args["namespace"].(string), args["excludeFunctions"].(*bool))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]Deployment)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Deployment(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_versionInfo(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().VersionInfo(rctx)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(VersionInfo)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._VersionInfo(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_pod(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_pod_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Pod(rctx, args["name"].(string), args["namespace"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Pod)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Pod(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_pods(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_pods_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Pods(rctx, args["namespace"].(string), args["first"].(*int), args["offset"].(*int))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]Pod)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Pod(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_service(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_service_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Service(rctx, args["name"].(string), args["namespace"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Service)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Service(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_services(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_services_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Services(rctx, args["namespace"].(string), args["excludedLabels"].([]string), args["first"].(*int), args["offset"].(*int))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]Service)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Service(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_configMap(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_configMap_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ConfigMap(rctx, args["name"].(string), args["namespace"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ConfigMap)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ConfigMap(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_configMaps(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_configMaps_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ConfigMaps(rctx, args["namespace"].(string), args["first"].(*int), args["offset"].(*int))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]ConfigMap)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._ConfigMap(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_replicaSet(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_replicaSet_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ReplicaSet(rctx, args["name"].(string), args["namespace"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ReplicaSet)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ReplicaSet(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_replicaSets(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_replicaSets_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ReplicaSets(rctx, args["namespace"].(string), args["first"].(*int), args["offset"].(*int))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]ReplicaSet)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._ReplicaSet(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_resourceQuotas(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_resourceQuotas_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ResourceQuotas(rctx, args["namespace"].(string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]ResourceQuota)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._ResourceQuota(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_resourceQuotasStatus(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_resourceQuotasStatus_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ResourceQuotasStatus(rctx, args["namespace"].(string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ResourceQuotasStatus)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ResourceQuotasStatus(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_eventActivations(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_eventActivations_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().EventActivations(rctx, args["namespace"].(string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]EventActivation)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._EventActivation(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_limitRanges(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_limitRanges_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().LimitRanges(rctx, args["namespace"].(string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]LimitRange)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._LimitRange(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_backendModules(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().BackendModules(rctx)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]BackendModule)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._BackendModule(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_secret(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_secret_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Secret(rctx, args["name"].(string), args["namespace"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Secret)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Secret(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_secrets(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_secrets_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Secrets(rctx, args["namespace"].(string), args["first"].(*int), args["offset"].(*int))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]Secret)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Secret(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_IDPPreset(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_IDPPreset_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().IDPPreset(rctx, args["name"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*IDPPreset)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._IDPPreset(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_IDPPresets(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_IDPPresets_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().IDPPresets(rctx, args["first"].(*int), args["offset"].(*int))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]IDPPreset)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._IDPPreset(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_microFrontends(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_microFrontends_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().MicroFrontends(rctx, args["namespace"].(string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]MicroFrontend)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._MicroFrontend(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_clusterMicroFrontends(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ClusterMicroFrontends(rctx)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]ClusterMicroFrontend)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._ClusterMicroFrontend(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_selfSubjectRules(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_selfSubjectRules_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().SelfSubjectRules(rctx, args["namespace"].(*string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]ResourceRule)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._ResourceRule(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_function(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_function_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Function(rctx, args["name"].(string), args["namespace"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Function)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Function(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_functions(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_functions_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Functions(rctx, args["namespace"].(string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]Function)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Function(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_triggers(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_triggers_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Triggers(rctx, args["namespace"].(string), args["subscriber"].(*SubscriberInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]Trigger)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Trigger(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query___type_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(args["name"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec.___Schema(ctx, field.Selections, res)
}

var replicaSetImplementors = []string{"ReplicaSet"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ReplicaSet(ctx context.Context, sel ast.SelectionSet, obj *ReplicaSet) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, replicaSetImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ReplicaSet")
		case "name":
			out.Values[i] = ec._ReplicaSet_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "pods":
			out.Values[i] = ec._ReplicaSet_pods(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "namespace":
			out.Values[i] = ec._ReplicaSet_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "images":
			out.Values[i] = ec._ReplicaSet_images(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "creationTimestamp":
			out.Values[i] = ec._ReplicaSet_creationTimestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "labels":
			out.Values[i] = ec._ReplicaSet_labels(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "json":
			out.Values[i] = ec._ReplicaSet_json(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ReplicaSet_name(ctx context.Context, field graphql.CollectedField, obj *ReplicaSet) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ReplicaSet",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ReplicaSet_pods(ctx context.Context, field graphql.CollectedField, obj *ReplicaSet) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ReplicaSet",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Pods, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ReplicaSet_namespace(ctx context.Context, field graphql.CollectedField, obj *ReplicaSet) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ReplicaSet",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ReplicaSet_images(ctx context.Context, field graphql.CollectedField, obj *ReplicaSet) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ReplicaSet",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Images, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return graphql.MarshalString(res[idx1])
		}()
	}

	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _ReplicaSet_creationTimestamp(ctx context.Context, field graphql.CollectedField, obj *ReplicaSet) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ReplicaSet",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTimestamp, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return MarshalTimestamp(res)
}

// nolint: vetshadow
func (ec *executionContext) _ReplicaSet_labels(ctx context.Context, field graphql.CollectedField, obj *ReplicaSet) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ReplicaSet",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Labels)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _ReplicaSet_json(ctx context.Context, field graphql.CollectedField, obj *ReplicaSet) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ReplicaSet",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JSON, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(JSON)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

var requiredPermissionImplementors = []string{"RequiredPermission"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _RequiredPermission(ctx context.Context, sel ast.SelectionSet, obj *RequiredPermission) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, requiredPermissionImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RequiredPermission")
		case "verbs":
			out.Values[i] = ec._RequiredPermission_verbs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "apiGroup":
			out.Values[i] = ec._RequiredPermission_apiGroup(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "resource":
			out.Values[i] = ec._RequiredPermission_resource(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _RequiredPermission_verbs(ctx context.Context, field graphql.CollectedField, obj *RequiredPermission) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "RequiredPermission",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Verbs, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return graphql.MarshalString(res[idx1])
		}()
	}

	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _RequiredPermission_apiGroup(ctx context.Context, field graphql.CollectedField, obj *RequiredPermission) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "RequiredPermission",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.APIGroup, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _RequiredPermission_resource(ctx context.Context, field graphql.CollectedField, obj *RequiredPermission) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "RequiredPermission",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Resource, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var resourceQuotaImplementors = []string{"ResourceQuota"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ResourceQuota(ctx context.Context, sel ast.SelectionSet, obj *ResourceQuota) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, resourceQuotaImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ResourceQuota")
		case "name":
			out.Values[i] = ec._ResourceQuota_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "pods":
			out.Values[i] = ec._ResourceQuota_pods(ctx, field, obj)
		case "limits":
			out.Values[i] = ec._ResourceQuota_limits(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "requests":
			out.Values[i] = ec._ResourceQuota_requests(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ResourceQuota_name(ctx context.Context, field graphql.CollectedField, obj *ResourceQuota) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ResourceQuota",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ResourceQuota_pods(ctx context.Context, field graphql.CollectedField, obj *ResourceQuota) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ResourceQuota",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Pods, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ResourceQuota_limits(ctx context.Context, field graphql.CollectedField, obj *ResourceQuota) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ResourceQuota",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Limits, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ResourceValues)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ResourceValues(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _ResourceQuota_requests(ctx context.Context, field graphql.CollectedField, obj *ResourceQuota) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ResourceQuota",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Requests, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ResourceValues)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ResourceValues(ctx, field.Selections, &res)
}

var resourceQuotasStatusImplementors = []string{"ResourceQuotasStatus"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ResourceQuotasStatus(ctx context.Context, sel ast.SelectionSet, obj *ResourceQuotasStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, resourceQuotasStatusImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ResourceQuotasStatus")
		case "exceeded":
			out.Values[i] = ec._ResourceQuotasStatus_exceeded(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "exceededQuotas":
			out.Values[i] = ec._ResourceQuotasStatus_exceededQuotas(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ResourceQuotasStatus_exceeded(ctx context.Context, field graphql.CollectedField, obj *ResourceQuotasStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ResourceQuotasStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Exceeded, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) _ResourceQuotasStatus_exceededQuotas(ctx context.Context, field graphql.CollectedField, obj *ResourceQuotasStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ResourceQuotasStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExceededQuotas, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]ExceededQuota)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._ExceededQuota(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var resourceRefImplementors = []string{"ResourceRef"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ResourceRef(ctx context.Context, sel ast.SelectionSet, obj *ResourceRef) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, resourceRefImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ResourceRef")
		case "name":
			out.Values[i] = ec._ResourceRef_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "namespace":
			out.Values[i] = ec._ResourceRef_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ResourceRef_name(ctx context.Context, field graphql.CollectedField, obj *ResourceRef) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ResourceRef",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ResourceRef_namespace(ctx context.Context, field graphql.CollectedField, obj *ResourceRef) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ResourceRef",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var resourceRuleImplementors = []string{"ResourceRule"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ResourceRule(ctx context.Context, sel ast.SelectionSet, obj *ResourceRule) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, resourceRuleImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ResourceRule")
		case "verbs":
			out.Values[i] = ec._ResourceRule_verbs(ctx, field, obj)
		case "apiGroups":
			out.Values[i] = ec._ResourceRule_apiGroups(ctx, field, obj)
		case "resources":
			out.Values[i] = ec._ResourceRule_resources(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ResourceRule_verbs(ctx context.Context, field graphql.CollectedField, obj *ResourceRule) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ResourceRule",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Verbs, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return graphql.MarshalString(res[idx1])
		}()
	}

	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _ResourceRule_apiGroups(ctx context.Context, field graphql.CollectedField, obj *ResourceRule) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ResourceRule",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.APIGroups, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return graphql.MarshalString(res[idx1])
		}()
	}

	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _ResourceRule_resources(ctx context.Context, field graphql.CollectedField, obj *ResourceRule) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ResourceRule",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Resources, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return graphql.MarshalString(res[idx1])
		}()
	}

	return arr1
}

var resourceTypeImplementors = []string{"ResourceType"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ResourceType(ctx context.Context, sel ast.SelectionSet, obj *ResourceType) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, resourceTypeImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ResourceType")
		case "memory":
			out.Values[i] = ec._ResourceType_memory(ctx, field, obj)
		case "cpu":
			out.Values[i] = ec._ResourceType_cpu(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ResourceType_memory(ctx context.Context, field graphql.CollectedField, obj *ResourceType) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ResourceType",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Memory, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ResourceType_cpu(ctx context.Context, field graphql.CollectedField, obj *ResourceType) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ResourceType",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CPU, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var resourceValuesImplementors = []string{"ResourceValues"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ResourceValues(ctx context.Context, sel ast.SelectionSet, obj *ResourceValues) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, resourceValuesImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ResourceValues")
		case "memory":
			out.Values[i] = ec._ResourceValues_memory(ctx, field, obj)
		case "cpu":
			out.Values[i] = ec._ResourceValues_cpu(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ResourceValues_memory(ctx context.Context, field graphql.CollectedField, obj *ResourceValues) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ResourceValues",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Memory, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ResourceValues_cpu(ctx context.Context, field graphql.CollectedField, obj *ResourceValues) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ResourceValues",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CPU, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var ruleImplementors = []string{"Rule"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Rule(ctx context.Context, sel ast.SelectionSet, obj *Rule) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, ruleImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Rule")
		case "path":
			out.Values[i] = ec._Rule_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "methods":
			out.Values[i] = ec._Rule_methods(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "accessStrategies":
			out.Values[i] = ec._Rule_accessStrategies(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "mutators":
			out.Values[i] = ec._Rule_mutators(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Rule_path(ctx context.Context, field graphql.CollectedField, obj *Rule) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Rule",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Path, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Rule_methods(ctx context.Context, field graphql.CollectedField, obj *Rule) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Rule",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Methods, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return graphql.MarshalString(res[idx1])
		}()
	}

	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Rule_accessStrategies(ctx context.Context, field graphql.CollectedField, obj *Rule) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Rule",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccessStrategies, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]APIRuleConfig)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._APIRuleConfig(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Rule_mutators(ctx context.Context, field graphql.CollectedField, obj *Rule) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Rule",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Mutators, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]APIRuleConfig)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._APIRuleConfig(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var secretImplementors = []string{"Secret"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Secret(ctx context.Context, sel ast.SelectionSet, obj *Secret) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, secretImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Secret")
		case "name":
			out.Values[i] = ec._Secret_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "namespace":
			out.Values[i] = ec._Secret_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "data":
			out.Values[i] = ec._Secret_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "type":
			out.Values[i] = ec._Secret_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "creationTime":
			out.Values[i] = ec._Secret_creationTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "labels":
			out.Values[i] = ec._Secret_labels(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "annotations":
			out.Values[i] = ec._Secret_annotations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "json":
			out.Values[i] = ec._Secret_json(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Secret_name(ctx context.Context, field graphql.CollectedField, obj *Secret) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Secret",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Secret_namespace(ctx context.Context, field graphql.CollectedField, obj *Secret) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Secret",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Secret_data(ctx context.Context, field graphql.CollectedField, obj *Secret) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Secret",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(JSON)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _Secret_type(ctx context.Context, field graphql.CollectedField, obj *Secret) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Secret",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Secret_creationTime(ctx context.Context, field graphql.CollectedField, obj *Secret) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Secret",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTime, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return MarshalTimestamp(res)
}

// nolint: vetshadow
func (ec *executionContext) _Secret_labels(ctx context.Context, field graphql.CollectedField, obj *Secret) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Secret",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(JSON)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _Secret_annotations(ctx context.Context, field graphql.CollectedField, obj *Secret) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Secret",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Annotations, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(JSON)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _Secret_json(ctx context.Context, field graphql.CollectedField, obj *Secret) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Secret",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JSON, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(JSON)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

var secretEventImplementors = []string{"SecretEvent"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _SecretEvent(ctx context.Context, sel ast.SelectionSet, obj *SecretEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, secretEventImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SecretEvent")
		case "type":
			out.Values[i] = ec._SecretEvent_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "secret":
			out.Values[i] = ec._SecretEvent_secret(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _SecretEvent_type(ctx context.Context, field graphql.CollectedField, obj *SecretEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "SecretEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SubscriptionEventType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _SecretEvent_secret(ctx context.Context, field graphql.CollectedField, obj *SecretEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "SecretEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Secret, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Secret)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Secret(ctx, field.Selections, &res)
}

var serviceImplementors = []string{"Service"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Service(ctx context.Context, sel ast.SelectionSet, obj *Service) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, serviceImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Service")
		case "name":
			out.Values[i] = ec._Service_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "clusterIP":
			out.Values[i] = ec._Service_clusterIP(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "creationTimestamp":
			out.Values[i] = ec._Service_creationTimestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "labels":
			out.Values[i] = ec._Service_labels(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "ports":
			out.Values[i] = ec._Service_ports(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "status":
			out.Values[i] = ec._Service_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "json":
			out.Values[i] = ec._Service_json(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Service_name(ctx context.Context, field graphql.CollectedField, obj *Service) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Service",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Service_clusterIP(ctx context.Context, field graphql.CollectedField, obj *Service) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Service",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClusterIP, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Service_creationTimestamp(ctx context.Context, field graphql.CollectedField, obj *Service) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Service",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTimestamp, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return MarshalTimestamp(res)
}

// nolint: vetshadow
func (ec *executionContext) _Service_labels(ctx context.Context, field graphql.CollectedField, obj *Service) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Service",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Labels)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _Service_ports(ctx context.Context, field graphql.CollectedField, obj *Service) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Service",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ports, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]ServicePort)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._ServicePort(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Service_status(ctx context.Context, field graphql.CollectedField, obj *Service) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Service",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ServiceStatus)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ServiceStatus(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Service_json(ctx context.Context, field graphql.CollectedField, obj *Service) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Service",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JSON, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(JSON)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

var serviceBindingImplementors = []string{"ServiceBinding"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ServiceBinding(ctx context.Context, sel ast.SelectionSet, obj *ServiceBinding) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, serviceBindingImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceBinding")
		case "name":
			out.Values[i] = ec._ServiceBinding_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "serviceInstanceName":
			out.Values[i] = ec._ServiceBinding_serviceInstanceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "namespace":
			out.Values[i] = ec._ServiceBinding_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "secret":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ServiceBinding_secret(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "status":
			out.Values[i] = ec._ServiceBinding_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "parameters":
			out.Values[i] = ec._ServiceBinding_parameters(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBinding_name(ctx context.Context, field graphql.CollectedField, obj *ServiceBinding) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBinding",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBinding_serviceInstanceName(ctx context.Context, field graphql.CollectedField, obj *ServiceBinding) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBinding",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServiceInstanceName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBinding_namespace(ctx context.Context, field graphql.CollectedField, obj *ServiceBinding) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBinding",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBinding_secret(ctx context.Context, field graphql.CollectedField, obj *ServiceBinding) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBinding",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ServiceBinding().Secret(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Secret)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Secret(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBinding_status(ctx context.Context, field graphql.CollectedField, obj *ServiceBinding) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBinding",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ServiceBindingStatus)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ServiceBindingStatus(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBinding_parameters(ctx context.Context, field graphql.CollectedField, obj *ServiceBinding) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBinding",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Parameters, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(JSON)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

var serviceBindingEventImplementors = []string{"ServiceBindingEvent"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ServiceBindingEvent(ctx context.Context, sel ast.SelectionSet, obj *ServiceBindingEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, serviceBindingEventImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceBindingEvent")
		case "type":
			out.Values[i] = ec._ServiceBindingEvent_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "serviceBinding":
			out.Values[i] = ec._ServiceBindingEvent_serviceBinding(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBindingEvent_type(ctx context.Context, field graphql.CollectedField, obj *ServiceBindingEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBindingEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SubscriptionEventType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBindingEvent_serviceBinding(ctx context.Context, field graphql.CollectedField, obj *ServiceBindingEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBindingEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServiceBinding, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ServiceBinding)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ServiceBinding(ctx, field.Selections, &res)
}

var serviceBindingStatusImplementors = []string{"ServiceBindingStatus"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ServiceBindingStatus(ctx context.Context, sel ast.SelectionSet, obj *ServiceBindingStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, serviceBindingStatusImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceBindingStatus")
		case "type":
			out.Values[i] = ec._ServiceBindingStatus_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "reason":
			out.Values[i] = ec._ServiceBindingStatus_reason(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "message":
			out.Values[i] = ec._ServiceBindingStatus_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBindingStatus_type(ctx context.Context, field graphql.CollectedField, obj *ServiceBindingStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBindingStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ServiceBindingStatusType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBindingStatus_reason(ctx context.Context, field graphql.CollectedField, obj *ServiceBindingStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBindingStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reason, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBindingStatus_message(ctx context.Context, field graphql.CollectedField, obj *ServiceBindingStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBindingStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var serviceBindingUsageImplementors = []string{"ServiceBindingUsage"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ServiceBindingUsage(ctx context.Context, sel ast.SelectionSet, obj *ServiceBindingUsage) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, serviceBindingUsageImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceBindingUsage")
		case "name":
			out.Values[i] = ec._ServiceBindingUsage_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "namespace":
			out.Values[i] = ec._ServiceBindingUsage_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "serviceBinding":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ServiceBindingUsage_serviceBinding(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "usedBy":
			out.Values[i] = ec._ServiceBindingUsage_usedBy(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "parameters":
			out.Values[i] = ec._ServiceBindingUsage_parameters(ctx, field, obj)
		case "status":
			out.Values[i] = ec._ServiceBindingUsage_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBindingUsage_name(ctx context.Context, field graphql.CollectedField, obj *ServiceBindingUsage) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBindingUsage",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBindingUsage_namespace(ctx context.Context, field graphql.CollectedField, obj *ServiceBindingUsage) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBindingUsage",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBindingUsage_serviceBinding(ctx context.Context, field graphql.CollectedField, obj *ServiceBindingUsage) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBindingUsage",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ServiceBindingUsage().ServiceBinding(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ServiceBinding)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ServiceBinding(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBindingUsage_usedBy(ctx context.Context, field graphql.CollectedField, obj *ServiceBindingUsage) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBindingUsage",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UsedBy, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(LocalObjectReference)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._LocalObjectReference(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBindingUsage_parameters(ctx context.Context, field graphql.CollectedField, obj *ServiceBindingUsage) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBindingUsage",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Parameters, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ServiceBindingUsageParameters)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ServiceBindingUsageParameters(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBindingUsage_status(ctx context.Context, field graphql.CollectedField, obj *ServiceBindingUsage) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBindingUsage",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ServiceBindingUsageStatus)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ServiceBindingUsageStatus(ctx, field.Selections, &res)
}

var serviceBindingUsageEventImplementors = []string{"ServiceBindingUsageEvent"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ServiceBindingUsageEvent(ctx context.Context, sel ast.SelectionSet, obj *ServiceBindingUsageEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, serviceBindingUsageEventImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceBindingUsageEvent")
		case "type":
			out.Values[i] = ec._ServiceBindingUsageEvent_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "serviceBindingUsage":
			out.Values[i] = ec._ServiceBindingUsageEvent_serviceBindingUsage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBindingUsageEvent_type(ctx context.Context, field graphql.CollectedField, obj *ServiceBindingUsageEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBindingUsageEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SubscriptionEventType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBindingUsageEvent_serviceBindingUsage(ctx context.Context, field graphql.CollectedField, obj *ServiceBindingUsageEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBindingUsageEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServiceBindingUsage, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ServiceBindingUsage)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ServiceBindingUsage(ctx, field.Selections, &res)
}

var serviceBindingUsageParametersImplementors = []string{"ServiceBindingUsageParameters"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ServiceBindingUsageParameters(ctx context.Context, sel ast.SelectionSet, obj *ServiceBindingUsageParameters) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, serviceBindingUsageParametersImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceBindingUsageParameters")
		case "envPrefix":
			out.Values[i] = ec._ServiceBindingUsageParameters_envPrefix(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBindingUsageParameters_envPrefix(ctx context.Context, field graphql.CollectedField, obj *ServiceBindingUsageParameters) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBindingUsageParameters",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnvPrefix, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*EnvPrefix)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._EnvPrefix(ctx, field.Selections, res)
}

var serviceBindingUsageStatusImplementors = []string{"ServiceBindingUsageStatus"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ServiceBindingUsageStatus(ctx context.Context, sel ast.SelectionSet, obj *ServiceBindingUsageStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, serviceBindingUsageStatusImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceBindingUsageStatus")
		case "type":
			out.Values[i] = ec._ServiceBindingUsageStatus_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "reason":
			out.Values[i] = ec._ServiceBindingUsageStatus_reason(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "message":
			out.Values[i] = ec._ServiceBindingUsageStatus_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBindingUsageStatus_type(ctx context.Context, field graphql.CollectedField, obj *ServiceBindingUsageStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBindingUsageStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ServiceBindingUsageStatusType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBindingUsageStatus_reason(ctx context.Context, field graphql.CollectedField, obj *ServiceBindingUsageStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBindingUsageStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reason, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBindingUsageStatus_message(ctx context.Context, field graphql.CollectedField, obj *ServiceBindingUsageStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBindingUsageStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var serviceBindingsImplementors = []string{"ServiceBindings"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ServiceBindings(ctx context.Context, sel ast.SelectionSet, obj *ServiceBindings) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, serviceBindingsImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceBindings")
		case "items":
			out.Values[i] = ec._ServiceBindings_items(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "stats":
			out.Values[i] = ec._ServiceBindings_stats(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBindings_items(ctx context.Context, field graphql.CollectedField, obj *ServiceBindings) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBindings",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Items, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]ServiceBinding)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._ServiceBinding(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBindings_stats(ctx context.Context, field graphql.CollectedField, obj *ServiceBindings) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBindings",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Stats, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ServiceBindingsStats)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ServiceBindingsStats(ctx, field.Selections, &res)
}

var serviceBindingsStatsImplementors = []string{"ServiceBindingsStats"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ServiceBindingsStats(ctx context.Context, sel ast.SelectionSet, obj *ServiceBindingsStats) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, serviceBindingsStatsImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceBindingsStats")
		case "ready":
			out.Values[i] = ec._ServiceBindingsStats_ready(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "failed":
			out.Values[i] = ec._ServiceBindingsStats_failed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "pending":
			out.Values[i] = ec._ServiceBindingsStats_pending(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "unknown":
			out.Values[i] = ec._ServiceBindingsStats_unknown(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBindingsStats_ready(ctx context.Context, field graphql.CollectedField, obj *ServiceBindingsStats) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBindingsStats",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ready, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBindingsStats_failed(ctx context.Context, field graphql.CollectedField, obj *ServiceBindingsStats) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBindingsStats",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Failed, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBindingsStats_pending(ctx context.Context, field graphql.CollectedField, obj *ServiceBindingsStats) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBindingsStats",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Pending, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBindingsStats_unknown(ctx context.Context, field graphql.CollectedField, obj *ServiceBindingsStats) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBindingsStats",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Unknown, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

var serviceBrokerImplementors = []string{"ServiceBroker"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ServiceBroker(ctx context.Context, sel ast.SelectionSet, obj *ServiceBroker) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, serviceBrokerImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceBroker")
		case "name":
			out.Values[i] = ec._ServiceBroker_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "namespace":
			out.Values[i] = ec._ServiceBroker_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "status":
			out.Values[i] = ec._ServiceBroker_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "creationTimestamp":
			out.Values[i] = ec._ServiceBroker_creationTimestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "url":
			out.Values[i] = ec._ServiceBroker_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "labels":
			out.Values[i] = ec._ServiceBroker_labels(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBroker_name(ctx context.Context, field graphql.CollectedField, obj *ServiceBroker) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBroker",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBroker_namespace(ctx context.Context, field graphql.CollectedField, obj *ServiceBroker) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBroker",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBroker_status(ctx context.Context, field graphql.CollectedField, obj *ServiceBroker) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBroker",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ServiceBrokerStatus)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ServiceBrokerStatus(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBroker_creationTimestamp(ctx context.Context, field graphql.CollectedField, obj *ServiceBroker) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBroker",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTimestamp, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return MarshalTimestamp(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBroker_url(ctx context.Context, field graphql.CollectedField, obj *ServiceBroker) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBroker",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBroker_labels(ctx context.Context, field graphql.CollectedField, obj *ServiceBroker) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBroker",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Labels)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

var serviceBrokerEventImplementors = []string{"ServiceBrokerEvent"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ServiceBrokerEvent(ctx context.Context, sel ast.SelectionSet, obj *ServiceBrokerEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, serviceBrokerEventImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceBrokerEvent")
		case "type":
			out.Values[i] = ec._ServiceBrokerEvent_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "serviceBroker":
			out.Values[i] = ec._ServiceBrokerEvent_serviceBroker(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBrokerEvent_type(ctx context.Context, field graphql.CollectedField, obj *ServiceBrokerEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBrokerEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SubscriptionEventType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBrokerEvent_serviceBroker(ctx context.Context, field graphql.CollectedField, obj *ServiceBrokerEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBrokerEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServiceBroker, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ServiceBroker)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ServiceBroker(ctx, field.Selections, &res)
}

var serviceBrokerStatusImplementors = []string{"ServiceBrokerStatus"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ServiceBrokerStatus(ctx context.Context, sel ast.SelectionSet, obj *ServiceBrokerStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, serviceBrokerStatusImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceBrokerStatus")
		case "ready":
			out.Values[i] = ec._ServiceBrokerStatus_ready(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "reason":
			out.Values[i] = ec._ServiceBrokerStatus_reason(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "message":
			out.Values[i] = ec._ServiceBrokerStatus_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBrokerStatus_ready(ctx context.Context, field graphql.CollectedField, obj *ServiceBrokerStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBrokerStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ready, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBrokerStatus_reason(ctx context.Context, field graphql.CollectedField, obj *ServiceBrokerStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBrokerStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reason, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceBrokerStatus_message(ctx context.Context, field graphql.CollectedField, obj *ServiceBrokerStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceBrokerStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var serviceClassImplementors = []string{"ServiceClass"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ServiceClass(ctx context.Context, sel ast.SelectionSet, obj *ServiceClass) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, serviceClassImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceClass")
		case "name":
			out.Values[i] = ec._ServiceClass_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "namespace":
			out.Values[i] = ec._ServiceClass_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "externalName":
			out.Values[i] = ec._ServiceClass_externalName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "displayName":
			out.Values[i] = ec._ServiceClass_displayName(ctx, field, obj)
		case "creationTimestamp":
			out.Values[i] = ec._ServiceClass_creationTimestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec._ServiceClass_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "longDescription":
			out.Values[i] = ec._ServiceClass_longDescription(ctx, field, obj)
		case "imageUrl":
			out.Values[i] = ec._ServiceClass_imageUrl(ctx, field, obj)
		case "documentationUrl":
			out.Values[i] = ec._ServiceClass_documentationUrl(ctx, field, obj)
		case "supportUrl":
			out.Values[i] = ec._ServiceClass_supportUrl(ctx, field, obj)
		case "providerDisplayName":
			out.Values[i] = ec._ServiceClass_providerDisplayName(ctx, field, obj)
		case "tags":
			out.Values[i] = ec._ServiceClass_tags(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "labels":
			out.Values[i] = ec._ServiceClass_labels(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "plans":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ServiceClass_plans(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "activated":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ServiceClass_activated(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "instances":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ServiceClass_instances(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "clusterAssetGroup":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ServiceClass_clusterAssetGroup(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "assetGroup":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ServiceClass_assetGroup(ctx, field, obj)
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ServiceClass_name(ctx context.Context, field graphql.CollectedField, obj *ServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceClass_namespace(ctx context.Context, field graphql.CollectedField, obj *ServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceClass_externalName(ctx context.Context, field graphql.CollectedField, obj *ServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExternalName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceClass_displayName(ctx context.Context, field graphql.CollectedField, obj *ServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceClass_creationTimestamp(ctx context.Context, field graphql.CollectedField, obj *ServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTimestamp, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return MarshalTimestamp(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceClass_description(ctx context.Context, field graphql.CollectedField, obj *ServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceClass_longDescription(ctx context.Context, field graphql.CollectedField, obj *ServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LongDescription, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceClass_imageUrl(ctx context.Context, field graphql.CollectedField, obj *ServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImageURL, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceClass_documentationUrl(ctx context.Context, field graphql.CollectedField, obj *ServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DocumentationURL, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceClass_supportUrl(ctx context.Context, field graphql.CollectedField, obj *ServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SupportURL, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceClass_providerDisplayName(ctx context.Context, field graphql.CollectedField, obj *ServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProviderDisplayName, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceClass_tags(ctx context.Context, field graphql.CollectedField, obj *ServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tags, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return graphql.MarshalString(res[idx1])
		}()
	}

	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _ServiceClass_labels(ctx context.Context, field graphql.CollectedField, obj *ServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Labels)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _ServiceClass_plans(ctx context.Context, field graphql.CollectedField, obj *ServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ServiceClass().Plans(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]ServicePlan)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._ServicePlan(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _ServiceClass_activated(ctx context.Context, field graphql.CollectedField, obj *ServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ServiceClass().Activated(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceClass_instances(ctx context.Context, field graphql.CollectedField, obj *ServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ServiceClass().Instances(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]ServiceInstance)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._ServiceInstance(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _ServiceClass_clusterAssetGroup(ctx context.Context, field graphql.CollectedField, obj *ServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ServiceClass().ClusterAssetGroup(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ClusterAssetGroup)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ClusterAssetGroup(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceClass_assetGroup(ctx context.Context, field graphql.CollectedField, obj *ServiceClass) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceClass",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ServiceClass().AssetGroup(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*AssetGroup)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._AssetGroup(ctx, field.Selections, res)
}

var serviceEventImplementors = []string{"ServiceEvent"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ServiceEvent(ctx context.Context, sel ast.SelectionSet, obj *ServiceEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, serviceEventImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceEvent")
		case "type":
			out.Values[i] = ec._ServiceEvent_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "service":
			out.Values[i] = ec._ServiceEvent_service(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ServiceEvent_type(ctx context.Context, field graphql.CollectedField, obj *ServiceEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SubscriptionEventType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _ServiceEvent_service(ctx context.Context, field graphql.CollectedField, obj *ServiceEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Service, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Service)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Service(ctx, field.Selections, &res)
}

var serviceInstanceImplementors = []string{"ServiceInstance"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ServiceInstance(ctx context.Context, sel ast.SelectionSet, obj *ServiceInstance) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, serviceInstanceImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceInstance")
		case "name":
			out.Values[i] = ec._ServiceInstance_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "namespace":
			out.Values[i] = ec._ServiceInstance_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "planSpec":
			out.Values[i] = ec._ServiceInstance_planSpec(ctx, field, obj)
		case "creationTimestamp":
			out.Values[i] = ec._ServiceInstance_creationTimestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "labels":
			out.Values[i] = ec._ServiceInstance_labels(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "status":
			out.Values[i] = ec._ServiceInstance_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "classReference":
			out.Values[i] = ec._ServiceInstance_classReference(ctx, field, obj)
		case "planReference":
			out.Values[i] = ec._ServiceInstance_planReference(ctx, field, obj)
		case "serviceClass":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ServiceInstance_serviceClass(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "clusterServiceClass":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ServiceInstance_clusterServiceClass(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "servicePlan":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ServiceInstance_servicePlan(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "clusterServicePlan":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ServiceInstance_clusterServicePlan(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "bindable":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ServiceInstance_bindable(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "serviceBindings":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ServiceInstance_serviceBindings(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "serviceBindingUsages":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ServiceInstance_serviceBindingUsages(ctx, field, obj)
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ServiceInstance_name(ctx context.Context, field graphql.CollectedField, obj *ServiceInstance) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceInstance",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceInstance_namespace(ctx context.Context, field graphql.CollectedField, obj *ServiceInstance) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceInstance",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceInstance_planSpec(ctx context.Context, field graphql.CollectedField, obj *ServiceInstance) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceInstance",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PlanSpec, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*JSON)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return *res
}

// nolint: vetshadow
func (ec *executionContext) _ServiceInstance_creationTimestamp(ctx context.Context, field graphql.CollectedField, obj *ServiceInstance) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceInstance",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTimestamp, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return MarshalTimestamp(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceInstance_labels(ctx context.Context, field graphql.CollectedField, obj *ServiceInstance) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceInstance",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return graphql.MarshalString(res[idx1])
		}()
	}

	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _ServiceInstance_status(ctx context.Context, field graphql.CollectedField, obj *ServiceInstance) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceInstance",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ServiceInstanceStatus)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ServiceInstanceStatus(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceInstance_classReference(ctx context.Context, field graphql.CollectedField, obj *ServiceInstance) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceInstance",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClassReference, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ServiceInstanceResourceRef)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ServiceInstanceResourceRef(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceInstance_planReference(ctx context.Context, field graphql.CollectedField, obj *ServiceInstance) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceInstance",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PlanReference, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ServiceInstanceResourceRef)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ServiceInstanceResourceRef(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceInstance_serviceClass(ctx context.Context, field graphql.CollectedField, obj *ServiceInstance) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceInstance",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ServiceInstance().ServiceClass(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ServiceClass)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ServiceClass(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceInstance_clusterServiceClass(ctx context.Context, field graphql.CollectedField, obj *ServiceInstance) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceInstance",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ServiceInstance().ClusterServiceClass(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ClusterServiceClass)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ClusterServiceClass(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceInstance_servicePlan(ctx context.Context, field graphql.CollectedField, obj *ServiceInstance) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceInstance",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ServiceInstance().ServicePlan(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ServicePlan)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ServicePlan(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceInstance_clusterServicePlan(ctx context.Context, field graphql.CollectedField, obj *ServiceInstance) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceInstance",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ServiceInstance().ClusterServicePlan(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ClusterServicePlan)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ClusterServicePlan(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceInstance_bindable(ctx context.Context, field graphql.CollectedField, obj *ServiceInstance) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceInstance",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ServiceInstance().Bindable(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceInstance_serviceBindings(ctx context.Context, field graphql.CollectedField, obj *ServiceInstance) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceInstance",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ServiceInstance().ServiceBindings(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ServiceBindings)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ServiceBindings(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceInstance_serviceBindingUsages(ctx context.Context, field graphql.CollectedField, obj *ServiceInstance) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceInstance",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ServiceInstance().ServiceBindingUsages(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]ServiceBindingUsage)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._ServiceBindingUsage(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var serviceInstanceEventImplementors = []string{"ServiceInstanceEvent"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ServiceInstanceEvent(ctx context.Context, sel ast.SelectionSet, obj *ServiceInstanceEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, serviceInstanceEventImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceInstanceEvent")
		case "type":
			out.Values[i] = ec._ServiceInstanceEvent_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "serviceInstance":
			out.Values[i] = ec._ServiceInstanceEvent_serviceInstance(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ServiceInstanceEvent_type(ctx context.Context, field graphql.CollectedField, obj *ServiceInstanceEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceInstanceEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SubscriptionEventType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _ServiceInstanceEvent_serviceInstance(ctx context.Context, field graphql.CollectedField, obj *ServiceInstanceEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceInstanceEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServiceInstance, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ServiceInstance)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ServiceInstance(ctx, field.Selections, &res)
}

var serviceInstanceResourceRefImplementors = []string{"ServiceInstanceResourceRef"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ServiceInstanceResourceRef(ctx context.Context, sel ast.SelectionSet, obj *ServiceInstanceResourceRef) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, serviceInstanceResourceRefImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceInstanceResourceRef")
		case "name":
			out.Values[i] = ec._ServiceInstanceResourceRef_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "displayName":
			out.Values[i] = ec._ServiceInstanceResourceRef_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "clusterWide":
			out.Values[i] = ec._ServiceInstanceResourceRef_clusterWide(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ServiceInstanceResourceRef_name(ctx context.Context, field graphql.CollectedField, obj *ServiceInstanceResourceRef) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceInstanceResourceRef",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceInstanceResourceRef_displayName(ctx context.Context, field graphql.CollectedField, obj *ServiceInstanceResourceRef) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceInstanceResourceRef",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceInstanceResourceRef_clusterWide(ctx context.Context, field graphql.CollectedField, obj *ServiceInstanceResourceRef) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceInstanceResourceRef",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClusterWide, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

var serviceInstanceStatusImplementors = []string{"ServiceInstanceStatus"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ServiceInstanceStatus(ctx context.Context, sel ast.SelectionSet, obj *ServiceInstanceStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, serviceInstanceStatusImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceInstanceStatus")
		case "type":
			out.Values[i] = ec._ServiceInstanceStatus_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "reason":
			out.Values[i] = ec._ServiceInstanceStatus_reason(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "message":
			out.Values[i] = ec._ServiceInstanceStatus_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ServiceInstanceStatus_type(ctx context.Context, field graphql.CollectedField, obj *ServiceInstanceStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceInstanceStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(InstanceStatusType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _ServiceInstanceStatus_reason(ctx context.Context, field graphql.CollectedField, obj *ServiceInstanceStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceInstanceStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reason, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceInstanceStatus_message(ctx context.Context, field graphql.CollectedField, obj *ServiceInstanceStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceInstanceStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var servicePlanImplementors = []string{"ServicePlan"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ServicePlan(ctx context.Context, sel ast.SelectionSet, obj *ServicePlan) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, servicePlanImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServicePlan")
		case "name":
			out.Values[i] = ec._ServicePlan_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "namespace":
			out.Values[i] = ec._ServicePlan_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "displayName":
			out.Values[i] = ec._ServicePlan_displayName(ctx, field, obj)
		case "externalName":
			out.Values[i] = ec._ServicePlan_externalName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec._ServicePlan_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "relatedServiceClassName":
			out.Values[i] = ec._ServicePlan_relatedServiceClassName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "instanceCreateParameterSchema":
			out.Values[i] = ec._ServicePlan_instanceCreateParameterSchema(ctx, field, obj)
		case "bindingCreateParameterSchema":
			out.Values[i] = ec._ServicePlan_bindingCreateParameterSchema(ctx, field, obj)
		case "clusterAssetGroup":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ServicePlan_clusterAssetGroup(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "assetGroup":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ServicePlan_assetGroup(ctx, field, obj)
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ServicePlan_name(ctx context.Context, field graphql.CollectedField, obj *ServicePlan) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServicePlan",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServicePlan_namespace(ctx context.Context, field graphql.CollectedField, obj *ServicePlan) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServicePlan",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServicePlan_displayName(ctx context.Context, field graphql.CollectedField, obj *ServicePlan) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServicePlan",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ServicePlan_externalName(ctx context.Context, field graphql.CollectedField, obj *ServicePlan) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServicePlan",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExternalName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServicePlan_description(ctx context.Context, field graphql.CollectedField, obj *ServicePlan) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServicePlan",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServicePlan_relatedServiceClassName(ctx context.Context, field graphql.CollectedField, obj *ServicePlan) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServicePlan",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RelatedServiceClassName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServicePlan_instanceCreateParameterSchema(ctx context.Context, field graphql.CollectedField, obj *ServicePlan) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServicePlan",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InstanceCreateParameterSchema, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*JSON)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return *res
}

// nolint: vetshadow
func (ec *executionContext) _ServicePlan_bindingCreateParameterSchema(ctx context.Context, field graphql.CollectedField, obj *ServicePlan) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServicePlan",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BindingCreateParameterSchema, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*JSON)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return *res
}

// nolint: vetshadow
func (ec *executionContext) _ServicePlan_clusterAssetGroup(ctx context.Context, field graphql.CollectedField, obj *ServicePlan) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServicePlan",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ServicePlan().ClusterAssetGroup(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ClusterAssetGroup)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ClusterAssetGroup(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _ServicePlan_assetGroup(ctx context.Context, field graphql.CollectedField, obj *ServicePlan) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServicePlan",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ServicePlan().AssetGroup(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*AssetGroup)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._AssetGroup(ctx, field.Selections, res)
}

var servicePortImplementors = []string{"ServicePort"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ServicePort(ctx context.Context, sel ast.SelectionSet, obj *ServicePort) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, servicePortImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServicePort")
		case "name":
			out.Values[i] = ec._ServicePort_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "serviceProtocol":
			out.Values[i] = ec._ServicePort_serviceProtocol(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "port":
			out.Values[i] = ec._ServicePort_port(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "nodePort":
			out.Values[i] = ec._ServicePort_nodePort(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "targetPort":
			out.Values[i] = ec._ServicePort_targetPort(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ServicePort_name(ctx context.Context, field graphql.CollectedField, obj *ServicePort) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServicePort",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServicePort_serviceProtocol(ctx context.Context, field graphql.CollectedField, obj *ServicePort) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServicePort",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServiceProtocol, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ServiceProtocol)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _ServicePort_port(ctx context.Context, field graphql.CollectedField, obj *ServicePort) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServicePort",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Port, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServicePort_nodePort(ctx context.Context, field graphql.CollectedField, obj *ServicePort) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServicePort",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NodePort, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

// nolint: vetshadow
func (ec *executionContext) _ServicePort_targetPort(ctx context.Context, field graphql.CollectedField, obj *ServicePort) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServicePort",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TargetPort, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

var serviceStatusImplementors = []string{"ServiceStatus"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ServiceStatus(ctx context.Context, sel ast.SelectionSet, obj *ServiceStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, serviceStatusImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceStatus")
		case "loadBalancer":
			out.Values[i] = ec._ServiceStatus_loadBalancer(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ServiceStatus_loadBalancer(ctx context.Context, field graphql.CollectedField, obj *ServiceStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LoadBalancer, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(LoadBalancerStatus)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._LoadBalancerStatus(ctx, field.Selections, &res)
}

var subscriberImplementors = []string{"Subscriber"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Subscriber(ctx context.Context, sel ast.SelectionSet, obj *Subscriber) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, subscriberImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Subscriber")
		case "uri":
			out.Values[i] = ec._Subscriber_uri(ctx, field, obj)
		case "ref":
			out.Values[i] = ec._Subscriber_ref(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Subscriber_uri(ctx context.Context, field graphql.CollectedField, obj *Subscriber) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Subscriber",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URI, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Subscriber_ref(ctx context.Context, field graphql.CollectedField, obj *Subscriber) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Subscriber",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ref, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*SubscriberRef)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._SubscriberRef(ctx, field.Selections, res)
}

var subscriberRefImplementors = []string{"SubscriberRef"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _SubscriberRef(ctx context.Context, sel ast.SelectionSet, obj *SubscriberRef) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, subscriberRefImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SubscriberRef")
		case "apiVersion":
			out.Values[i] = ec._SubscriberRef_apiVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "kind":
			out.Values[i] = ec._SubscriberRef_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "name":
			out.Values[i] = ec._SubscriberRef_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "namespace":
			out.Values[i] = ec._SubscriberRef_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _SubscriberRef_apiVersion(ctx context.Context, field graphql.CollectedField, obj *SubscriberRef) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "SubscriberRef",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.APIVersion, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _SubscriberRef_kind(ctx context.Context, field graphql.CollectedField, obj *SubscriberRef) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "SubscriberRef",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _SubscriberRef_name(ctx context.Context, field graphql.CollectedField, obj *SubscriberRef) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "SubscriberRef",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _SubscriberRef_namespace(ctx context.Context, field graphql.CollectedField, obj *SubscriberRef) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "SubscriberRef",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var subscriptionImplementors = []string{"Subscription"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Subscription(ctx context.Context, sel ast.SelectionSet) func() graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, subscriptionImplementors)
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Subscription",
	})
	if len(fields) != 1 {
		ec.Errorf(ctx, "must subscribe to exactly one stream")
		return nil
	}

	switch fields[0].Name {
	case "clusterAssetEvent":
		return ec._Subscription_clusterAssetEvent(ctx, fields[0])
	case "assetEvent":
		return ec._Subscription_assetEvent(ctx, fields[0])
	case "clusterAssetGroupEvent":
		return ec._Subscription_clusterAssetGroupEvent(ctx, fields[0])
	case "assetGroupEvent":
		return ec._Subscription_assetGroupEvent(ctx, fields[0])
	case "serviceInstanceEvent":
		return ec._Subscription_serviceInstanceEvent(ctx, fields[0])
	case "serviceBindingEvent":
		return ec._Subscription_serviceBindingEvent(ctx, fields[0])
	case "serviceBindingUsageEvent":
		return ec._Subscription_serviceBindingUsageEvent(ctx, fields[0])
	case "serviceBrokerEvent":
		return ec._Subscription_serviceBrokerEvent(ctx, fields[0])
	case "clusterServiceBrokerEvent":
		return ec._Subscription_clusterServiceBrokerEvent(ctx, fields[0])
	case "applicationEvent":
		return ec._Subscription_applicationEvent(ctx, fields[0])
	case "podEvent":
		return ec._Subscription_podEvent(ctx, fields[0])
	case "serviceEvent":
		return ec._Subscription_serviceEvent(ctx, fields[0])
	case "configMapEvent":
		return ec._Subscription_configMapEvent(ctx, fields[0])
	case "clusterAddonsConfigurationEvent":
		return ec._Subscription_clusterAddonsConfigurationEvent(ctx, fields[0])
	case "addonsConfigurationEvent":
		return ec._Subscription_addonsConfigurationEvent(ctx, fields[0])
	case "apiRuleEvent":
		return ec._Subscription_apiRuleEvent(ctx, fields[0])
	case "namespaceEvent":
		return ec._Subscription_namespaceEvent(ctx, fields[0])
	case "functionEvent":
		return ec._Subscription_functionEvent(ctx, fields[0])
	case "triggerEvent":
		return ec._Subscription_triggerEvent(ctx, fields[0])
	default:
		panic("unknown field " + strconv.Quote(fields[0].Name))
	}
}

func (ec *executionContext) _Subscription_clusterAssetEvent(ctx context.Context, field graphql.CollectedField) func() graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Field: field,
	})
	// FIXME: subscriptions are missing request middleware stack https://github.com/99designs/gqlgen/issues/259
	//          and Tracer stack
	rctx := ctx
	results, err := ec.resolvers.Subscription().ClusterAssetEvent(rctx)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-results
		if !ok {
			return nil
		}
		var out graphql.OrderedMap
		out.Add(field.Alias, func() graphql.Marshaler {
			return ec._ClusterAssetEvent(ctx, field.Selections, &res)
		}())
		return &out
	}
}

func (ec *executionContext) _Subscription_assetEvent(ctx context.Context, field graphql.CollectedField) func() graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Subscription_assetEvent_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Field: field,
	})
	// FIXME: subscriptions are missing request middleware stack https://github.com/99designs/gqlgen/issues/259
	//          and Tracer stack
	rctx := ctx
	results, err := ec.resolvers.Subscription().AssetEvent(rctx, args["namespace"].(string))
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-results
		if !ok {
			return nil
		}
		var out graphql.OrderedMap
		out.Add(field.Alias, func() graphql.Marshaler {
			return ec._AssetEvent(ctx, field.Selections, &res)
		}())
		return &out
	}
}

func (ec *executionContext) _Subscription_clusterAssetGroupEvent(ctx context.Context, field graphql.CollectedField) func() graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Field: field,
	})
	// FIXME: subscriptions are missing request middleware stack https://github.com/99designs/gqlgen/issues/259
	//          and Tracer stack
	rctx := ctx
	results, err := ec.resolvers.Subscription().ClusterAssetGroupEvent(rctx)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-results
		if !ok {
			return nil
		}
		var out graphql.OrderedMap
		out.Add(field.Alias, func() graphql.Marshaler {
			return ec._ClusterAssetGroupEvent(ctx, field.Selections, &res)
		}())
		return &out
	}
}

func (ec *executionContext) _Subscription_assetGroupEvent(ctx context.Context, field graphql.CollectedField) func() graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Subscription_assetGroupEvent_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Field: field,
	})
	// FIXME: subscriptions are missing request middleware stack https://github.com/99designs/gqlgen/issues/259
	//          and Tracer stack
	rctx := ctx
	results, err := ec.resolvers.Subscription().AssetGroupEvent(rctx, args["namespace"].(string))
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-results
		if !ok {
			return nil
		}
		var out graphql.OrderedMap
		out.Add(field.Alias, func() graphql.Marshaler {
			return ec._AssetGroupEvent(ctx, field.Selections, &res)
		}())
		return &out
	}
}

func (ec *executionContext) _Subscription_serviceInstanceEvent(ctx context.Context, field graphql.CollectedField) func() graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Subscription_serviceInstanceEvent_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Field: field,
	})
	// FIXME: subscriptions are missing request middleware stack https://github.com/99designs/gqlgen/issues/259
	//          and Tracer stack
	rctx := ctx
	results, err := ec.resolvers.Subscription().ServiceInstanceEvent(rctx, args["namespace"].(string))
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-results
		if !ok {
			return nil
		}
		var out graphql.OrderedMap
		out.Add(field.Alias, func() graphql.Marshaler {
			return ec._ServiceInstanceEvent(ctx, field.Selections, &res)
		}())
		return &out
	}
}

func (ec *executionContext) _Subscription_serviceBindingEvent(ctx context.Context, field graphql.CollectedField) func() graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Subscription_serviceBindingEvent_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Field: field,
	})
	// FIXME: subscriptions are missing request middleware stack https://github.com/99designs/gqlgen/issues/259
	//          and Tracer stack
	rctx := ctx
	results, err := ec.resolvers.Subscription().ServiceBindingEvent(rctx, args["namespace"].(string))
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-results
		if !ok {
			return nil
		}
		var out graphql.OrderedMap
		out.Add(field.Alias, func() graphql.Marshaler {
			return ec._ServiceBindingEvent(ctx, field.Selections, &res)
		}())
		return &out
	}
}

func (ec *executionContext) _Subscription_serviceBindingUsageEvent(ctx context.Context, field graphql.CollectedField) func() graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Subscription_serviceBindingUsageEvent_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Field: field,
	})
	// FIXME: subscriptions are missing request middleware stack https://github.com/99designs/gqlgen/issues/259
	//          and Tracer stack
	rctx := ctx
	results, err := ec.resolvers.Subscription().ServiceBindingUsageEvent(rctx, args["namespace"].(string), args["resourceKind"].(*string), args["resourceName"].(*string))
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-results
		if !ok {
			return nil
		}
		var out graphql.OrderedMap
		out.Add(field.Alias, func() graphql.Marshaler {
			return ec._ServiceBindingUsageEvent(ctx, field.Selections, &res)
		}())
		return &out
	}
}

func (ec *executionContext) _Subscription_serviceBrokerEvent(ctx context.Context, field graphql.CollectedField) func() graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Subscription_serviceBrokerEvent_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Field: field,
	})
	// FIXME: subscriptions are missing request middleware stack https://github.com/99designs/gqlgen/issues/259
	//          and Tracer stack
	rctx := ctx
	results, err := ec.resolvers.Subscription().ServiceBrokerEvent(rctx, args["namespace"].(string))
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-results
		if !ok {
			return nil
		}
		var out graphql.OrderedMap
		out.Add(field.Alias, func() graphql.Marshaler {
			return ec._ServiceBrokerEvent(ctx, field.Selections, &res)
		}())
		return &out
	}
}

func (ec *executionContext) _Subscription_clusterServiceBrokerEvent(ctx context.Context, field graphql.CollectedField) func() graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Field: field,
	})
	// FIXME: subscriptions are missing request middleware stack https://github.com/99designs/gqlgen/issues/259
	//          and Tracer stack
	rctx := ctx
	results, err := ec.resolvers.Subscription().ClusterServiceBrokerEvent(rctx)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-results
		if !ok {
			return nil
		}
		var out graphql.OrderedMap
		out.Add(field.Alias, func() graphql.Marshaler {
			return ec._ClusterServiceBrokerEvent(ctx, field.Selections, &res)
		}())
		return &out
	}
}

func (ec *executionContext) _Subscription_applicationEvent(ctx context.Context, field graphql.CollectedField) func() graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Field: field,
	})
	// FIXME: subscriptions are missing request middleware stack https://github.com/99designs/gqlgen/issues/259
	//          and Tracer stack
	rctx := ctx
	results, err := ec.resolvers.Subscription().ApplicationEvent(rctx)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-results
		if !ok {
			return nil
		}
		var out graphql.OrderedMap
		out.Add(field.Alias, func() graphql.Marshaler {
			return ec._ApplicationEvent(ctx, field.Selections, &res)
		}())
		return &out
	}
}

func (ec *executionContext) _Subscription_podEvent(ctx context.Context, field graphql.CollectedField) func() graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Subscription_podEvent_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Field: field,
	})
	// FIXME: subscriptions are missing request middleware stack https://github.com/99designs/gqlgen/issues/259
	//          and Tracer stack
	rctx := ctx
	results, err := ec.resolvers.Subscription().PodEvent(rctx, args["namespace"].(string))
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-results
		if !ok {
			return nil
		}
		var out graphql.OrderedMap
		out.Add(field.Alias, func() graphql.Marshaler {
			return ec._PodEvent(ctx, field.Selections, &res)
		}())
		return &out
	}
}

func (ec *executionContext) _Subscription_serviceEvent(ctx context.Context, field graphql.CollectedField) func() graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Subscription_serviceEvent_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Field: field,
	})
	// FIXME: subscriptions are missing request middleware stack https://github.com/99designs/gqlgen/issues/259
	//          and Tracer stack
	rctx := ctx
	results, err := ec.resolvers.Subscription().ServiceEvent(rctx, args["namespace"].(string))
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-results
		if !ok {
			return nil
		}
		var out graphql.OrderedMap
		out.Add(field.Alias, func() graphql.Marshaler {
			return ec._ServiceEvent(ctx, field.Selections, &res)
		}())
		return &out
	}
}

func (ec *executionContext) _Subscription_configMapEvent(ctx context.Context, field graphql.CollectedField) func() graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Subscription_configMapEvent_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Field: field,
	})
	// FIXME: subscriptions are missing request middleware stack https://github.com/99designs/gqlgen/issues/259
	//          and Tracer stack
	rctx := ctx
	results, err := ec.resolvers.Subscription().ConfigMapEvent(rctx, args["namespace"].(string))
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-results
		if !ok {
			return nil
		}
		var out graphql.OrderedMap
		out.Add(field.Alias, func() graphql.Marshaler {
			return ec._ConfigMapEvent(ctx, field.Selections, &res)
		}())
		return &out
	}
}

func (ec *executionContext) _Subscription_clusterAddonsConfigurationEvent(ctx context.Context, field graphql.CollectedField) func() graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Field: field,
	})
	// FIXME: subscriptions are missing request middleware stack https://github.com/99designs/gqlgen/issues/259
	//          and Tracer stack
	rctx := ctx
	results, err := ec.resolvers.Subscription().ClusterAddonsConfigurationEvent(rctx)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-results
		if !ok {
			return nil
		}
		var out graphql.OrderedMap
		out.Add(field.Alias, func() graphql.Marshaler {
			return ec._ClusterAddonsConfigurationEvent(ctx, field.Selections, &res)
		}())
		return &out
	}
}

func (ec *executionContext) _Subscription_addonsConfigurationEvent(ctx context.Context, field graphql.CollectedField) func() graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Subscription_addonsConfigurationEvent_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Field: field,
	})
	// FIXME: subscriptions are missing request middleware stack https://github.com/99designs/gqlgen/issues/259
	//          and Tracer stack
	rctx := ctx
	results, err := ec.resolvers.Subscription().AddonsConfigurationEvent(rctx, args["namespace"].(string))
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-results
		if !ok {
			return nil
		}
		var out graphql.OrderedMap
		out.Add(field.Alias, func() graphql.Marshaler {
			return ec._AddonsConfigurationEvent(ctx, field.Selections, &res)
		}())
		return &out
	}
}

func (ec *executionContext) _Subscription_apiRuleEvent(ctx context.Context, field graphql.CollectedField) func() graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Subscription_apiRuleEvent_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Field: field,
	})
	// FIXME: subscriptions are missing request middleware stack https://github.com/99designs/gqlgen/issues/259
	//          and Tracer stack
	rctx := ctx
	results, err := ec.resolvers.Subscription().APIRuleEvent(rctx, args["namespace"].(string), args["serviceName"].(*string))
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-results
		if !ok {
			return nil
		}
		var out graphql.OrderedMap
		out.Add(field.Alias, func() graphql.Marshaler {
			return ec._ApiRuleEvent(ctx, field.Selections, &res)
		}())
		return &out
	}
}

func (ec *executionContext) _Subscription_namespaceEvent(ctx context.Context, field graphql.CollectedField) func() graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Subscription_namespaceEvent_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Field: field,
	})
	// FIXME: subscriptions are missing request middleware stack https://github.com/99designs/gqlgen/issues/259
	//          and Tracer stack
	rctx := ctx
	results, err := ec.resolvers.Subscription().NamespaceEvent(rctx, args["withSystemNamespaces"].(*bool))
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-results
		if !ok {
			return nil
		}
		var out graphql.OrderedMap
		out.Add(field.Alias, func() graphql.Marshaler {
			return ec._NamespaceEvent(ctx, field.Selections, &res)
		}())
		return &out
	}
}

func (ec *executionContext) _Subscription_functionEvent(ctx context.Context, field graphql.CollectedField) func() graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Subscription_functionEvent_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Field: field,
	})
	// FIXME: subscriptions are missing request middleware stack https://github.com/99designs/gqlgen/issues/259
	//          and Tracer stack
	rctx := ctx
	results, err := ec.resolvers.Subscription().FunctionEvent(rctx, args["namespace"].(string), args["functionName"].(*string))
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-results
		if !ok {
			return nil
		}
		var out graphql.OrderedMap
		out.Add(field.Alias, func() graphql.Marshaler {
			return ec._FunctionEvent(ctx, field.Selections, &res)
		}())
		return &out
	}
}

func (ec *executionContext) _Subscription_triggerEvent(ctx context.Context, field graphql.CollectedField) func() graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Subscription_triggerEvent_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Field: field,
	})
	// FIXME: subscriptions are missing request middleware stack https://github.com/99designs/gqlgen/issues/259
	//          and Tracer stack
	rctx := ctx
	results, err := ec.resolvers.Subscription().TriggerEvent(rctx, args["namespace"].(string), args["subscriber"].(*SubscriberInput))
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-results
		if !ok {
			return nil
		}
		var out graphql.OrderedMap
		out.Add(field.Alias, func() graphql.Marshaler {
			return ec._TriggerEvent(ctx, field.Selections, &res)
		}())
		return &out
	}
}

var triggerImplementors = []string{"Trigger"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Trigger(ctx context.Context, sel ast.SelectionSet, obj *Trigger) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, triggerImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Trigger")
		case "name":
			out.Values[i] = ec._Trigger_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "namespace":
			out.Values[i] = ec._Trigger_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "broker":
			out.Values[i] = ec._Trigger_broker(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "filterAttributes":
			out.Values[i] = ec._Trigger_filterAttributes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "subscriber":
			out.Values[i] = ec._Trigger_subscriber(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "status":
			out.Values[i] = ec._Trigger_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Trigger_name(ctx context.Context, field graphql.CollectedField, obj *Trigger) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Trigger",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Trigger_namespace(ctx context.Context, field graphql.CollectedField, obj *Trigger) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Trigger",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Trigger_broker(ctx context.Context, field graphql.CollectedField, obj *Trigger) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Trigger",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Broker, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Trigger_filterAttributes(ctx context.Context, field graphql.CollectedField, obj *Trigger) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Trigger",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FilterAttributes, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(JSON)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _Trigger_subscriber(ctx context.Context, field graphql.CollectedField, obj *Trigger) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Trigger",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Subscriber, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Subscriber)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Subscriber(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Trigger_status(ctx context.Context, field graphql.CollectedField, obj *Trigger) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Trigger",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(TriggerStatus)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._TriggerStatus(ctx, field.Selections, &res)
}

var triggerEventImplementors = []string{"TriggerEvent"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _TriggerEvent(ctx context.Context, sel ast.SelectionSet, obj *TriggerEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, triggerEventImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TriggerEvent")
		case "type":
			out.Values[i] = ec._TriggerEvent_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "trigger":
			out.Values[i] = ec._TriggerEvent_trigger(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _TriggerEvent_type(ctx context.Context, field graphql.CollectedField, obj *TriggerEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "TriggerEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SubscriptionEventType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _TriggerEvent_trigger(ctx context.Context, field graphql.CollectedField, obj *TriggerEvent) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "TriggerEvent",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Trigger, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Trigger)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Trigger(ctx, field.Selections, &res)
}

var triggerMetadataImplementors = []string{"TriggerMetadata"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _TriggerMetadata(ctx context.Context, sel ast.SelectionSet, obj *TriggerMetadata) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, triggerMetadataImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TriggerMetadata")
		case "name":
			out.Values[i] = ec._TriggerMetadata_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "namespace":
			out.Values[i] = ec._TriggerMetadata_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _TriggerMetadata_name(ctx context.Context, field graphql.CollectedField, obj *TriggerMetadata) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "TriggerMetadata",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _TriggerMetadata_namespace(ctx context.Context, field graphql.CollectedField, obj *TriggerMetadata) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "TriggerMetadata",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var triggerStatusImplementors = []string{"TriggerStatus"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _TriggerStatus(ctx context.Context, sel ast.SelectionSet, obj *TriggerStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, triggerStatusImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TriggerStatus")
		case "reason":
			out.Values[i] = ec._TriggerStatus_reason(ctx, field, obj)
		case "status":
			out.Values[i] = ec._TriggerStatus_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _TriggerStatus_reason(ctx context.Context, field graphql.CollectedField, obj *TriggerStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "TriggerStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reason, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return graphql.MarshalString(res[idx1])
		}()
	}

	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _TriggerStatus_status(ctx context.Context, field graphql.CollectedField, obj *TriggerStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "TriggerStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(TriggerStatusType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

var usageKindImplementors = []string{"UsageKind"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _UsageKind(ctx context.Context, sel ast.SelectionSet, obj *UsageKind) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, usageKindImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UsageKind")
		case "name":
			out.Values[i] = ec._UsageKind_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "group":
			out.Values[i] = ec._UsageKind_group(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "kind":
			out.Values[i] = ec._UsageKind_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "version":
			out.Values[i] = ec._UsageKind_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "displayName":
			out.Values[i] = ec._UsageKind_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _UsageKind_name(ctx context.Context, field graphql.CollectedField, obj *UsageKind) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "UsageKind",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _UsageKind_group(ctx context.Context, field graphql.CollectedField, obj *UsageKind) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "UsageKind",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Group, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _UsageKind_kind(ctx context.Context, field graphql.CollectedField, obj *UsageKind) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "UsageKind",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _UsageKind_version(ctx context.Context, field graphql.CollectedField, obj *UsageKind) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "UsageKind",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _UsageKind_displayName(ctx context.Context, field graphql.CollectedField, obj *UsageKind) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "UsageKind",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var usageKindResourceImplementors = []string{"UsageKindResource"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _UsageKindResource(ctx context.Context, sel ast.SelectionSet, obj *UsageKindResource) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, usageKindResourceImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UsageKindResource")
		case "name":
			out.Values[i] = ec._UsageKindResource_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "namespace":
			out.Values[i] = ec._UsageKindResource_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _UsageKindResource_name(ctx context.Context, field graphql.CollectedField, obj *UsageKindResource) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "UsageKindResource",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _UsageKindResource_namespace(ctx context.Context, field graphql.CollectedField, obj *UsageKindResource) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "UsageKindResource",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var versionInfoImplementors = []string{"VersionInfo"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _VersionInfo(ctx context.Context, sel ast.SelectionSet, obj *VersionInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, versionInfoImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VersionInfo")
		case "kymaVersion":
			out.Values[i] = ec._VersionInfo_kymaVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _VersionInfo_kymaVersion(ctx context.Context, field graphql.CollectedField, obj *VersionInfo) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "VersionInfo",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.KymaVersion, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var __DirectiveImplementors = []string{"__Directive"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __DirectiveImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Directive",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Directive",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Directive",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return graphql.MarshalString(res[idx1])
		}()
	}

	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Directive",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___InputValue(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var __EnumValueImplementors = []string{"__EnumValue"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __EnumValueImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__EnumValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__EnumValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__EnumValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__EnumValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var __FieldImplementors = []string{"__Field"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __FieldImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___InputValue(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var __InputValueImplementors = []string{"__InputValue"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __InputValueImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__InputValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__InputValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__InputValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__InputValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var __SchemaImplementors = []string{"__Schema"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __SchemaImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___Type(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___Directive(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var __TypeImplementors = []string{"__Type"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __TypeImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field___Type_fields_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(args["includeDeprecated"].(bool)), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___Field(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___Type(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___Type(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field___Type_enumValues_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(args["includeDeprecated"].(bool)), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___EnumValue(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___InputValue(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

var compassMetadataImplementors = []string{"compassMetadata"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _compassMetadata(ctx context.Context, sel ast.SelectionSet, obj *CompassMetadata) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, compassMetadataImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("compassMetadata")
		case "applicationId":
			out.Values[i] = ec._compassMetadata_applicationId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _compassMetadata_applicationId(ctx context.Context, field graphql.CollectedField, obj *CompassMetadata) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "compassMetadata",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ApplicationID, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var enabledMappingServiceImplementors = []string{"enabledMappingService"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _enabledMappingService(ctx context.Context, sel ast.SelectionSet, obj *EnabledMappingService) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, enabledMappingServiceImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("enabledMappingService")
		case "namespace":
			out.Values[i] = ec._enabledMappingService_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "allServices":
			out.Values[i] = ec._enabledMappingService_allServices(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "services":
			out.Values[i] = ec._enabledMappingService_services(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _enabledMappingService_namespace(ctx context.Context, field graphql.CollectedField, obj *EnabledMappingService) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "enabledMappingService",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _enabledMappingService_allServices(ctx context.Context, field graphql.CollectedField, obj *EnabledMappingService) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "enabledMappingService",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AllServices, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) _enabledMappingService_services(ctx context.Context, field graphql.CollectedField, obj *EnabledMappingService) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "enabledMappingService",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Services, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*EnabledApplicationService)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				if res[idx1] == nil {
					return graphql.Null
				}

				return ec._EnabledApplicationService(ctx, field.Selections, res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

func UnmarshalAPIRuleConfigInput(v interface{}) (APIRuleConfigInput, error) {
	var it APIRuleConfigInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "config":
			var err error
			err = (&it.Config).UnmarshalGQL(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalAPIRuleInput(v interface{}) (APIRuleInput, error) {
	var it APIRuleInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "host":
			var err error
			it.Host, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "serviceName":
			var err error
			it.ServiceName, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "servicePort":
			var err error
			it.ServicePort, err = graphql.UnmarshalInt(v)
			if err != nil {
				return it, err
			}
		case "gateway":
			var err error
			it.Gateway, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "rules":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Rules = make([]RuleInput, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Rules[idx1], err = UnmarshalRuleInput(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalAddonsConfigurationRepositoryInput(v interface{}) (AddonsConfigurationRepositoryInput, error) {
	var it AddonsConfigurationRepositoryInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "url":
			var err error
			it.URL, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "secretRef":
			var err error
			var ptr1 ResourceRefInput
			if v != nil {
				ptr1, err = UnmarshalResourceRefInput(v)
				it.SecretRef = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalCreateServiceBindingUsageInput(v interface{}) (CreateServiceBindingUsageInput, error) {
	var it CreateServiceBindingUsageInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Name = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "serviceBindingRef":
			var err error
			it.ServiceBindingRef, err = UnmarshalServiceBindingRefInput(v)
			if err != nil {
				return it, err
			}
		case "usedBy":
			var err error
			it.UsedBy, err = UnmarshalLocalObjectReferenceInput(v)
			if err != nil {
				return it, err
			}
		case "parameters":
			var err error
			var ptr1 ServiceBindingUsageParametersInput
			if v != nil {
				ptr1, err = UnmarshalServiceBindingUsageParametersInput(v)
				it.Parameters = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalEnvPrefixInput(v interface{}) (EnvPrefixInput, error) {
	var it EnvPrefixInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalFunctionEnvInput(v interface{}) (FunctionEnvInput, error) {
	var it FunctionEnvInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "value":
			var err error
			it.Value, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "valueFrom":
			var err error
			var ptr1 FunctionEnvValueFromInput
			if v != nil {
				ptr1, err = UnmarshalFunctionEnvValueFromInput(v)
				it.ValueFrom = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalFunctionEnvValueFromInput(v interface{}) (FunctionEnvValueFromInput, error) {
	var it FunctionEnvValueFromInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "type":
			var err error
			err = (&it.Type).UnmarshalGQL(v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "key":
			var err error
			it.Key, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "optional":
			var err error
			var ptr1 bool
			if v != nil {
				ptr1, err = graphql.UnmarshalBoolean(v)
				it.Optional = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalFunctionMetadataInput(v interface{}) (FunctionMetadataInput, error) {
	var it FunctionMetadataInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "namespace":
			var err error
			it.Namespace, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalFunctionMutationInput(v interface{}) (FunctionMutationInput, error) {
	var it FunctionMutationInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "labels":
			var err error
			err = (&it.Labels).UnmarshalGQL(v)
			if err != nil {
				return it, err
			}
		case "source":
			var err error
			it.Source, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "dependencies":
			var err error
			it.Dependencies, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "env":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Env = make([]FunctionEnvInput, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Env[idx1], err = UnmarshalFunctionEnvInput(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		case "replicas":
			var err error
			it.Replicas, err = UnmarshalFunctionReplicasInput(v)
			if err != nil {
				return it, err
			}
		case "resources":
			var err error
			it.Resources, err = UnmarshalFunctionResourcesInput(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalFunctionReplicasInput(v interface{}) (FunctionReplicasInput, error) {
	var it FunctionReplicasInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "min":
			var err error
			var ptr1 int
			if v != nil {
				ptr1, err = graphql.UnmarshalInt(v)
				it.Min = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "max":
			var err error
			var ptr1 int
			if v != nil {
				ptr1, err = graphql.UnmarshalInt(v)
				it.Max = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalFunctionResourcesInput(v interface{}) (FunctionResourcesInput, error) {
	var it FunctionResourcesInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "limits":
			var err error
			it.Limits, err = UnmarshalResourceValuesInput(v)
			if err != nil {
				return it, err
			}
		case "requests":
			var err error
			it.Requests, err = UnmarshalResourceValuesInput(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalLimitRangeInput(v interface{}) (LimitRangeInput, error) {
	var it LimitRangeInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "default":
			var err error
			it.Default, err = UnmarshalResourceValuesInput(v)
			if err != nil {
				return it, err
			}
		case "defaultRequest":
			var err error
			it.DefaultRequest, err = UnmarshalResourceValuesInput(v)
			if err != nil {
				return it, err
			}
		case "max":
			var err error
			it.Max, err = UnmarshalResourceValuesInput(v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error
			it.Type, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalLocalObjectReferenceInput(v interface{}) (LocalObjectReferenceInput, error) {
	var it LocalObjectReferenceInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "kind":
			var err error
			it.Kind, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalOwnerReference(v interface{}) (OwnerReference, error) {
	var it OwnerReference
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "apiVersion":
			var err error
			it.APIVersion, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "blockOwnerDeletion":
			var err error
			var ptr1 bool
			if v != nil {
				ptr1, err = graphql.UnmarshalBoolean(v)
				it.BlockOwnerDeletion = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "controller":
			var err error
			var ptr1 bool
			if v != nil {
				ptr1, err = graphql.UnmarshalBoolean(v)
				it.Controller = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "kind":
			var err error
			it.Kind, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "UID":
			var err error
			it.UID, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalResourceAttributes(v interface{}) (ResourceAttributes, error) {
	var it ResourceAttributes
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "verb":
			var err error
			it.Verb, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "apiGroup":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.APIGroup = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "apiVersion":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.APIVersion = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "resource":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Resource = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "resourceArg":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.ResourceArg = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "subresource":
			var err error
			it.Subresource, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "nameArg":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.NameArg = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "namespaceArg":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.NamespaceArg = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "isChildResolver":
			var err error
			it.IsChildResolver, err = graphql.UnmarshalBoolean(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalResourceQuotaInput(v interface{}) (ResourceQuotaInput, error) {
	var it ResourceQuotaInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "limits":
			var err error
			it.Limits, err = UnmarshalResourceValuesInput(v)
			if err != nil {
				return it, err
			}
		case "requests":
			var err error
			it.Requests, err = UnmarshalResourceValuesInput(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalResourceRefInput(v interface{}) (ResourceRefInput, error) {
	var it ResourceRefInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "namespace":
			var err error
			it.Namespace, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalResourceValuesInput(v interface{}) (ResourceValuesInput, error) {
	var it ResourceValuesInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "memory":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Memory = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "cpu":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.CPU = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalRuleInput(v interface{}) (RuleInput, error) {
	var it RuleInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "path":
			var err error
			it.Path, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "methods":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Methods = make([]string, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Methods[idx1], err = graphql.UnmarshalString(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		case "accessStrategies":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.AccessStrategies = make([]APIRuleConfigInput, len(rawIf1))
			for idx1 := range rawIf1 {
				it.AccessStrategies[idx1], err = UnmarshalAPIRuleConfigInput(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		case "mutators":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Mutators = make([]APIRuleConfigInput, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Mutators[idx1], err = UnmarshalAPIRuleConfigInput(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalServiceBindingRefInput(v interface{}) (ServiceBindingRefInput, error) {
	var it ServiceBindingRefInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalServiceBindingUsageParametersInput(v interface{}) (ServiceBindingUsageParametersInput, error) {
	var it ServiceBindingUsageParametersInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "envPrefix":
			var err error
			var ptr1 EnvPrefixInput
			if v != nil {
				ptr1, err = UnmarshalEnvPrefixInput(v)
				it.EnvPrefix = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalServiceInstanceCreateInput(v interface{}) (ServiceInstanceCreateInput, error) {
	var it ServiceInstanceCreateInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "classRef":
			var err error
			it.ClassRef, err = UnmarshalServiceInstanceCreateInputResourceRef(v)
			if err != nil {
				return it, err
			}
		case "planRef":
			var err error
			it.PlanRef, err = UnmarshalServiceInstanceCreateInputResourceRef(v)
			if err != nil {
				return it, err
			}
		case "labels":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Labels = make([]string, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Labels[idx1], err = graphql.UnmarshalString(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		case "parameterSchema":
			var err error
			var ptr1 JSON
			if v != nil {
				err = (&ptr1).UnmarshalGQL(v)
				it.ParameterSchema = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalServiceInstanceCreateInputResourceRef(v interface{}) (ServiceInstanceCreateInputResourceRef, error) {
	var it ServiceInstanceCreateInputResourceRef
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "externalName":
			var err error
			it.ExternalName, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "clusterWide":
			var err error
			it.ClusterWide, err = graphql.UnmarshalBoolean(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalSubscriberInput(v interface{}) (SubscriberInput, error) {
	var it SubscriberInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "uri":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.URI = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "ref":
			var err error
			var ptr1 SubscriberRefInput
			if v != nil {
				ptr1, err = UnmarshalSubscriberRefInput(v)
				it.Ref = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalSubscriberRefInput(v interface{}) (SubscriberRefInput, error) {
	var it SubscriberRefInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "apiVersion":
			var err error
			it.APIVersion, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "kind":
			var err error
			it.Kind, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "namespace":
			var err error
			it.Namespace, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalTriggerCreateInput(v interface{}) (TriggerCreateInput, error) {
	var it TriggerCreateInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Name = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "namespace":
			var err error
			it.Namespace, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "broker":
			var err error
			it.Broker, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "filterAttributes":
			var err error
			var ptr1 JSON
			if v != nil {
				err = (&ptr1).UnmarshalGQL(v)
				it.FilterAttributes = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "subscriber":
			var err error
			it.Subscriber, err = UnmarshalSubscriberInput(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalTriggerMetadataInput(v interface{}) (TriggerMetadataInput, error) {
	var it TriggerMetadataInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "namespace":
			var err error
			it.Namespace, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) FieldMiddleware(ctx context.Context, obj interface{}, next graphql.Resolver) (ret interface{}) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	rctx := graphql.GetResolverContext(ctx)
	for _, d := range rctx.Field.Definition.Directives {
		switch d.Name {
		case "HasAccess":
			if ec.directives.HasAccess != nil {
				rawArgs := d.ArgumentMap(ec.Variables)
				args, err := dir_HasAccess_args(rawArgs)
				if err != nil {
					ec.Error(ctx, err)
					return nil
				}
				n := next
				next = func(ctx context.Context) (interface{}, error) {
					return ec.directives.HasAccess(ctx, obj, n, args["attributes"].(ResourceAttributes))
				}
			}
		}
	}
	res, err := ec.ResolverMiddleware(ctx, next)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return res
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var parsedSchema = gqlparser.MustLoadSchema(
	&ast.Source{Name: "schema.graphql", Input: `# Scalars

scalar JSON

scalar Labels

scalar Timestamp

scalar Settings

scalar ApplicationMappingService

# Directives

directive @HasAccess(attributes: ResourceAttributes!) on FIELD_DEFINITION

input ResourceAttributes {
    verb: String!
    apiGroup: String
    apiVersion: String
    resource: String
    resourceArg: String
    subresource: String! = ""
    nameArg: String
    namespaceArg: String
    isChildResolver: Boolean! = false
}

# Rafter resources

type File {
    url: String!
    metadata: JSON!
}

type Asset {
    name: String!
    namespace: String!
    parameters: JSON!
    type: String!
    files(filterExtensions: [String!]): [File!]!
    status: AssetStatus!
    displayName: String
}

type AssetEvent {
    type: SubscriptionEventType!
    asset: Asset!
}

type ClusterAsset {
    name: String!
    parameters: JSON!
    type: String!
    files(filterExtensions: [String!]): [File!]!
    status: AssetStatus!
    displayName: String
}

type ClusterAssetEvent {
    type: SubscriptionEventType!
    clusterAsset: ClusterAsset!
}

type AssetStatus {
    phase: AssetPhaseType!
    reason: String!
    message: String!
}

enum AssetPhaseType {
    READY
    PENDING
    FAILED
}

type AssetGroup {
    name: String!
    namespace: String!
    groupName: String!
    assets(types: [String!]): [Asset!]!
    displayName: String!
    description: String!
    status: AssetGroupStatus!
}

type AssetGroupEvent {
    type: SubscriptionEventType!
    assetGroup: AssetGroup!
}

type ClusterAssetGroup {
    name: String!
    groupName: String!
    assets(types: [String!]): [ClusterAsset!]!
    displayName: String!
    description: String!
    status: AssetGroupStatus!
}

type ClusterAssetGroupEvent {
    type: SubscriptionEventType!
    clusterAssetGroup: ClusterAssetGroup!
}

type AssetGroupStatus {
    phase: AssetGroupPhaseType!
    reason: String!
    message: String!
}

enum AssetGroupPhaseType {
    READY
    PENDING
    FAILED
}

# Service Catalog

type AddonsConfiguration {
    name: String!
    urls: [String!]
    repositories: [AddonsConfigurationRepository!]
    labels: Labels!
    status: AddonsConfigurationStatus!
}

type AddonsConfigurationRepository {
    url: String!
    secretRef: ResourceRef
}

type ResourceRef {
    name: String!
    namespace: String!
}

input AddonsConfigurationRepositoryInput {
    url: String!
    secretRef: ResourceRefInput
}

input ResourceRefInput {
    name: String!
    namespace: String!
}

type AddonsConfigurationStatus {
    phase: String!
    repositories: [AddonsConfigurationStatusRepository!]
}

type AddonsConfigurationStatusRepository {
    url: String!
    status: String!
    addons: [AddonsConfigurationStatusAddons!]
    reason: String!
    message: String!
}

type AddonsConfigurationStatusAddons {
    name: String!
    version: String!
    status: String!
    reason: String!
    message: String!
}

type AddonsConfigurationEvent {
    type: SubscriptionEventType!
    addonsConfiguration: AddonsConfiguration!
}

type ClusterAddonsConfigurationEvent {
    type: SubscriptionEventType!
    addonsConfiguration: AddonsConfiguration!
}

type ServiceInstance {
    name: String!
    namespace: String!
    planSpec: JSON
    creationTimestamp: Timestamp!
    labels: [String!]!
    status: ServiceInstanceStatus!
    classReference: ServiceInstanceResourceRef
    planReference: ServiceInstanceResourceRef
    serviceClass: ServiceClass
    clusterServiceClass: ClusterServiceClass
    servicePlan: ServicePlan
    clusterServicePlan: ClusterServicePlan
    bindable: Boolean!
    serviceBindings: ServiceBindings

    # Depends on servicecatalogaddons domain
    serviceBindingUsages: [ServiceBindingUsage!]
}

type ServiceInstanceResourceRef {
    name: String!
    displayName: String!
    clusterWide: Boolean!
}

type ServiceInstanceStatus {
    type: InstanceStatusType!
    reason: String!
    message: String!
}

enum InstanceStatusType {
    RUNNING
    PROVISIONING
    DEPROVISIONING
    PENDING
    FAILED
}

type ServiceInstanceEvent {
    type: SubscriptionEventType!
    serviceInstance: ServiceInstance!
}

type ServiceBrokerEvent {
    type: SubscriptionEventType!
    serviceBroker: ServiceBroker!
}

type ClusterServiceBrokerEvent {
    type: SubscriptionEventType!
    clusterServiceBroker: ClusterServiceBroker!
}

enum SubscriptionEventType {
    ADD
    UPDATE
    DELETE
}

input ServiceInstanceCreateInput {
    name: String!
    classRef: ServiceInstanceCreateInputResourceRef!
    planRef: ServiceInstanceCreateInputResourceRef!
    labels: [String!]!
    parameterSchema: JSON
}

input ServiceInstanceCreateInputResourceRef {
    externalName: String!
    clusterWide: Boolean!
}

type ServiceClass {
    name: String!
    namespace: String!
    externalName: String!
    displayName: String
    creationTimestamp: Timestamp!
    description: String!
    longDescription: String
    imageUrl: String
    documentationUrl: String
    supportUrl: String
    providerDisplayName: String
    tags: [String!]!
    labels: Labels!
    plans: [ServicePlan!]!
    activated: Boolean!
    instances: [ServiceInstance!]!

    # Depends on rafter domain
    clusterAssetGroup: ClusterAssetGroup
    assetGroup: AssetGroup
}

type ClusterServiceClass {
    name: String!
    externalName: String!
    displayName: String
    creationTimestamp: Timestamp!
    description: String!
    longDescription: String
    imageUrl: String
    documentationUrl: String
    supportUrl: String
    providerDisplayName: String
    tags: [String!]!
    labels: Labels!
    plans: [ClusterServicePlan!]!
    activated(namespace: String): Boolean!
    instances(namespace: String): [ServiceInstance!]!

    # Depends on rafter domain
    clusterAssetGroup: ClusterAssetGroup
}

type ServicePlan {
  name: String!
  namespace: String!
  displayName: String
  externalName: String!
  description: String!
  relatedServiceClassName: String!
  instanceCreateParameterSchema: JSON
  bindingCreateParameterSchema: JSON

  # Depends on rafter domain
  clusterAssetGroup: ClusterAssetGroup
  assetGroup: AssetGroup
}

type ClusterServicePlan {
  name: String!
  displayName: String
  externalName: String!
  description: String!
  relatedClusterServiceClassName: String!
  instanceCreateParameterSchema: JSON
  bindingCreateParameterSchema: JSON

  # Depends on rafter domain
  clusterAssetGroup: ClusterAssetGroup
}

type ServiceBroker {
    name: String!
    namespace: String!
    status: ServiceBrokerStatus!
    creationTimestamp: Timestamp!
    url: String!
    labels: Labels!
}

type ClusterServiceBroker {
    name: String!
    status: ServiceBrokerStatus!
    creationTimestamp: Timestamp!
    url: String!
    labels: Labels!
}

type ServiceBrokerStatus {
    ready: Boolean!
    reason: String!
    message: String!
}

type ServiceBindings {
    items: [ServiceBinding!]!
    stats: ServiceBindingsStats!
}

type ServiceBindingsStats {
    ready: Int!
    failed: Int!
    pending: Int!
    unknown: Int!
}

type ServiceBinding {
    name: String!
    serviceInstanceName: String!
    namespace: String!
    secret: Secret
    status: ServiceBindingStatus!
    parameters: JSON
}

type ServiceBindingStatus {
    type: ServiceBindingStatusType!
    reason: String!
    message: String!
}

enum ServiceBindingStatusType {
    READY
    PENDING
    FAILED
    UNKNOWN
}

type ServiceBindingEvent {
    type: SubscriptionEventType!
    serviceBinding: ServiceBinding!
}

# We cannot use ServiceBinding as a result of create action
# because secret at the moment of mutation execution is not available.
type CreateServiceBindingOutput {
    name: String!
    serviceInstanceName: String!
    namespace: String!
}

type Secret {
    name: String!
    namespace: String!
    data: JSON!
    type: String!
    creationTime: Timestamp!
    labels: JSON!
    annotations: JSON!
    json: JSON!
}

type DeleteServiceBindingOutput {
    name: String!
    namespace: String!
}

type DeleteServiceBindingUsageOutput {
    name: String!
    namespace: String!
}

type ServiceBindingUsage {
    name: String!
    namespace: String!
    serviceBinding: ServiceBinding
    usedBy: LocalObjectReference!
    parameters: ServiceBindingUsageParameters
    status: ServiceBindingUsageStatus!
}

type ServiceBindingUsageEvent {
    type: SubscriptionEventType!
    serviceBindingUsage: ServiceBindingUsage!
}

type ServiceBindingUsageStatus {
    type: ServiceBindingUsageStatusType!
    reason: String!
    message: String!
}

enum ServiceBindingUsageStatusType {
    READY
    PENDING
    FAILED
    UNKNOWN
}

type LocalObjectReference {
    kind: String!
    name: String!
}

type ServiceBindingUsageParameters {
    envPrefix: EnvPrefix
}

type EnvPrefix {
    name: String!
}

type LimitRange {
    name: String!
    limits: [LimitRangeItem!]!
}

type LimitRangeItem {
    limitType: LimitType!
    max: ResourceType!
    default: ResourceType!
    defaultRequest: ResourceType!
}

input LimitRangeInput {
    default: ResourceValuesInput!,
    defaultRequest: ResourceValuesInput!
    max: ResourceValuesInput!
    type: String!
}

enum LimitType {
    Container
    Pod
}

type ResourceType {
    memory: String
    cpu: String
}

input CreateServiceBindingUsageInput {
    name: String
    serviceBindingRef: ServiceBindingRefInput!
    usedBy: LocalObjectReferenceInput!
    parameters: ServiceBindingUsageParametersInput
}

input ServiceBindingRefInput {
    name: String!
}

input LocalObjectReferenceInput {
    kind: String!
    name: String!
}

input ServiceBindingUsageParametersInput {
    envPrefix: EnvPrefixInput
}

input EnvPrefixInput {
    name: String!
}

type Container {
    name: String!
    image: String!
}

type DeploymentStatus {
    replicas: Int!
    updatedReplicas: Int!
    readyReplicas: Int!
    availableReplicas: Int!
    conditions: [DeploymentCondition!]!
}

type DeploymentCondition {
    status: String!
    type: String!
    lastTransitionTimestamp: Timestamp!
    lastUpdateTimestamp: Timestamp!
    message: String!
    reason: String!
}

type Deployment {
    name: String!
    namespace: String!
    creationTimestamp: Timestamp!
    status: DeploymentStatus!
    labels: Labels!
    containers: [Container!]!

    # Depends on servicecatalog and servicecatalogaddons modules
    boundServiceInstanceNames: [String!]
}

enum ServiceProtocol {
    TCP
    UDP
    UNKNOWN
}

type ServicePort {
    name: String!
    serviceProtocol: ServiceProtocol!
    port: Int!
    nodePort: Int!
    targetPort: Int!
}

type LoadBalancerIngress {
    ip: String!
    hostName: String!
}

type LoadBalancerStatus {
    ingress: [LoadBalancerIngress!]!
}

type ServiceStatus {
    loadBalancer: LoadBalancerStatus!
}

type Service {
    name: String!
    clusterIP: String!
    creationTimestamp: Timestamp!
    labels: Labels!
    ports: [ServicePort!]!
    status: ServiceStatus!
    json: JSON!
}

type Pod {
    name: String!
    nodeName: String!
    namespace: String!
    restartCount: Int!
    creationTimestamp: Timestamp!
    labels: Labels!
    status: PodStatusType!
    containerStates: [ContainerState!]!
    json: JSON!
}

type ReplicaSet {
    name: String!
    pods: String!
    namespace: String!
    images: [String!]!
    creationTimestamp: Timestamp!
    labels: Labels!
    json: JSON!
}

enum PodStatusType {
    PENDING
    RUNNING
    SUCCEEDED
    FAILED
    UNKNOWN
}

type PodEvent {
    type: SubscriptionEventType!
    pod: Pod!
}

type ServiceEvent {
    type: SubscriptionEventType!
    service: Service!
}

type SecretEvent {
    type: SubscriptionEventType!
    secret: Secret!
}

type ApiRuleEvent {
    type: SubscriptionEventType!
    apiRule: APIRule!
}

type ContainerState {
    state: ContainerStateType!
    reason: String!
    message: String!
}

enum ContainerStateType {
    WAITING
    RUNNING
    TERMINATED
}

type ResourceValues {
    memory: String
    cpu: String
}

type ResourceQuota {
    name: String!
    pods: String
    limits: ResourceValues!
    requests: ResourceValues!
}

input ResourceValuesInput {
    memory: String
    cpu: String
}

input ResourceQuotaInput {
    limits: ResourceValuesInput!
    requests: ResourceValuesInput!
}

type ResourceQuotasStatus {
    exceeded: Boolean!
    exceededQuotas: [ExceededQuota!]!
}

type ExceededQuota {
    quotaName: String!
    resourceName: String!
    affectedResources: [String!]!
}

# Applications

type Namespace {
    name: String!
    labels: Labels
    status: String!
    isSystemNamespace: Boolean!
    pods: [Pod!]!

    # Depends on application module
    applications: [String!]
}

type NamespaceEvent {
    type: SubscriptionEventType!
    namespace: Namespace!
}

type NamespaceMutationOutput {
    name: String!
    labels: Labels!
}

type Application {
    name: String!
    description: String!
    labels: Labels!
    services: [ApplicationService!]!
    enabledInNamespaces: [String!]!
    enabledMappingServices: [enabledMappingService]
    status: ApplicationStatus!
    compassMetadata: compassMetadata
}

type compassMetadata {
    applicationId: String!
}

type enabledMappingService {
    namespace: String!
    allServices: Boolean!
    services: [EnabledApplicationService]
}

type EnabledApplicationService {
    id: String!
    displayName: String!
    exist: Boolean!
}

type ConnectorService {
    url: String!
}

type ApplicationMapping {
    namespace: String!
    application: String!
    allServices: Boolean
    services: [ApplicationMappingService]
}

type ApplicationService {
    id: String!
    displayName: String!
    longDescription: String!
    providerDisplayName: String!
    tags: [String!]!
    entries: [ApplicationEntry!]!
}

type ApplicationEntry {
    type: String!
    gatewayUrl: String
    accessLabel: String
}

enum ApplicationStatus {
    SERVING
    NOT_SERVING
    GATEWAY_NOT_CONFIGURED
}

type ApplicationEvent {
    type: SubscriptionEventType!
    application: Application!
}

type ApplicationMutationOutput {
    name: String!
    description: String!
    labels: Labels!
}

type DeleteApplicationOutput {
    name: String!
}

type EventActivationEvent {
    eventType: String!
    version: String!
    description: String!
    schema: JSON!
}

type EventActivation {
    name: String!
    displayName: String!
    sourceId: String!
    events: [EventActivationEvent!] # content module
}

type UsageKind {
    name: String!
    group: String!
    kind: String!
    version: String!
    displayName: String!
}

type UsageKindResource {
    name: String!
    namespace: String!
}

type BindableResourcesOutputItem {
    kind: String!
    displayName: String!
    resources: [UsageKindResource!]!
}

# IDP PRESETS

type IDPPreset {
    name: String!
    issuer: String!
    jwksUri: String!
}

# API Gateway Controller

type APIRule {
    name: String!
    service: APIRuleService!
    gateway: String!
    rules: [Rule!]!
    status: APIRuleStatuses!
}

type APIRuleService{
    host: String!
    name: String!
    port: Int!
}

type Rule {
    path: String!
    methods: [String!]!
    accessStrategies: [APIRuleConfig!]!
    mutators: [APIRuleConfig!]
}

type APIRuleConfig {
    name: String!
    config: JSON!
}

type APIRuleStatuses {
    apiRuleStatus: APIRuleStatus
    accessRuleStatus: APIRuleStatus
    virtualServiceStatus: APIRuleStatus
}

type APIRuleStatus {
    code: String!
    desc: String
}

input APIRuleInput {
    host: String!
    serviceName: String!
    servicePort: Int!
    gateway: String!
    rules: [RuleInput!]!
}

input RuleInput {
    path: String!
    methods: [String!]!
    accessStrategies: [APIRuleConfigInput!]!
    mutators: [APIRuleConfigInput!]
}

input APIRuleConfigInput {
    name: String!
    config: JSON!
}

# Backend Module
type BackendModule {
    name: String!
}

# Config Maps

type ConfigMap {
    name: String!
    namespace: String!
    creationTimestamp: Timestamp!
    labels: Labels!
    json: JSON!
}

type ConfigMapEvent {
    type: SubscriptionEventType!
    configMap: ConfigMap!
}

# MF

type MicroFrontend {
    name: String!
    version: String!
    category: String!
    viewBaseUrl: String!
    navigationNodes: [NavigationNode!]!
}

type ClusterMicroFrontend {
    name: String!
    version: String!
    category: String!
    viewBaseUrl: String!
    placement: String!
    preloadUrl: String!
    navigationNodes: [NavigationNode!]!
}

type NavigationNode {
    label: String!
    navigationPath: String!
    viewUrl: String!
    showInNavigation: Boolean!
    order: Int!
    settings: Settings!
    externalLink: String
    requiredPermissions: [RequiredPermission!]!
}

type RequiredPermission {
    verbs: [String!]!
    apiGroup: String!
    resource: String!
}

# SelfSubjectRules

type ResourceRule {
    verbs: [String!]
    apiGroups: [String!]
    resources: [String!]
}

# Function

type Function {
    # meta
    name: String!
	namespace: String!
	UID: String!
	labels: Labels!

    # spec
    source: String!
    dependencies: String!
    env: [FunctionEnv!]!
    replicas: FunctionReplicas!
    resources: FunctionResources!

    # status
    status: FunctionStatus!
}

type FunctionEnv {
    name: String!
    value: String!
    valueFrom: FunctionEnvValueFrom
}

type FunctionEnvValueFrom {
    type: FunctionEnvValueFromType!
    name: String!
    key: String!
    optional: Boolean
}

input FunctionEnvInput {
    name: String!
    value: String!
    valueFrom: FunctionEnvValueFromInput
}

input FunctionEnvValueFromInput {
    type: FunctionEnvValueFromType!
    name: String!
    key: String!
    optional: Boolean
}

enum FunctionEnvValueFromType {
    ConfigMap
    Secret
}

type FunctionReplicas {
    min: Int
    max: Int
}

input FunctionReplicasInput {
    min: Int
    max: Int
}

type FunctionResources {
    limits: ResourceValues!
    requests: ResourceValues!
}

input FunctionResourcesInput {
    limits: ResourceValuesInput!
    requests: ResourceValuesInput!
}

type FunctionStatus {
    phase: FunctionPhaseType!
    reason: FunctionReasonType
    message: String
}

enum FunctionPhaseType {
    INITIALIZING
    BUILDING
    DEPLOYING
    RUNNING
    NEW_REVISION_ERROR
    FAILED
}

enum FunctionReasonType {
    CONFIG # ConfigMap
    JOB # K8S Job
    SERVICE # KNative Service
}

input FunctionMutationInput {
    labels: Labels!
    source: String!
    dependencies: String!
    env: [FunctionEnvInput!]!
    replicas: FunctionReplicasInput!
    resources: FunctionResourcesInput!
}

type FunctionMetadata {
    name: String!
    namespace: String!
}

input FunctionMetadataInput {
    name: String!
    namespace: String!
}

type FunctionEvent {
    type: SubscriptionEventType!
    function: Function!
}

# KNative Trigger

type Trigger {
    name: String!
    namespace: String!
    broker: String!
    filterAttributes: JSON!
    subscriber: Subscriber!
    status: TriggerStatus!
}

type TriggerStatus {
    reason: [String!]
    status: TriggerStatusType!
}

enum TriggerStatusType {
    FAILED
    UNKNOWN
    READY
}

type Subscriber {
    uri: String
    ref: SubscriberRef
}

type SubscriberRef {
    apiVersion: String!
    kind: String!
    name: String!
    namespace: String!
}

input SubscriberInput {
    uri: String
    ref: SubscriberRefInput
}

input SubscriberRefInput {
    apiVersion: String!
    kind: String!
    name: String!
    namespace: String!
}

input TriggerCreateInput {
    name: String
    namespace: String!
    broker: String!
    filterAttributes: JSON
    subscriber: SubscriberInput!
}

input TriggerMetadataInput {
    name: String!
    namespace: String!
}

type TriggerMetadata {
    name: String!
    namespace: String!
}

input OwnerReference {
    apiVersion: String!
    blockOwnerDeletion: Boolean
    controller: Boolean
    kind: String!
    name: String!
    UID: String!
}

type TriggerEvent {
    type: SubscriptionEventType!
    trigger: Trigger!
}

# Misc

type VersionInfo {
    kymaVersion: String!
}

# Queries

type Query {
    clusterAssetGroups(viewContext: String, groupName: String): [ClusterAssetGroup!]! @HasAccess(attributes: {resource: "clusterassetgroups", verb: "list", apiGroup: "rafter.kyma-project.io", apiVersion: "v1beta1"})

    serviceInstance(name: String!, namespace: String!): ServiceInstance @HasAccess(attributes: {resource: "serviceinstances", verb: "get", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace", nameArg: "name"})
    serviceInstances(namespace: String!, first: Int, offset: Int, status: InstanceStatusType): [ServiceInstance!]! @HasAccess(attributes: {resource: "serviceinstances", verb: "list", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace"})

    clusterServiceClasses(first: Int, offset: Int): [ClusterServiceClass!]! @HasAccess(attributes: {resource: "clusterserviceclasses", verb: "list", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1"})
    clusterServiceClass(name: String!): ClusterServiceClass @HasAccess(attributes: {resource: "clusterserviceclasses", verb: "get", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", nameArg: "name"})
    serviceClasses(namespace: String!, first: Int, offset: Int): [ServiceClass!]! @HasAccess(attributes: {resource: "serviceclasses", verb: "list", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace"})
    serviceClass(namespace: String!, name: String!): ServiceClass @HasAccess(attributes: {resource: "serviceclasses", verb: "get", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace", nameArg: "name"})

    clusterServiceBrokers(first: Int, offset: Int): [ClusterServiceBroker!]! @HasAccess(attributes: {resource: "clusterservicebrokers", verb: "list", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1"})
    clusterServiceBroker(name: String!): ClusterServiceBroker @HasAccess(attributes: {resource: "clusterservicebrokers", verb: "get", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", nameArg: "name"})
    serviceBrokers(namespace: String!, first: Int, offset: Int): [ServiceBroker!]! @HasAccess(attributes: {resource: "servicebrokers", verb: "list", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace"})
    serviceBroker(name: String!, namespace: String!): ServiceBroker @HasAccess(attributes: {resource: "servicebrokers", verb: "get", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace", nameArg: "name"})

    serviceBindingUsage(name: String!, namespace: String!): ServiceBindingUsage @HasAccess(attributes: {resource: "servicebindingusages", verb: "get", apiGroup: "servicecatalog.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace", nameArg: "name"})
    serviceBindingUsages(namespace: String!, resourceKind: String, resourceName: String): [ServiceBindingUsage!]! @HasAccess(attributes: {resource: "servicebindingusages", verb: "get", apiGroup: "servicecatalog.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace"})
    serviceBinding(name: String!, namespace: String!): ServiceBinding @HasAccess(attributes: {resource: "servicebindings", verb: "get", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace", nameArg: "name"})
    usageKinds(first: Int, offset: Int): [UsageKind!]! @HasAccess(attributes: {resource: "usagekinds", verb: "list", apiGroup: "servicecatalog.kyma-project.io", apiVersion: "v1alpha1"})

    clusterAddonsConfigurations(first: Int, offset: Int): [AddonsConfiguration!]! @HasAccess(attributes: {resource: "clusteraddonsconfigurations", verb: "list", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1"})
    addonsConfigurations(namespace: String!, first: Int, offset: Int): [AddonsConfiguration!]! @HasAccess(attributes: {resource: "addonsconfigurations", verb: "list", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1"})

    # The query returns all instance of the resources which could be bound (proper UsageKind exists).
    bindableResources(namespace: String!): [BindableResourcesOutputItem!]! @HasAccess(attributes: {resource: "usagekinds", verb: "list", apiGroup: "servicecatalog.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace"})

    APIRules(namespace: String!, serviceName: String, hostname: String): [APIRule!]! @HasAccess(attributes: {resource: "apirules", verb: "list", apiGroup: "gateway.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace"})
    APIRule(name: String!, namespace: String!): APIRule @HasAccess(attributes: {resource: "apirules", verb: "get", apiGroup: "gateway.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace", nameArg: "name"})

    application(name: String!): Application @HasAccess(attributes: {resource: "applications", verb: "get", apiGroup: "applicationconnector.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})
    applications(namespace: String, first: Int, offset: Int): [Application!]! @HasAccess(attributes: {resource: "applications", verb: "list", apiGroup: "applicationconnector.kyma-project.io", apiVersion: "v1alpha1"})
    connectorService(application: String!): ConnectorService! @HasAccess(attributes: {resource: "applications", verb: "create", apiGroup: "applicationconnector.kyma-project.io", apiVersion: "v1alpha1"})

    # Depends on 'application'
    namespaces(withSystemNamespaces: Boolean, withInactiveStatus: Boolean): [Namespace!]! @HasAccess(attributes: {resource: "namespaces", verb: "list", apiGroup: "", apiVersion: "v1"})
    namespace(name: String!): Namespace @HasAccess(attributes: {resource: "namespaces", verb: "get", apiGroup: "", apiVersion: "v1"})

    deployments(namespace: String!, excludeFunctions: Boolean): [Deployment!]! @HasAccess(attributes: {resource: "deployments", verb: "list", apiGroup: "apps", apiVersion: "v1beta2", namespaceArg: "namespace"})
    versionInfo: VersionInfo!

    pod(name: String!, namespace: String!): Pod @HasAccess(attributes: {resource: "pods", verb: "get", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace", nameArg: "name"})
    pods(namespace: String!, first: Int, offset: Int): [Pod!]! @HasAccess(attributes: {resource: "pods", verb: "list", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})

    service(name: String!, namespace: String!): Service @HasAccess(attributes: {resource: "services", verb: "get", apiGroup: "", apiVersion: "v1", nameArg: "name", namespaceArg: "namespace"})
    services(namespace: String!, excludedLabels: [String!], first: Int, offset: Int): [Service!]! @HasAccess(attributes: {resource: "services", verb: "list", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})
    configMap(name: String!, namespace: String!): ConfigMap @HasAccess(attributes: {resource: "configmaps", verb: "get", apiGroup: "", apiVersion: "v1", nameArg: "name", namespaceArg: "namespace"})
    configMaps(namespace: String!, first: Int, offset: Int): [ConfigMap!]! @HasAccess(attributes: {resource: "configmaps", verb: "list", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})

    replicaSet(name: String!, namespace: String!): ReplicaSet @HasAccess(attributes: {resource: "replicasets", verb: "get", apiGroup: "apps", apiVersion: "v1", namespaceArg: "namespace", nameArg: "name"})
    replicaSets(namespace: String!, first: Int, offset: Int): [ReplicaSet!]! @HasAccess(attributes: {resource: "replicasets", verb: "list", apiGroup: "apps", apiVersion: "v1", namespaceArg: "namespace"})

    resourceQuotas(namespace: String!): [ResourceQuota!]! @HasAccess(attributes: {resource: "resourcequotas", verb: "list", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})
    resourceQuotasStatus(namespace: String!): ResourceQuotasStatus! @HasAccess(attributes: {resource: "resourcequotas", verb: "list", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})

    eventActivations(namespace: String!): [EventActivation!]! @HasAccess(attributes: {resource: "eventactivations", verb: "list", apiGroup: "applicationconnector.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace"})

    limitRanges(namespace: String!): [LimitRange!]! @HasAccess(attributes: {resource: "limitranges", verb: "list", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})

    backendModules: [BackendModule!]! @HasAccess(attributes: {resource: "backendmodules", verb: "list", apiGroup: "ui.kyma-project.io", apiVersion: "v1alpha1"})

    secret(name: String!, namespace: String!): Secret @HasAccess(attributes: {resource: "secrets", verb: "get", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})
    secrets(namespace: String!, first: Int, offset: Int): [Secret!]!  @HasAccess(attributes: {resource: "secrets", verb: "list", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})

    IDPPreset(name: String!): IDPPreset @HasAccess(attributes: {resource: "idppresets", verb: "get", apiGroup: "authentication.kyma-project.io", apiVersion: "v1alpha1"})
    IDPPresets(first: Int, offset: Int): [IDPPreset!]! @HasAccess(attributes: {resource: "idppresets", verb: "list", apiGroup: "authentication.kyma-project.io", apiVersion: "v1alpha1"})

    microFrontends(namespace: String!): [MicroFrontend!]! @HasAccess(attributes: {resource: "microfrontends", verb: "list", apiGroup: "ui.kyma-project.io", apiVersion: "v1alpha1"})
    clusterMicroFrontends: [ClusterMicroFrontend!]! @HasAccess(attributes: {resource: "clustermicrofrontends", verb: "list", apiGroup: "ui.kyma-project.io", apiVersion: "v1alpha1"})

    selfSubjectRules(namespace: String): [ResourceRule!]! @HasAccess(attributes: {apiGroup: "authorization.k8s.io", resource: "selfsubjectrulesreviews", verb: "create", apiVersion: "v1" namespaceArg: "namespace"})

    function(name: String!, namespace: String!): Function @HasAccess(attributes: {apiGroup: "serverless.kyma-project.io", resource: "functions", verb: "get", apiVersion: "v1alpha1" nameArg:"name" namespaceArg: "namespace"})
    functions(namespace: String!): [Function!]! @HasAccess(attributes: {apiGroup: "serverless.kyma-project.io", resource: "functions", verb: "list", apiVersion: "v1alpha1" namespaceArg: "namespace"})

    triggers(namespace: String!, subscriber: SubscriberInput): [Trigger!] @HasAccess(attributes: {resource: "triggers", verb: "list", apiGroup: "eventing.knative.dev", apiVersion: "v1alpha1", namespaceArg: "namespace"})
}

# Mutations

type Mutation {
    createResource(namespace: String!, resource: JSON!): JSON @HasAccess(attributes: {verb: "create", resourceArg: "resource", namespaceArg: "namespace"})
    createServiceInstance(namespace: String!, params: ServiceInstanceCreateInput!): ServiceInstance @HasAccess(attributes: {resource: "serviceinstances", verb: "create", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace"})
    deleteServiceInstance(name: String!, namespace: String!): ServiceInstance @HasAccess(attributes: {resource: "serviceinstances", verb: "delete", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace", nameArg: "name"})
    createServiceBinding(serviceBindingName: String, serviceInstanceName: String!, namespace: String!, parameters: JSON): CreateServiceBindingOutput @HasAccess(attributes: {resource: "servicebindings", verb: "create", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace"})
    deleteServiceBinding(serviceBindingName: String!, namespace: String!): DeleteServiceBindingOutput @HasAccess(attributes: {resource: "servicebindings", verb: "delete", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace", nameArg: "serviceBindingName"})
    createServiceBindingUsage(namespace: String!, createServiceBindingUsageInput: CreateServiceBindingUsageInput): ServiceBindingUsage @HasAccess(attributes: {resource: "servicebindingusages", verb: "create", apiGroup: "servicecatalog.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace"})
    deleteServiceBindingUsage(serviceBindingUsageName: String!, namespace: String!): DeleteServiceBindingUsageOutput @HasAccess(attributes: {resource: "servicebindingusages", verb: "delete", apiGroup: "servicecatalog.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace", nameArg: "serviceBindingUsageName"})
    deleteServiceBindingUsages(serviceBindingUsageNames: [String!]!, namespace: String!): [DeleteServiceBindingUsageOutput] @HasAccess(attributes: {resource: "servicebindingusages", verb: "delete", apiGroup: "servicecatalog.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace"})

    createClusterAddonsConfiguration(name: String!, repositories: [AddonsConfigurationRepositoryInput!], urls: [String!], labels: Labels): AddonsConfiguration @HasAccess(attributes: {resource: "clusteraddonsconfigurations", verb: "create", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})
    updateClusterAddonsConfiguration(name: String!, repositories: [AddonsConfigurationRepositoryInput!], urls: [String!], labels: Labels): AddonsConfiguration @HasAccess(attributes: {resource: "clusteraddonsconfigurations", verb: "update", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})
    deleteClusterAddonsConfiguration(name: String!): AddonsConfiguration @HasAccess(attributes: {resource: "clusteraddonsconfigurations", verb: "delete", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})
    addClusterAddonsConfigurationURLs(name: String!, urls: [String!]): AddonsConfiguration @HasAccess(attributes: {resource: "clusteraddonsconfigurations", verb: "update", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})
    removeClusterAddonsConfigurationURLs(name: String!, urls: [String!]): AddonsConfiguration @HasAccess(attributes: {resource: "clusteraddonsconfigurations", verb: "update", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})
    addClusterAddonsConfigurationRepository(name: String!, repositories: [AddonsConfigurationRepositoryInput!]): AddonsConfiguration @HasAccess(attributes: {resource: "clusteraddonsconfigurations", verb: "update", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})
    removeClusterAddonsConfigurationRepository(name: String!, urls: [String!]): AddonsConfiguration @HasAccess(attributes: {resource: "clusteraddonsconfigurations", verb: "update", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})
    resyncClusterAddonsConfiguration(name: String!): AddonsConfiguration @HasAccess(attributes: {resource: "clusteraddonsconfigurations", verb: "update", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})

    createAddonsConfiguration(name: String!, namespace: String!, repositories: [AddonsConfigurationRepositoryInput!], urls: [String!], labels: Labels): AddonsConfiguration @HasAccess(attributes: {resource: "addonsconfigurations", verb: "create", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})
    updateAddonsConfiguration(name: String!, namespace: String!, repositories: [AddonsConfigurationRepositoryInput!], urls: [String!], labels: Labels): AddonsConfiguration @HasAccess(attributes: {resource: "addonsconfigurations", verb: "update", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})
    deleteAddonsConfiguration(name: String!, namespace: String!): AddonsConfiguration @HasAccess(attributes: {resource: "addonsconfigurations", verb: "delete", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})
    addAddonsConfigurationURLs(name: String!, namespace: String!, urls: [String!]): AddonsConfiguration @HasAccess(attributes: {resource: "addonsconfigurations", verb: "update", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})
    removeAddonsConfigurationURLs(name: String!, namespace: String!, urls: [String!]): AddonsConfiguration @HasAccess(attributes: {resource: "addonsconfigurations", verb: "update", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})
    addAddonsConfigurationRepository(name: String!, namespace: String!, repositories: [AddonsConfigurationRepositoryInput!]): AddonsConfiguration @HasAccess(attributes: {resource: "addonsconfigurations", verb: "update", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})
    removeAddonsConfigurationRepository(name: String!, namespace: String!, urls: [String!]): AddonsConfiguration @HasAccess(attributes: {resource: "addonsconfigurations", verb: "update", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})
    resyncAddonsConfiguration(name: String!, namespace: String!): AddonsConfiguration @HasAccess(attributes: {resource: "addonsconfigurations", verb: "update", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})

    createApplication(name: String!, description: String, labels: Labels): ApplicationMutationOutput! @HasAccess(attributes: {resource: "applications", verb: "create", apiGroup: "applicationconnector.kyma-project.io", apiVersion: "v1alpha1"})
    updateApplication(name: String!, description: String, labels: Labels): ApplicationMutationOutput! @HasAccess(attributes: {resource: "applications", verb: "update", apiGroup: "applicationconnector.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})
    deleteApplication(name: String!): DeleteApplicationOutput! @HasAccess(attributes: {resource: "applications", verb: "delete", apiGroup: "applicationconnector.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})

    enableApplication(application: String!, namespace: String!, allServices: Boolean, services: [ApplicationMappingService]): ApplicationMapping @HasAccess(attributes: {resource: "applicationmappings", verb: "create", apiGroup: "applicationconnector.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace"})
    overloadApplication(application: String!, namespace: String!, allServices: Boolean, services: [ApplicationMappingService]): ApplicationMapping @HasAccess(attributes: {resource: "applicationmappings", verb: "update", apiGroup: "applicationconnector.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace"})
    disableApplication(application: String!, namespace: String!): ApplicationMapping @HasAccess(attributes: {resource: "applicationmappings", verb: "delete", apiGroup: "applicationconnector.kyma-project.io", apiVersion: "v1alpha1", nameArg: "application", namespaceArg: "namespace"})

    updatePod(name: String!, namespace: String!, pod: JSON!): Pod @HasAccess(attributes: {resource: "pods", verb: "update", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace", nameArg: "name"})
    deletePod(name: String!, namespace: String!): Pod @HasAccess(attributes: {resource: "pods", verb: "delete", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace", nameArg: "name"})

    updateSecret(name: String!, namespace: String!, secret: JSON!): Secret @HasAccess(attributes: {resource: "secrets", verb: "update", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})
    deleteSecret(name: String!, namespace: String!): Secret @HasAccess(attributes: {resource: "secrets", verb: "delete", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})

    updateReplicaSet(name: String!, namespace: String!, replicaSet: JSON!): ReplicaSet @HasAccess(attributes: {resource: "replicasets", verb: "update", apiGroup: "apps", apiVersion: "v1", namespaceArg: "namespace", nameArg: "name"})
    deleteReplicaSet(name: String!, namespace: String!): ReplicaSet @HasAccess(attributes: {resource: "replicasets", verb: "delete", apiGroup: "apps", apiVersion: "v1", namespaceArg: "namespace", nameArg: "name"})

    createResourceQuota(namespace: String!, name: String!, resourceQuota: ResourceQuotaInput!): ResourceQuota @HasAccess(attributes: {resource: "resourcequotas", verb: "create", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})

    updateConfigMap(name: String!, namespace: String!, configMap: JSON!): ConfigMap @HasAccess(attributes: {resource: "configmaps", verb: "update", apiGroup: "", apiVersion: "v1", nameArg: "name", namespaceArg: "namespace"})
    deleteConfigMap(name: String!, namespace: String!): ConfigMap @HasAccess(attributes: {resource: "configmaps", verb: "delete", apiGroup: "", apiVersion: "v1", nameArg: "name", namespaceArg: "namespace"})

    createIDPPreset(name: String!, issuer: String!, jwksUri: String!): IDPPreset @HasAccess(attributes: {resource: "idppresets", verb: "create", apiGroup: "authentication.kyma-project.io", apiVersion: "v1alpha1"})
    deleteIDPPreset(name: String!): IDPPreset @HasAccess(attributes: {resource: "idppresets", verb: "delete", apiGroup: "authentication.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name"})

    updateService(name: String!, namespace: String!, service: JSON!): Service @HasAccess(attributes: {resource: "services", verb: "update", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace", nameArg: "name"})
    deleteService(name: String!, namespace: String!): Service @HasAccess(attributes: {resource: "services", verb: "delete", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace", nameArg: "name"})

    createNamespace(name: String!, labels: Labels): NamespaceMutationOutput! @HasAccess(attributes: {resource: "namespaces", verb: "create", apiGroup: "", apiVersion: "v1"})
    updateNamespace(name: String!, labels: Labels!): NamespaceMutationOutput! @HasAccess(attributes: {resource: "namespaces", verb: "update", apiGroup: "", apiVersion: "v1", namespaceArg: "name"})
    deleteNamespace(name: String!): Namespace @HasAccess(attributes: {resource: "namespaces", verb: "delete", apiGroup: "", apiVersion: "v1", namespaceArg: "name"})

    createAPIRule(name: String!, namespace: String!, params: APIRuleInput!): APIRule @HasAccess(attributes: {resource: "apirules", verb: "create", apiGroup: "gateway.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace", nameArg: "name"})
    updateAPIRule(name: String!, namespace: String!, params: APIRuleInput!): APIRule @HasAccess(attributes: {resource: "apirules", verb: "update", apiGroup: "gateway.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace", nameArg: "name"})
    deleteAPIRule(name: String!, namespace: String!): APIRule @HasAccess(attributes: {resource: "apirules", verb: "delete", apiGroup: "gateway.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace", nameArg: "name"})

    createLimitRange(namespace: String!, name: String!, limitRange: LimitRangeInput!): LimitRange @HasAccess(attributes: {resource: "limitrange", verb: "create", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})

    createFunction(name: String!, namespace: String!, params: FunctionMutationInput!): Function @HasAccess(attributes: {resource: "functions", verb: "create", apiGroup: "serverless.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name",  namespaceArg: "namespace"})
    updateFunction(name: String!, namespace: String!, params: FunctionMutationInput!): Function @HasAccess(attributes: {resource: "functions", verb: "create", apiGroup: "serverless.kyma-project.io", apiVersion: "v1alpha1", nameArg: "name",  namespaceArg: "namespace"})
    deleteFunction(function: FunctionMetadataInput!): FunctionMetadata @HasAccess(attributes: {resource: "functions", verb: "delete", apiGroup: "serverless.kyma-project.io", apiVersion: "v1alpha1"})
    deleteManyFunctions(functions: [FunctionMetadataInput!]!): [FunctionMetadata!] @HasAccess(attributes: {resource: "functions", verb: "delete", apiGroup: "serverless.kyma-project.io", apiVersion: "v1alpha1"})

    createTrigger(trigger: TriggerCreateInput!, ownerRef: [OwnerReference!]): Trigger @HasAccess(attributes: {resource: "triggers", verb: "create", apiGroup: "eventing.knative.dev", apiVersion: "v1alpha1"})
    createManyTriggers(triggers: [TriggerCreateInput!]!, ownerRef: [OwnerReference!]): [Trigger!] @HasAccess(attributes: {resource: "triggers", verb: "create", apiGroup: "eventing.knative.dev", apiVersion: "v1alpha1"})
    deleteTrigger(trigger: TriggerMetadataInput!): TriggerMetadata @HasAccess(attributes: {resource: "triggers", verb: "delete", apiGroup: "eventing.knative.dev", apiVersion: "v1alpha1"})
    deleteManyTriggers(triggers: [TriggerMetadataInput!]!): [TriggerMetadata!] @HasAccess(attributes: {resource: "triggers", verb: "delete", apiGroup: "eventing.knative.dev", apiVersion: "v1alpha1"})
}

# Subscriptions

type Subscription {
    clusterAssetEvent: ClusterAssetEvent! @HasAccess(attributes: {resource: "clusterassets", verb: "watch", apiGroup: "rafter.kyma-project.io", apiVersion: "v1beta1"})
    assetEvent(namespace: String!): AssetEvent! @HasAccess(attributes: {resource: "assets", verb: "watch", apiGroup: "rafter.kyma-project.io", apiVersion: "v1beta1", namespaceArg: "namespace"})
    clusterAssetGroupEvent: ClusterAssetGroupEvent! @HasAccess(attributes: {resource: "clusterassetgroups", verb: "watch", apiGroup: "rafter.kyma-project.io", apiVersion: "v1beta1"})
    assetGroupEvent(namespace: String!): AssetGroupEvent! @HasAccess(attributes: {resource: "assetgroups", verb: "watch", apiGroup: "rafter.kyma-project.io", apiVersion: "v1beta1", namespaceArg: "namespace"})

    serviceInstanceEvent(namespace: String!): ServiceInstanceEvent! @HasAccess(attributes: {resource: "serviceinstances", verb: "watch", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace"})
    serviceBindingEvent(namespace: String!): ServiceBindingEvent! @HasAccess(attributes: {resource: "servicebindings", verb: "watch", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace"})
    serviceBindingUsageEvent(namespace: String!, resourceKind: String, resourceName: String): ServiceBindingUsageEvent! @HasAccess(attributes: {resource: "servicebindingusages", verb: "watch", apiGroup: "servicecatalog.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace"})
    serviceBrokerEvent(namespace: String!): ServiceBrokerEvent! @HasAccess(attributes: {resource: "servicebrokers", verb: "watch", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1", namespaceArg: "namespace"})
    clusterServiceBrokerEvent: ClusterServiceBrokerEvent! @HasAccess(attributes: {resource: "clusterservicebrokers", verb: "watch", apiGroup: "servicecatalog.k8s.io", apiVersion: "v1beta1"})

    applicationEvent: ApplicationEvent! @HasAccess(attributes: {resource: "applications", verb: "watch", apiGroup: "applicationconnector.kyma-project.io", apiVersion: "v1alpha1"})

    podEvent(namespace: String!): PodEvent! @HasAccess(attributes: {resource: "pods", verb: "watch", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})
    serviceEvent(namespace: String!): ServiceEvent! @HasAccess(attributes: {resource: "services", verb: "watch", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})
    configMapEvent(namespace: String!): ConfigMapEvent! @HasAccess(attributes: {resource: "configmaps", verb: "watch", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"})

    clusterAddonsConfigurationEvent: ClusterAddonsConfigurationEvent! @HasAccess(attributes: {resource: "clusteraddonsconfigurations", verb: "watch", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1"})
    addonsConfigurationEvent(namespace: String!): AddonsConfigurationEvent! @HasAccess(attributes: {resource: "addonsconfigurations", verb: "watch", apiGroup: "addons.kyma-project.io", apiVersion: "v1alpha1"})

    # secretEvent(namespace: String!): SecretEvent!  @HasAccess(attributes: {resource: "secrets", verb: "watch", apiGroup: "", apiVersion: "v1", namespaceArg: "namespace"}) # This subscription has to be disabled until https://github.com/kyma-project/kyma/issues/3412 gets resolved
    apiRuleEvent(namespace: String!, serviceName: String): ApiRuleEvent! @HasAccess(attributes: {resource: "apirules", verb: "watch", apiGroup: "gateway.kyma-project.io", apiVersion: "v1alpha", namespaceArg: "namespace"})

    namespaceEvent(withSystemNamespaces: Boolean): NamespaceEvent! @HasAccess(attributes: {resource: "namespaces", verb: "watch", apiGroup: "", apiVersion: "v1"})

    functionEvent(namespace: String!, functionName: String): FunctionEvent! @HasAccess(attributes: {resource: "functions", verb: "watch", apiGroup: "serverless.kyma-project.io", apiVersion: "v1alpha1", namespaceArg: "namespace"})
    triggerEvent(namespace: String!, subscriber: SubscriberInput): TriggerEvent! @HasAccess(attributes: {resource: "triggers", verb: "watch", apiGroup: "eventing.knative.dev", apiVersion: "v1alpha1", namespaceArg: "namespace"})
}

# Schema

schema {
    query: Query
    mutation: Mutation
}
`},
)
