#!/usr/bin/env bash
set -e ; # Have script exit in the event of a failed command.

echo "#############################
# Migration to Headless CMS #
#############################"

# connect to Minio
# Use a check-sleep-check loop to wait for Minio service to be available
connectToMinio() {
  SCHEME=http
  MINIO_ENDPOINT=assetstore-minio
  MINIO_PORT=9000
  CONFIG_NAME=$1
  ATTEMPTS=0 ; LIMIT=29 ; # Allow 30 attempts
  set -e ; # fail if we can't read the keys.
  ACCESS=$(cat /config/accesskey) ; SECRET=$(cat /config/secretkey) ;
  set +e ; # The connections to minio are allowed to fail.
  echo "Connecting to Minio server: $SCHEME://$MINIO_ENDPOINT:$MINIO_PORT" ;
  MC_COMMAND="mc config host add $CONFIG_NAME $SCHEME://$MINIO_ENDPOINT:$MINIO_PORT $ACCESS $SECRET" ;
  $MC_COMMAND ;
  STATUS=$? ;
  until [ $STATUS = 0 ]
  do
    ATTEMPTS=`expr $ATTEMPTS + 1` ;
    echo \"Failed attempts: $ATTEMPTS\" ;
    if [ $ATTEMPTS -gt $LIMIT ]; then
      exit 1 ;
    fi ;
    sleep 2 ; # 1 second intervals between attempts
    $MC_COMMAND ;
    STATUS=$? ;
  done ;
  set -e ; # reset `e` as active
  return 0
}

installDeps(){
    export KUBE_LATEST_VERSION="v1.14.0"
    apk add --update ca-certificates \
    && apk add --update -t deps curl \
    && apk add libxml2-utils \
    && curl -L https://storage.googleapis.com/kubernetes-release/release/${KUBE_LATEST_VERSION}/bin/linux/amd64/kubectl -o /usr/local/bin/kubectl \
    && chmod +x /usr/local/bin/kubectl \
    && curl https://dl.minio.io/client/mc/release/linux-amd64/mc > /usr/bin/mc \
    && chmod +x /usr/bin/mc
}

createDocsTopic() {

SC_ID=$1
OLD_URL=$2
FILE_NAME=$3


SPEC_TYPE=$(getAssetType "$FILE_NAME" "$OLD_URL")

cat <<EOF | kubectl apply -f -
apiVersion: cms.kyma-project.io/v1alpha1
kind: ClusterDocsTopic
metadata:
  name: $SC_ID
  labels:
    cms.kyma-project.io/view-context: service-catalog
spec:
  sources:
    - type: $SPEC_TYPE
      name: $SPEC_TYPE-spec
      mode: single
      url: $OLD_URL
EOF

}


getAppNames() {
   echo "$(kubectl get applications -o=jsonpath='{.items[*].metadata.name}')"
}

getAssetType() {
  FILE_NAME=$1
  OLD_URL=$2
  
  if [ "$FILE_NAME" = "apiSpec.json" ]; then
     # xmllint throws error if unable to format invalid XML and then variable is empty
     # in case of successful formatting grep specific for OData edmx files checks if such basic tag is in place
     # there is no other way to differenciate between OpenAPI or OData as they are always stored as apiSpec.json file
     VALID_XML_CONTENT=$(curl -s -N "$OLD_URL" | xmllint --format - | grep /edmx:Edmx)
     if [ "$VALID_XML_CONTENT" = "</edmx:Edmx>" ]; then
        echo "odata"
        else
        echo "openapi"
     fi
   else
     echo "asyncapi"
  fi
}

getAppServiceIds() {
    APP_NAME=$1
    echo $(kubectl get application "$APP_NAME" -o=jsonpath='{.spec.services[*].id}')
}

createMigratedResources() {
    APP_SERVICES_IDS_ARRAY=$1
    APP_NAME=$2
    CONFIG_NAME=$3

    for i in "${APP_SERVICES_IDS_ARRAY[@]}"
    do
      FILE_NAME=$(mc ls "$CONFIG_NAME"/content/service-class/"$i" | awk '{print $6}')
      SPEC_URL="$MINIO_DOMAIN"/content/service-class/"$i"/"$FILE_NAME"
      createDocsTopic "$i" "$SPEC_URL" "$FILE_NAME"
    done
}

installDeps
CONFIG_NAME="kymaminio"
connectToMinio "$CONFIG_NAME"

APPS_NAMES_ARRAY=($(getAppNames))

if [ ${#APPS_NAMES_ARRAY[@]} -eq 0 ]; then
  echo "There are no applications to migrate to Headless CMS"
else
  for i in "${APPS_NAMES_ARRAY[@]}"
  do

    APP_SERVICES_IDS_ARRAY=($(getAppServiceIds "$i"))

    if [ ${#APP_SERVICES_IDS_ARRAY[@]} -eq 0 ]; then
      echo "There are no specs for $i application to migrate to Headless CMS"
      else

      echo "Migration of specs for $i application started"

      createMigratedResources "$APP_SERVICES_IDS_ARRAY" "$i" "$CONFIG_NAME"

    fi

  done
fi
exit 0



