#!/usr/bin/env bash

set -o errexit
set -o nounset
set -o pipefail

readonly PRE_UPGRADE="PRE_UPGRADE"
readonly POST_UPGRADE="POST_UPGRADE"

# preUpgrade runs before upgrade process of minio release and create secret with old credentials 
#
preUpgrade() {
  local -r secret=$(kubectl get secret -n ${NAMESPACE} ${MINIO_SECRET_NAME} -ojson)
  local -r accesskeyold="$(echo ${secret} | jq -r '.data.accesskey')"
  local -r secretkeyold="$(echo ${secret} | jq -r '.data.secretkey')"

  # kubectl patch secret -n "${NAMESPACE}" "${SECRET_NAME}" \
  #   --patch "{\"spec\": {\"accesskeyold\": \"${accesskeyold}\", \"secretkeyold\": \"${secretkeyold}\"}}" \
  #   --type=merge

cat <<EOF | kubectl apply -f -
apiVersion: v1
kind: Secret
metadata:
  name: ${PATCH_CREDENTIALS_SECRET_NAME}
  namespace: ${NAMESPACE}
data:
  accesskey: ${accesskeyold}
  secretkey: ${secretkeyold}
EOF
}

# postUpgrade runs after upgrade process of minio release and remove from minio's deployment MINIO_ACCESS_KEY_OLD and MINIO_SECRET_KEY_OLD envs and delete secret with old credentials
#
postUpgrade() {
  kubectl set env -n "${NAMESPACE}" "deployment/${DEPLOYMENT_NAME}" -c "${CONTAINER_NAME}" MINIO_ACCESS_KEY_OLD-
  kubectl set env -n "${NAMESPACE}" "deployment/${DEPLOYMENT_NAME}" -c "${CONTAINER_NAME}" MINIO_SECRET_KEY_OLD-
  kubectl delete secret -n "${NAMESPACE}" "${PATCH_CREDENTIALS_SECRET_NAME}"
}

main() {
  if [ "$HELM_STEP" == "$PRE_UPGRADE" ]; then
    preUpgrade
  fi

  if [ "$HELM_STEP" == "$POST_UPGRADE" ]; then
    postUpgrade
  fi
}
main
