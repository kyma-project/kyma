apiVersion: batch/v1
kind: Job
metadata:
  name: {{ template "name" . }}-certs-job
spec:
  backoffLimit: 3
  template:
    metadata:
      name: {{ template "name" . }}-certs-job
      annotations:
        sidecar.istio.io/inject: "false"
    spec:
      serviceAccountName: {{ template "name" . }}-certs-job
      restartPolicy: OnFailure
      volumes:
        - name: {{ template "name" . }}-tls-cert
          secret:
            secretName: {{ template "name" . }}-tls-cert
            optional: true
      containers:
      - name: generate-certs
        image: {{ .Values.global.containerRegistry.path }}/{{ .Values.global.xip_patch.dir }}xip-patch:{{ .Values.global.xip_patch.version }}
        envFrom:
        - configMapRef:
            name: {{ template "name" . }}
            optional: true
        command:
        - bash
        - -c
        - |
          set -e
          # if running on Gardener create Certificate CR
          # else proceed 'old' way
          if [ "$DOMAIN" = "" ]; then
          {{ if .Values.global.domainName }}
          {{ if .Values.global.environment.gardener }}
          cat <<EOF | kubectl apply -f -
          apiVersion: cert.gardener.cloud/v1alpha1
          kind: Certificate
          metadata:
            name: apiserver-proxy-tls-cert
            namespace: kyma-system
          spec:
            commonName: "apiserver.{{ trimPrefix "*." .Values.global.domainName }}"
            secretName: "{{ template "name" . }}-tls-cert"
          EOF

            SECONDS=0
            END_TIME=$((SECONDS+600)) #600 seconds = 10 minutes
            while [ ${SECONDS} -lt ${END_TIME} ];do
              STATUS="$(kubectl get -n {{ .Release.Namespace }} certificate.cert.gardener.cloud {{ template "name" . }}-tls-cert -o jsonpath='{.status.state}')"
              if [ "${STATUS}" = "Ready" ]; then
                break
              fi
              echo "Waiting for Certicate generation, status is ${STATUS}"
              sleep 10
            done

            DOMAIN="apiserver.{{ trimPrefix "*." .Values.global.domainName }}"
          {{ else }}
              DOMAIN={{ .Values.global.domainName }}
          {{ end }}
          {{ else }}
            source /app/utils.sh
            INGRESS_IP=$(getLoadBalancerIP {{ template "name" . }}-ssl {{ .Release.Namespace }})
            DOMAIN="$INGRESS_IP.xip.io"
          {{ end }}
            kubectl create configmap {{ template "name" . }} --from-literal DOMAIN="$DOMAIN"
          fi
          if [ "$(cat /etc/apiserver-proxy-tls-cert/tls.key)" = "" ]; then
          # if running on Gardener && there is key mouted we skip, do nothing
          # if running on given by user domain create secret with key and cert
          # else generate domain and create secret
          {{ if .Values.global.environment.gardener }}
            echo "Skipping processing existing cert because environment is Gardener which rotates certs by itself"
          {{ else if .Values.global.tlsKey }}
            echo "{{ .Values.global.tlsKey }}" | base64 -d > ${HOME}/key.pem
            echo "{{ .Values.global.tlsCrt }}" | base64 -d > ${HOME}/cert.pem
            kubectl create secret tls {{ template "name" . }}-tls-cert  --key ${HOME}/key.pem --cert ${HOME}/cert.pem
          {{ else }}
            source /app/utils.sh
            generateCertificatesForDomain "$DOMAIN" ${HOME}/key.pem ${HOME}/cert.pem
            kubectl create secret tls {{ template "name" . }}-tls-cert  --key ${HOME}/key.pem --cert ${HOME}/cert.pem
          {{ end }}
          fi
        volumeMounts:
        - name: {{ template "name" . }}-tls-cert
          mountPath: /etc/apiserver-proxy-tls-cert/
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: {{ template "name" . }}-certs-job
  namespace: {{ .Release.Namespace}}
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: {{ template "name" . }}-certs-job
  namespace: {{ .Release.Namespace}}
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: {{ template "name" . }}-certs-job
subjects:
- kind: ServiceAccount
  name: {{ template "name" . }}-certs-job
  namespace: {{ .Release.Namespace }}
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: {{ template "name" . }}-certs-job
  namespace: {{ .Release.Namespace }}
rules:
- apiGroups: [""]
  resources: [configmaps, secrets, services]
  verbs: [create, list, get, watch]
---
{{- if .Capabilities.APIVersions.Has "cert.gardener.cloud/v1alpha1" }}
kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  namespace: kube-system
  name: {{ template "name" . }}-certs-job-kube-system-role
rules:
- apiGroups: [""]
  resources: ["configmaps"]
  resourceNames: ["shoot-info"]
  verbs: ["get"]
---
kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  namespace: {{ .Release.Namespace }}
  name: {{ template "name" . }}-certs-job-gardener-certs-role
rules:
- apiGroups: ["cert.gardener.cloud"]
  resources: ["certificates"]
  verbs: ["get", "create", "patch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: {{ template "name" . }}-certs-job-gardener-certs-role
  namespace: {{ .Release.Namespace}}
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: {{ template "name" . }}-certs-job-gardener-certs-role
subjects:
- kind: ServiceAccount
  name: {{ template "name" . }}-certs-job
  namespace: {{ .Release.Namespace }}
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: {{ template "name" . }}-certs-job-kube-system-role
  namespace: {{ .Release.Namespace}}
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: {{ template "name" . }}-certs-job-kube-system-role
subjects:
- kind: ServiceAccount
  name: {{ template "name" . }}-certs-job
  namespace: {{ .Release.Namespace }}
{{ end }}