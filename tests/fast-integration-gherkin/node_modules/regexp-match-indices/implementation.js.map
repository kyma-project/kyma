{"version":3,"file":"implementation.js","sourceRoot":"","sources":["implementation.ts"],"names":[],"mappings":"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","sourcesContent":["/*!\r\nCopyright 2019 Ron Buckton\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\");\r\nyou may not use this file except in compliance with the License.\r\nYou may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nUnless required by applicable law or agreed to in writing, software\r\ndistributed under the License is distributed on an \"AS IS\" BASIS,\r\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\nSee the License for the specific language governing permissions and\r\nlimitations under the License.\r\n*/\r\n\r\n/*\r\n require('foo').implementation or require('foo/implementation') is a spec-compliant JS function,\r\n that will depend on a receiver (a “this” value) as the spec requires.\r\n */\r\n\r\nimport config = require(\"./config\");\r\nimport nativeExec = require(\"./native\");\r\nimport { RegExpExecArray, RegExpExecIndicesArray } from \"./types\";\r\nimport {\r\n    AstNode,\r\n    AstRegExp,\r\n    CapturingGroup,\r\n    Expression\r\n} from \"regexp-tree/ast\";\r\nimport {\r\n    parse,\r\n    transform,\r\n    TransformResult,\r\n    TransformHandlers,\r\n    traverse,\r\n    TraversalCallbacks,\r\n    TraversalHandlers\r\n} from \"regexp-tree\";\r\n\r\nconst weakMeasurementRegExp = new WeakMap<RegExp, TransformResult<AstRegExp, readonly GroupInfo[]>>();\r\n\r\nfunction exec(this: RegExp, string: string): RegExpExecArray | null {\r\n    return config.mode === \"spec-compliant\"\r\n        ? execSpecCompliant(this, string)\r\n        : execLazy(this, string);\r\n}\r\n\r\nfunction execLazy(regexp: RegExp, string: string) {\r\n    const index = regexp.lastIndex;\r\n    const result = nativeExec.call(regexp, string);\r\n    if (result === null) return null;\r\n\r\n    // For performance reasons, we defer computing the indices until later. This isn't spec compliant,\r\n    // but once we compute the indices we convert the result to a data-property.\r\n    let indicesArray: RegExpExecIndicesArray | undefined;\r\n    Object.defineProperty(result, \"indices\", {\r\n        enumerable: true,\r\n        configurable: true,\r\n        get() {\r\n            if (indicesArray === undefined) {\r\n                const { measurementRegExp, groupInfos } = getMeasurementRegExp(regexp);\r\n                measurementRegExp.lastIndex = index;\r\n                const measuredResult = nativeExec.call(measurementRegExp, string);\r\n                if (measuredResult === null) throw new TypeError();\r\n                makeDataProperty(result, \"indices\", indicesArray = makeIndicesArray(measuredResult, groupInfos));\r\n            }\r\n            return indicesArray;\r\n        },\r\n        set(value) {\r\n            makeDataProperty(result, \"indices\", value);\r\n        }\r\n    });\r\n    return result;\r\n}\r\n\r\nfunction execSpecCompliant(regexp: RegExp, string: string) {\r\n    const { measurementRegExp, groupInfos } = getMeasurementRegExp(regexp);\r\n    measurementRegExp.lastIndex = regexp.lastIndex;\r\n\r\n    const measuredResult = nativeExec.call(measurementRegExp, string);\r\n    if (measuredResult === null) return null;\r\n\r\n    regexp.lastIndex = measurementRegExp.lastIndex;\r\n\r\n    const result = [] as unknown as RegExpExecArray;\r\n    makeDataProperty(result, 0, measuredResult[0]);\r\n\r\n    for (const groupInfo of groupInfos) {\r\n        makeDataProperty(result, groupInfo.oldGroupNumber, measuredResult[groupInfo.newGroupNumber]);\r\n    }\r\n\r\n    makeDataProperty(result, \"index\", measuredResult.index);\r\n    makeDataProperty(result, \"input\", measuredResult.input);\r\n    makeDataProperty(result, \"groups\", measuredResult.groups);\r\n    makeDataProperty(result, \"indices\", makeIndicesArray(measuredResult, groupInfos));\r\n    return result;\r\n}\r\n\r\nfunction getMeasurementRegExp(regexp: RegExp) {\r\n    let transformed = weakMeasurementRegExp.get(regexp);\r\n    if (!transformed) {\r\n        transformed = transformMeasurementGroups(parse(`/${regexp.source}/${regexp.flags}`));\r\n        weakMeasurementRegExp.set(regexp, transformed);\r\n    }\r\n    const groupInfos = transformed.getExtra();\r\n    const measurementRegExp = transformed.toRegExp();\r\n    return { measurementRegExp, groupInfos };\r\n}\r\n\r\nfunction makeIndicesArray(measuredResult: RegExpExecArray, groupInfos: readonly GroupInfo[]) {\r\n    const matchStart = measuredResult.index;\r\n    const matchEnd = matchStart + measuredResult[0].length;\r\n    const hasGroups = !!measuredResult.groups;\r\n    const indicesArray = [] as RegExpExecIndicesArray;\r\n    const groups: Record<string, [number, number]> | undefined = hasGroups ? Object.create(null) : undefined;\r\n    makeDataProperty(indicesArray, 0, [matchStart, matchEnd]);\r\n\r\n    for (const groupInfo of groupInfos) {\r\n        let indices: [number, number] | undefined;\r\n        if (measuredResult[groupInfo.newGroupNumber] !== undefined) {\r\n            let startIndex = matchStart;\r\n            if (groupInfo.measurementGroups) {\r\n                for (const measurementGroup of groupInfo.measurementGroups) {\r\n                    startIndex += measuredResult[measurementGroup].length;\r\n                }\r\n            }\r\n\r\n            const endIndex = startIndex + measuredResult[groupInfo.newGroupNumber].length;\r\n            indices = [startIndex, endIndex];\r\n        }\r\n        makeDataProperty(indicesArray, groupInfo.oldGroupNumber, indices!);\r\n        if (groups && groupInfo.groupName !== undefined) {\r\n            makeDataProperty(groups, groupInfo.groupName, indices!);\r\n        }\r\n    }\r\n\r\n    makeDataProperty(indicesArray, \"groups\", groups);\r\n    return indicesArray;\r\n}\r\n\r\nfunction makeDataProperty<T, K extends keyof T>(result: T, key: K, value: T[K]) {\r\n    const existingDesc = Object.getOwnPropertyDescriptor(result, key);\r\n    if (existingDesc ? existingDesc.configurable : Object.isExtensible(result)) {\r\n        const newDesc = {\r\n            enumerable: existingDesc ? existingDesc.enumerable : true,\r\n            configurable: existingDesc ? existingDesc.configurable : true,\r\n            writable: true,\r\n            value\r\n        };\r\n        Object.defineProperty(result, key, newDesc);\r\n    }\r\n}\r\n\r\ninterface GroupInfo {\r\n    readonly oldGroupNumber: number;\r\n    readonly newGroupNumber: number;\r\n    readonly measurementGroups: ReadonlyArray<number> | undefined;\r\n    readonly groupName?: string;\r\n}\r\n\r\nlet groupRenumbers: GroupInfo[] | undefined;\r\nlet hasBackreferences = false;\r\nlet nodesContainingCapturingGroup = new Set<AstNode>();\r\nlet containsCapturingGroupStack: boolean[] = [];\r\nlet containsCapturingGroup = false;\r\nlet nextNewGroupNumber = 1;\r\nlet measurementGroupStack: CapturingGroup[][] = [];\r\nlet measurementGroupsForGroup = new Map<CapturingGroup, CapturingGroup[]>();\r\nlet newGroupNumberForGroup = new Map<number, number>();\r\n\r\nconst handlers: TransformHandlers<AstRegExp> = {\r\n    init() {\r\n        hasBackreferences = false;\r\n        nodesContainingCapturingGroup.clear();\r\n        containsCapturingGroupStack.length = 0;\r\n        containsCapturingGroup = false;\r\n        nextNewGroupNumber = 1;\r\n        measurementGroupStack.length = 0;\r\n        measurementGroupsForGroup.clear();\r\n        newGroupNumberForGroup.clear();\r\n        groupRenumbers = [];\r\n    },\r\n    RegExp(path) {\r\n        traverse(path.node, visitor);\r\n        if (nodesContainingCapturingGroup.size > 0) {\r\n            transform(path.node, builder);\r\n            transform(path.node, groupRenumberer);\r\n            if (hasBackreferences) {\r\n                transform(path.node, backreferenceRenumberer);\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n};\r\n\r\nconst nodeCallbacks: TraversalCallbacks = {\r\n    pre(path) {\r\n        containsCapturingGroupStack.push(containsCapturingGroup);\r\n        containsCapturingGroup = path.node.type === \"Group\" && path.node.capturing;\r\n    },\r\n    post(path) {\r\n        if (containsCapturingGroup) {\r\n            nodesContainingCapturingGroup.add(path.node);\r\n        }\r\n        containsCapturingGroup = containsCapturingGroupStack.pop() || containsCapturingGroup;\r\n    }\r\n};\r\n\r\nconst visitor: TraversalHandlers = {\r\n    Alternative: nodeCallbacks,\r\n    Disjunction: nodeCallbacks,\r\n    Assertion: nodeCallbacks,\r\n    Group: nodeCallbacks,\r\n    Repetition: nodeCallbacks,\r\n    Backreference(path) { hasBackreferences = true; }\r\n};\r\n\r\nconst builder: TransformHandlers = {\r\n    Alternative(path) {\r\n        if (nodesContainingCapturingGroup.has(path.node)) {\r\n            // aa(b)c       -> (aa)(b)c\r\n            // aa(b)c(d)    -> (aa)(b)(c)(d)\r\n            // aa(b)+c(d)   -> (aa)((b)+)(c)(d);\r\n            let lastMeasurementIndex = 0;\r\n            let pendingTerms: Expression[] = [];\r\n            const measurementGroups: CapturingGroup[] = [];\r\n            const terms: Expression[] = [];\r\n            for (let i = 0; i < path.node.expressions.length; i++) {\r\n                const term = path.node.expressions[i];\r\n                if (nodesContainingCapturingGroup.has(term)) {\r\n                    if (i > lastMeasurementIndex) {\r\n                        const measurementGroup: CapturingGroup = {\r\n                            type: \"Group\",\r\n                            capturing: true,\r\n                            number: -1,\r\n                            expression:\r\n                                pendingTerms.length > 1 ? { type: \"Alternative\", expressions: pendingTerms } :\r\n                                pendingTerms.length === 1 ? pendingTerms[0] :\r\n                                null\r\n                        };\r\n                        terms.push(measurementGroup);\r\n                        measurementGroups.push(measurementGroup);\r\n                        lastMeasurementIndex = i;\r\n                        pendingTerms = [];\r\n                    }\r\n                    measurementGroupStack.push(measurementGroups);\r\n                    transform(term, builder);\r\n                    measurementGroupStack.pop();\r\n                    pendingTerms.push(term);\r\n                    continue;\r\n                }\r\n\r\n                pendingTerms.push(term);\r\n            }\r\n            path.update({ expressions: terms.concat(pendingTerms) });\r\n        }\r\n        return false;\r\n    },\r\n    Group(path) {\r\n        if (!path.node.capturing) return;\r\n        measurementGroupsForGroup.set(path.node, getMeasurementGroups());\r\n    }\r\n};\r\n\r\nconst groupRenumberer: TransformHandlers = {\r\n    Group(path) {\r\n        if (!groupRenumbers) throw new Error(\"Not initialized.\");\r\n        if (!path.node.capturing) return;\r\n        const oldGroupNumber = path.node.number;\r\n        const newGroupNumber = nextNewGroupNumber++;\r\n        const measurementGroups = measurementGroupsForGroup.get(path.node);\r\n        if (oldGroupNumber !== -1) {\r\n            groupRenumbers.push({\r\n                oldGroupNumber,\r\n                newGroupNumber,\r\n                measurementGroups: measurementGroups && measurementGroups.map(group => group.number),\r\n                groupName: path.node.name\r\n            });\r\n            newGroupNumberForGroup.set(oldGroupNumber, newGroupNumber);\r\n        }\r\n        path.update({ number: newGroupNumber });\r\n    }\r\n};\r\n\r\nconst backreferenceRenumberer: TransformHandlers = {\r\n    Backreference(path) {\r\n        const newGroupNumber = newGroupNumberForGroup.get(path.node.number);\r\n        if (newGroupNumber) {\r\n            if (path.node.kind === \"number\") {\r\n                path.update({\r\n                    number: newGroupNumber,\r\n                    reference: newGroupNumber\r\n                });\r\n            }\r\n            else {\r\n                path.update({\r\n                    number: newGroupNumber\r\n                });\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nfunction getMeasurementGroups() {\r\n    const measurementGroups: CapturingGroup[] = [];\r\n    for (const array of measurementGroupStack) {\r\n        for (const item of array) {\r\n            measurementGroups.push(item);\r\n        }\r\n    }\r\n    return measurementGroups;\r\n}\r\n\r\nfunction transformMeasurementGroups(ast: AstRegExp) {\r\n    const result = transform(ast, handlers);\r\n    return new TransformResult(result.getAST(), groupRenumbers as readonly GroupInfo[]);\r\n}\r\n\r\nexport = exec;"]}