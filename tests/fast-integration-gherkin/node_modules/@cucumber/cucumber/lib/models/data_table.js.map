{"version":3,"file":"data_table.js","sourceRoot":"","sources":["../../src/models/data_table.ts"],"names":[],"mappings":";;;;;AAAA,oDAAsB;AAGtB,MAAqB,SAAS;IAG5B,YAAY,WAA8C;QACxD,IAAI,WAAW,YAAY,KAAK,EAAE;YAChC,IAAI,CAAC,QAAQ,GAAG,WAAW,CAAA;SAC5B;aAAM;YACL,IAAI,CAAC,QAAQ,GAAG,WAAW,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,EAAE,CAC3C,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,CACpC,CAAA;SACF;IACH,CAAC;IAED,MAAM;QACJ,MAAM,IAAI,GAAG,IAAI,CAAC,GAAG,EAAE,CAAA;QACvB,MAAM,IAAI,GAAG,IAAI,CAAC,CAAC,CAAC,CAAA;QACpB,MAAM,WAAW,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAA;QACjC,OAAO,WAAW,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,gBAAC,CAAC,SAAS,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC,CAAA;IAC/D,CAAC;IAED,GAAG;QACD,OAAO,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAA;IAC/B,CAAC;IAED,IAAI;QACF,MAAM,IAAI,GAAG,IAAI,CAAC,GAAG,EAAE,CAAA;QACvB,IAAI,CAAC,KAAK,EAAE,CAAA;QACZ,OAAO,IAAI,CAAA;IACb,CAAC;IAED,QAAQ;QACN,MAAM,IAAI,GAAG,IAAI,CAAC,GAAG,EAAE,CAAA;QACvB,MAAM,qBAAqB,GAAG,gBAAC,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,GAAG,CAAC,MAAM,KAAK,CAAC,CAAC,CAAA;QACtE,IAAI,CAAC,qBAAqB,EAAE;YAC1B,MAAM,IAAI,KAAK,CACb,qFAAqF,CACtF,CAAA;SACF;QACD,OAAO,gBAAC,CAAC,SAAS,CAAC,IAAI,CAAC,CAAA;IAC1B,CAAC;IAED,SAAS;QACP,MAAM,UAAU,GAAG,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAC/C,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAC/B,CAAA;QACD,OAAO,IAAI,SAAS,CAAC,UAAU,CAAC,CAAA;IAClC,CAAC;CACF;AA/CD,4BA+CC","sourcesContent":["import _ from 'lodash'\nimport * as messages from '@cucumber/messages'\n\nexport default class DataTable {\n  private readonly rawTable: string[][]\n\n  constructor(sourceTable: messages.PickleTable | string[][]) {\n    if (sourceTable instanceof Array) {\n      this.rawTable = sourceTable\n    } else {\n      this.rawTable = sourceTable.rows.map((row) =>\n        row.cells.map((cell) => cell.value)\n      )\n    }\n  }\n\n  hashes(): any[] {\n    const copy = this.raw()\n    const keys = copy[0]\n    const valuesArray = copy.slice(1)\n    return valuesArray.map((values) => _.zipObject(keys, values))\n  }\n\n  raw(): string[][] {\n    return this.rawTable.slice(0)\n  }\n\n  rows(): string[][] {\n    const copy = this.raw()\n    copy.shift()\n    return copy\n  }\n\n  rowsHash(): Record<string, string> {\n    const rows = this.raw()\n    const everyRowHasTwoColumns = _.every(rows, (row) => row.length === 2)\n    if (!everyRowHasTwoColumns) {\n      throw new Error(\n        'rowsHash can only be called on a data table where all rows have exactly two columns'\n      )\n    }\n    return _.fromPairs(rows)\n  }\n\n  transpose(): DataTable {\n    const transposed = this.rawTable[0].map((x, i) =>\n      this.rawTable.map((y) => y[i])\n    )\n    return new DataTable(transposed)\n  }\n}\n"]}