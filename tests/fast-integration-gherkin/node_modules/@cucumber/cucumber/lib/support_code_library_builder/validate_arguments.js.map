{"version":3,"file":"validate_arguments.js","sourceRoot":"","sources":["../../src/support_code_library_builder/validate_arguments.ts"],"names":[],"mappings":";;;;;AAAA,oDAAsB;AACtB,oDAAmD;AAenD,MAAM,iBAAiB,GAAG;IACxB,YAAY,EAAE,oBAAoB;IAClC,SAAS,CAAC,EAAE,OAAO,EAAwB;QACzC,OAAO,gBAAC,CAAC,aAAa,CAAC,OAAO,CAAC,CAAA;IACjC,CAAC;CACF,CAAA;AAED,MAAM,wBAAwB,GAAG;IAC/B,UAAU,EAAE,mBAAmB;IAC/B,YAAY,EAAE,SAAS;IACvB,SAAS,CAAC,EAAE,OAAO,EAAwB;QACzC,OAAO,gCAAgB,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,gBAAC,CAAC,SAAS,CAAC,OAAO,CAAC,OAAO,CAAC,CAAA;IAC1E,CAAC;CACF,CAAA;AAED,MAAM,YAAY,GAAG;IACnB,YAAY,EAAE,UAAU;IACxB,SAAS,CAAC,EAAE,IAAI,EAAwB;QACtC,OAAO,gBAAC,CAAC,UAAU,CAAC,IAAI,CAAC,CAAA;IAC3B,CAAC;CACF,CAAA;AAED,MAAM,WAAW,GAAkC;IACjD,iBAAiB,EAAE;wBACf,UAAU,EAAE,gBAAgB,IAAK,iBAAiB;QACpD,wBAAwB;wBACtB,UAAU,EAAE,iBAAiB,IAAK,YAAY;KACjD;IACD,kBAAkB,EAAE;wBAChB,UAAU,EAAE,gBAAgB,IAAK,iBAAiB;QACpD;YACE,UAAU,EAAE,gBAAgB;YAC5B,YAAY,EAAE,QAAQ;YACtB,SAAS,CAAC,EAAE,OAAO,EAAE;gBACnB,OAAO,gCAAgB,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,gBAAC,CAAC,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,CAAA;YACnE,CAAC;SACF;QACD,wBAAwB;wBACtB,UAAU,EAAE,iBAAiB,IAAK,YAAY;KACjD;IACD,kBAAkB,EAAE;wBAChB,UAAU,EAAE,gBAAgB,IAAK,iBAAiB;QACpD;YACE,UAAU,EAAE,gBAAgB;YAC5B,YAAY,EAAE,QAAQ;YACtB,SAAS,CAAC,EAAE,OAAO,EAAE;gBACnB,OAAO,gCAAgB,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,gBAAC,CAAC,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,CAAA;YACnE,CAAC;SACF;QACD,wBAAwB;wBACtB,UAAU,EAAE,iBAAiB,IAAK,YAAY;KACjD;IACD,UAAU,EAAE;QACV;YACE,UAAU,EAAE,gBAAgB;YAC5B,YAAY,EAAE,8BAA8B;YAC5C,SAAS,CAAC,EAAE,OAAO,EAAE;gBACnB,OAAO,gBAAC,CAAC,QAAQ,CAAC,OAAO,CAAC,IAAI,gBAAC,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAA;YACnD,CAAC;SACF;wBACC,UAAU,EAAE,iBAAiB,IAAK,iBAAiB;QACrD,wBAAwB;wBACtB,UAAU,EAAE,gBAAgB,IAAK,YAAY;KAChD;CACF,CAAA;AAED,SAAwB,iBAAiB,CAAC,EACxC,IAAI,EACJ,MAAM,EACN,QAAQ,GAKT;IACC,WAAW,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,CAAC,EAAE,UAAU,EAAE,YAAY,EAAE,SAAS,EAAE,EAAE,EAAE;QACtE,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,EAAE;YACpB,MAAM,IAAI,KAAK,CACb,GAAG,QAAQ,aAAa,UAAU,iBAAiB,YAAY,EAAE,CAClE,CAAA;SACF;IACH,CAAC,CAAC,CAAA;AACJ,CAAC;AAhBD,oCAgBC","sourcesContent":["import _ from 'lodash'\nimport { doesNotHaveValue } from '../value_checker'\nimport { DefineStepPattern, IDefineStepOptions } from './types'\n\ninterface IValidation {\n  identifier: string\n  expectedType: string\n  predicate: (args: any) => boolean\n}\n\ninterface IDefineStepArguments {\n  pattern?: DefineStepPattern\n  options?: IDefineStepOptions\n  code?: Function\n}\n\nconst optionsValidation = {\n  expectedType: 'object or function',\n  predicate({ options }: IDefineStepArguments) {\n    return _.isPlainObject(options)\n  },\n}\n\nconst optionsTimeoutValidation = {\n  identifier: '\"options.timeout\"',\n  expectedType: 'integer',\n  predicate({ options }: IDefineStepArguments) {\n    return doesNotHaveValue(options.timeout) || _.isInteger(options.timeout)\n  },\n}\n\nconst fnValidation = {\n  expectedType: 'function',\n  predicate({ code }: IDefineStepArguments) {\n    return _.isFunction(code)\n  },\n}\n\nconst validations: Record<string, IValidation[]> = {\n  defineTestRunHook: [\n    { identifier: 'first argument', ...optionsValidation },\n    optionsTimeoutValidation,\n    { identifier: 'second argument', ...fnValidation },\n  ],\n  defineTestCaseHook: [\n    { identifier: 'first argument', ...optionsValidation },\n    {\n      identifier: '\"options.tags\"',\n      expectedType: 'string',\n      predicate({ options }) {\n        return doesNotHaveValue(options.tags) || _.isString(options.tags)\n      },\n    },\n    optionsTimeoutValidation,\n    { identifier: 'second argument', ...fnValidation },\n  ],\n  defineTestStepHook: [\n    { identifier: 'first argument', ...optionsValidation },\n    {\n      identifier: '\"options.tags\"',\n      expectedType: 'string',\n      predicate({ options }) {\n        return doesNotHaveValue(options.tags) || _.isString(options.tags)\n      },\n    },\n    optionsTimeoutValidation,\n    { identifier: 'second argument', ...fnValidation },\n  ],\n  defineStep: [\n    {\n      identifier: 'first argument',\n      expectedType: 'string or regular expression',\n      predicate({ pattern }) {\n        return _.isRegExp(pattern) || _.isString(pattern)\n      },\n    },\n    { identifier: 'second argument', ...optionsValidation },\n    optionsTimeoutValidation,\n    { identifier: 'third argument', ...fnValidation },\n  ],\n}\n\nexport default function validateArguments({\n  args,\n  fnName,\n  location,\n}: {\n  args?: IDefineStepArguments\n  fnName: string\n  location: string\n}): void {\n  validations[fnName].forEach(({ identifier, expectedType, predicate }) => {\n    if (!predicate(args)) {\n      throw new Error(\n        `${location}: Invalid ${identifier}: should be a ${expectedType}`\n      )\n    }\n  })\n}\n"]}