{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../src/runtime/attachment_manager/index.ts"],"names":[],"mappings":"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","sourcesContent":["import isStream from 'is-stream'\nimport { Readable } from 'stream'\nimport * as messages from '@cucumber/messages'\nimport { doesHaveValue, doesNotHaveValue } from '../../value_checker'\n\nexport interface IAttachmentMedia {\n  encoding: messages.AttachmentContentEncoding\n  contentType: string\n}\n\nexport interface IAttachment {\n  data: string\n  media: IAttachmentMedia\n}\n\nexport type IAttachFunction = (attachment: IAttachment) => void\nexport type ICreateAttachment = (\n  data: Buffer | Readable | string,\n  mediaType?: string,\n  callback?: () => void\n) => void | Promise<void>\nexport type ICreateLog = (text: string) => void | Promise<void>\n\nexport default class AttachmentManager {\n  private readonly onAttachment: IAttachFunction\n\n  constructor(onAttachment: IAttachFunction) {\n    this.onAttachment = onAttachment\n  }\n\n  log(text: string): void | Promise<void> {\n    return this.create(text, 'text/x.cucumber.log+plain')\n  }\n\n  create(\n    data: Buffer | Readable | string,\n    mediaType?: string,\n    callback?: () => void\n  ): void | Promise<void> {\n    if (Buffer.isBuffer(data)) {\n      if (doesNotHaveValue(mediaType)) {\n        throw Error('Buffer attachments must specify a media type')\n      }\n      this.createBufferAttachment(data, mediaType)\n    } else if (isStream.readable(data)) {\n      if (doesNotHaveValue(mediaType)) {\n        throw Error('Stream attachments must specify a media type')\n      }\n      return this.createStreamAttachment(data, mediaType, callback)\n    } else if (typeof data === 'string') {\n      if (doesNotHaveValue(mediaType)) {\n        mediaType = 'text/plain'\n      }\n      if (mediaType.startsWith('base64:')) {\n        this.createStringAttachment(data, {\n          encoding: messages.AttachmentContentEncoding.BASE64,\n          contentType: mediaType.replace('base64:', ''),\n        })\n      } else {\n        this.createStringAttachment(data, {\n          encoding: messages.AttachmentContentEncoding.IDENTITY,\n          contentType: mediaType,\n        })\n      }\n    } else {\n      throw Error(\n        'Invalid attachment data: must be a buffer, readable stream, or string'\n      )\n    }\n  }\n\n  createBufferAttachment(data: Buffer, mediaType: string): void {\n    this.createStringAttachment(data.toString('base64'), {\n      encoding: messages.AttachmentContentEncoding.BASE64,\n      contentType: mediaType,\n    })\n  }\n\n  createStreamAttachment(\n    data: Readable,\n    mediaType: string,\n    callback: () => void\n  ): void | Promise<void> {\n    const promise = new Promise<void>((resolve, reject) => {\n      const buffers: Uint8Array[] = []\n      data.on('data', (chunk) => {\n        buffers.push(chunk)\n      })\n      data.on('end', () => {\n        this.createBufferAttachment(Buffer.concat(buffers), mediaType)\n        resolve()\n      })\n      data.on('error', reject)\n    })\n    if (doesHaveValue(callback)) {\n      promise.then(callback, callback)\n    } else {\n      return promise\n    }\n  }\n\n  createStringAttachment(data: string, media: IAttachmentMedia): void {\n    this.onAttachment({ data, media })\n  }\n}\n"]}