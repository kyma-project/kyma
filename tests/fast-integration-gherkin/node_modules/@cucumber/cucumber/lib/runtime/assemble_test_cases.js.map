{"version":3,"file":"assemble_test_cases.js","sourceRoot":"","sources":["../../src/runtime/assemble_test_cases.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventEmitter } from 'events'\nimport * as messages from '@cucumber/messages'\nimport { IdGenerator } from '@cucumber/messages'\nimport { ISupportCodeLibrary } from '../support_code_library_builder/types'\nimport { Group } from '@cucumber/cucumber-expressions'\nimport { doesHaveValue } from '../value_checker'\nimport { clone } from 'lodash'\n\nexport declare type IAssembledTestCases = Record<string, messages.TestCase>\n\nexport interface IAssembleTestCasesOptions {\n  eventBroadcaster: EventEmitter\n  newId: IdGenerator.NewId\n  pickles: messages.Pickle[]\n  supportCodeLibrary: ISupportCodeLibrary\n}\n\nexport async function assembleTestCases({\n  eventBroadcaster,\n  newId,\n  pickles,\n  supportCodeLibrary,\n}: IAssembleTestCasesOptions): Promise<IAssembledTestCases> {\n  const result: IAssembledTestCases = {}\n  for (const pickle of pickles) {\n    const { id: pickleId } = pickle\n    const testCaseId = newId()\n    const fromBeforeHooks: messages.TestStep[] = makeBeforeHookSteps({\n      supportCodeLibrary,\n      pickle,\n      newId,\n    })\n    const fromStepDefinitions: messages.TestStep[] = makeSteps({\n      pickle,\n      supportCodeLibrary,\n      newId,\n    })\n    const fromAfterHooks: messages.TestStep[] = makeAfterHookSteps({\n      supportCodeLibrary,\n      pickle,\n      newId,\n    })\n    const testCase: messages.TestCase = {\n      pickleId,\n      id: testCaseId,\n      testSteps: [\n        ...fromBeforeHooks,\n        ...fromStepDefinitions,\n        ...fromAfterHooks,\n      ],\n    }\n    eventBroadcaster.emit('envelope', { testCase })\n    result[pickleId] = testCase\n  }\n  return result\n}\n\nfunction makeAfterHookSteps({\n  supportCodeLibrary,\n  pickle,\n  newId,\n}: {\n  supportCodeLibrary: ISupportCodeLibrary\n  pickle: messages.Pickle\n  newId: IdGenerator.NewId\n}): messages.TestStep[] {\n  return clone(supportCodeLibrary.afterTestCaseHookDefinitions)\n    .reverse()\n    .filter((hookDefinition) => hookDefinition.appliesToTestCase(pickle))\n    .map((hookDefinition) => ({\n      id: newId(),\n      hookId: hookDefinition.id,\n    }))\n}\n\nfunction makeBeforeHookSteps({\n  supportCodeLibrary,\n  pickle,\n  newId,\n}: {\n  supportCodeLibrary: ISupportCodeLibrary\n  pickle: messages.Pickle\n  newId: IdGenerator.NewId\n}): messages.TestStep[] {\n  return supportCodeLibrary.beforeTestCaseHookDefinitions\n    .filter((hookDefinition) => hookDefinition.appliesToTestCase(pickle))\n    .map((hookDefinition) => ({\n      id: newId(),\n      hookId: hookDefinition.id,\n    }))\n}\n\nfunction makeSteps({\n  pickle,\n  supportCodeLibrary,\n  newId,\n}: {\n  pickle: messages.Pickle\n  supportCodeLibrary: ISupportCodeLibrary\n  newId: () => string\n}): messages.TestStep[] {\n  return pickle.steps.map((pickleStep) => {\n    const stepDefinitions = supportCodeLibrary.stepDefinitions.filter(\n      (stepDefinition) => stepDefinition.matchesStepName(pickleStep.text)\n    )\n    return {\n      id: newId(),\n      pickleStepId: pickleStep.id,\n      stepDefinitionIds: stepDefinitions.map(\n        (stepDefinition) => stepDefinition.id\n      ),\n      stepMatchArgumentsLists: stepDefinitions.map((stepDefinition) => {\n        const result = stepDefinition.expression.match(pickleStep.text)\n        return {\n          stepMatchArguments: result.map((arg) => {\n            return {\n              group: mapArgumentGroup(arg.group),\n              parameterTypeName: arg.parameterType.name,\n            }\n          }),\n        }\n      }),\n    }\n  })\n}\n\nfunction mapArgumentGroup(group: Group): messages.Group {\n  return {\n    start: group.start,\n    value: group.value,\n    children: doesHaveValue(group.children)\n      ? group.children.map((child) => mapArgumentGroup(child))\n      : undefined,\n  }\n}\n"]}