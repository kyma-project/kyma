{"version":3,"file":"issue_helpers.js","sourceRoot":"","sources":["../../../src/formatter/helpers/issue_helpers.ts"],"names":[],"mappings":";;;;;;AAAA,kEAAwC;AACxC,+EAAqE;AAOrE,SAAgB,SAAS,CAAC,MAA+B;IACvD,OAAO,CACL,MAAM,CAAC,MAAM,KAAK,WAAW;QAC7B,MAAM,CAAC,MAAM,KAAK,WAAW;QAC7B,CAAC,MAAM,CAAC,MAAM,KAAK,QAAQ,IAAI,CAAC,MAAM,CAAC,aAAa,CAAC,CACtD,CAAA;AACH,CAAC;AAND,8BAMC;AAED,SAAgB,SAAS,CAAC,MAA+B;IACvD,OAAO,CACL,MAAM,CAAC,MAAM,KAAK,SAAS;QAC3B,CAAC,MAAM,CAAC,MAAM,KAAK,QAAQ,IAAI,MAAM,CAAC,aAAa,CAAC,CACrD,CAAA;AACH,CAAC;AALD,8BAKC;AAED,SAAgB,OAAO,CAAC,MAA+B;IACrD,OAAO,SAAS,CAAC,MAAM,CAAC,IAAI,SAAS,CAAC,MAAM,CAAC,CAAA;AAC/C,CAAC;AAFD,0BAEC;AAWD,SAAgB,WAAW,CAAC,EAC1B,QAAQ,EACR,GAAG,EACH,MAAM,EACN,cAAc,EACd,eAAe,EACf,kBAAkB,GACE;IACpB,MAAM,MAAM,GAAG,GAAG,MAAM,CAAC,QAAQ,EAAE,IAAI,CAAA;IACvC,MAAM,wBAAwB,GAAG,mDAAqB,CAAC;QACrD,QAAQ;QACR,GAAG;QACH,cAAc;QACd,eAAe;QACf,kBAAkB;KACnB,CAAC,CAAA;IACF,MAAM,KAAK,GAAG,wBAAwB,CAAC,KAAK,CAAC,IAAI,CAAC,CAAA;IAClD,MAAM,YAAY,GAAG,KAAK,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,KAAK,EAAE,EAAE;QAC7C,IAAI,KAAK,KAAK,CAAC,EAAE;YACf,OAAO,GAAG,MAAM,GAAG,IAAI,EAAE,CAAA;SAC1B;QACD,OAAO,uBAAY,CAAC,IAAI,EAAE,MAAM,CAAC,MAAM,CAAC,CAAA;IAC1C,CAAC,CAAC,CAAA;IACF,OAAO,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;AAChC,CAAC;AAxBD,kCAwBC;AAED,SAAgB,6BAA6B,CAC3C,uBAA0D;IAE1D,MAAM,MAAM,GAAG,CAAC,gCAAgC,CAAC,CAAA;IACjD,MAAM,UAAU,GAAoD,EAAE,CAAA;IACtE,uBAAuB,CAAC,OAAO,CAAC,CAAC,aAAa,EAAE,EAAE;QAChD,UAAU,CAAC,aAAa,CAAC,IAAI,CAAC,GAAG,aAAa,CAAA;IAChD,CAAC,CAAC,CAAA;IACF,MAAM,CAAC,IAAI,CACT,MAAM,CAAC,MAAM,CAAC,UAAU,CAAC;SACtB,GAAG,CACF,CAAC,aAAa,EAAE,EAAE,CAAC,KAAK,4BAA4B,CAAC,aAAa,CAAC,EAAE,CACtE;SACA,IAAI,CAAC,IAAI,CAAC,CACd,CAAA;IACD,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAA;IACnB,OAAO,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,CAAA;AACxB,CAAC;AAjBD,sEAiBC;AAED,SAAgB,4BAA4B,CAC1C,aAA8C;IAE9C,OAAO,IAAI,aAAa,CAAC,IAAI,YAAY,aAAa,CAAC,UAAU,IAAI,CAAA;AACvE,CAAC;AAJD,oEAIC","sourcesContent":["import indentString from 'indent-string'\nimport { formatTestCaseAttempt } from './test_case_attempt_formatter'\nimport * as messages from '@cucumber/messages'\nimport { IColorFns } from '../get_color_fns'\nimport StepDefinitionSnippetBuilder from '../step_definition_snippet_builder'\nimport { ISupportCodeLibrary } from '../../support_code_library_builder/types'\nimport { ITestCaseAttempt } from './event_data_collector'\n\nexport function isFailure(result: messages.TestStepResult): boolean {\n  return (\n    result.status === 'AMBIGUOUS' ||\n    result.status === 'UNDEFINED' ||\n    (result.status === 'FAILED' && !result.willBeRetried)\n  )\n}\n\nexport function isWarning(result: messages.TestStepResult): boolean {\n  return (\n    result.status === 'PENDING' ||\n    (result.status === 'FAILED' && result.willBeRetried)\n  )\n}\n\nexport function isIssue(result: messages.TestStepResult): boolean {\n  return isFailure(result) || isWarning(result)\n}\n\nexport interface IFormatIssueRequest {\n  colorFns: IColorFns\n  cwd: string\n  number: number\n  snippetBuilder: StepDefinitionSnippetBuilder\n  testCaseAttempt: ITestCaseAttempt\n  supportCodeLibrary: ISupportCodeLibrary\n}\n\nexport function formatIssue({\n  colorFns,\n  cwd,\n  number,\n  snippetBuilder,\n  testCaseAttempt,\n  supportCodeLibrary,\n}: IFormatIssueRequest): string {\n  const prefix = `${number.toString()}) `\n  const formattedTestCaseAttempt = formatTestCaseAttempt({\n    colorFns,\n    cwd,\n    snippetBuilder,\n    testCaseAttempt,\n    supportCodeLibrary,\n  })\n  const lines = formattedTestCaseAttempt.split('\\n')\n  const updatedLines = lines.map((line, index) => {\n    if (index === 0) {\n      return `${prefix}${line}`\n    }\n    return indentString(line, prefix.length)\n  })\n  return updatedLines.join('\\n')\n}\n\nexport function formatUndefinedParameterTypes(\n  undefinedParameterTypes: messages.UndefinedParameterType[]\n): string {\n  const output = [`Undefined parameter types:\\n\\n`]\n  const withLatest: Record<string, messages.UndefinedParameterType> = {}\n  undefinedParameterTypes.forEach((parameterType) => {\n    withLatest[parameterType.name] = parameterType\n  })\n  output.push(\n    Object.values(withLatest)\n      .map(\n        (parameterType) => `- ${formatUndefinedParameterType(parameterType)}`\n      )\n      .join('\\n')\n  )\n  output.push('\\n\\n')\n  return output.join('')\n}\n\nexport function formatUndefinedParameterType(\n  parameterType: messages.UndefinedParameterType\n): string {\n  return `\"${parameterType.name}\" e.g. \\`${parameterType.expression}\\``\n}\n"]}