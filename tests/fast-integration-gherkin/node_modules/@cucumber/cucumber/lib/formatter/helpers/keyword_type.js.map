{"version":3,"file":"keyword_type.js","sourceRoot":"","sources":["../../../src/formatter/helpers/keyword_type.ts"],"names":[],"mappings":";;;;;;AAAA,oDAAsB;AACtB,+CAAqD;AACrD,uDAAmD;AAEnD,IAAY,WAIX;AAJD,WAAY,WAAW;IACrB,4CAA6B,CAAA;IAC7B,8BAAe,CAAA;IACf,kCAAmB,CAAA;AACrB,CAAC,EAJW,WAAW,GAAX,mBAAW,KAAX,mBAAW,QAItB;AAQD,SAAgB,kBAAkB,CAAC,EACjC,OAAO,EACP,QAAQ,EACR,mBAAmB,GACQ;IAC3B,MAAM,OAAO,GAAY,kBAAQ,CAAC,QAAQ,CAAC,CAAA;IAC3C,MAAM,YAAY,GAAG,CAAC,OAAO,EAAE,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,KAAK,CAAU,CAAA;IACrE,MAAM,IAAI,GAAG,gBAAC,CAAC,IAAI,CAAC,YAAY,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,gBAAC,CAAC,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE,OAAO,CAAC,CAAC,CAAA;IAC7E,QAAQ,IAAI,EAAE;QACZ,KAAK,MAAM;YACT,OAAO,WAAW,CAAC,KAAK,CAAA;QAC1B,KAAK,MAAM;YACT,OAAO,WAAW,CAAC,OAAO,CAAA;QAC5B,KAAK,KAAK,CAAC;QACX,KAAK,KAAK;YACR,IAAI,6BAAa,CAAC,mBAAmB,CAAC,EAAE;gBACtC,OAAO,mBAAmB,CAAA;aAC3B;QACH,cAAc;QACd;YACE,OAAO,WAAW,CAAC,YAAY,CAAA;KAClC;AACH,CAAC;AAtBD,gDAsBC","sourcesContent":["import _ from 'lodash'\nimport { Dialect, dialects } from '@cucumber/gherkin'\nimport { doesHaveValue } from '../../value_checker'\n\nexport enum KeywordType {\n  Precondition = 'precondition',\n  Event = 'event',\n  Outcome = 'outcome',\n}\n\nexport interface IGetStepKeywordTypeOptions {\n  keyword: string\n  language: string\n  previousKeywordType?: KeywordType\n}\n\nexport function getStepKeywordType({\n  keyword,\n  language,\n  previousKeywordType,\n}: IGetStepKeywordTypeOptions): KeywordType {\n  const dialect: Dialect = dialects[language]\n  const stepKeywords = ['given', 'when', 'then', 'and', 'but'] as const\n  const type = _.find(stepKeywords, (key) => _.includes(dialect[key], keyword))\n  switch (type) {\n    case 'when':\n      return KeywordType.Event\n    case 'then':\n      return KeywordType.Outcome\n    case 'and':\n    case 'but':\n      if (doesHaveValue(previousKeywordType)) {\n        return previousKeywordType\n      }\n    // fallthrough\n    default:\n      return KeywordType.Precondition\n  }\n}\n"]}