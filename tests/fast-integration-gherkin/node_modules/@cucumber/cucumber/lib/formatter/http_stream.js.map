{"version":3,"file":"http_stream.js","sourceRoot":"","sources":["../../src/formatter/http_stream.ts"],"names":[],"mappings":"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","sourcesContent":["import { pipeline, Transform, Writable } from 'stream'\nimport tmp from 'tmp'\nimport fs from 'fs'\nimport http from 'http'\nimport https from 'https'\nimport { doesHaveValue } from '../value_checker'\n\ntype HttpMethod = 'GET' | 'POST' | 'PUT'\n\n/**\n * This Writable writes data to a HTTP/HTTPS URL.\n *\n * It has special handling for https://reports.cucumber.io/\n * which uses an API where the first request is a `GET`,\n * and if the response is 202 with a Location header, issues\n * a PUT request to that URL.\n *\n * 3xx redirects are not currently followed.\n */\nexport default class HttpStream extends Transform {\n  private tempFilePath: string\n  private tempFile: Writable\n\n  constructor(\n    private readonly url: string,\n    private readonly method: HttpMethod,\n    private readonly headers: http.OutgoingHttpHeaders\n  ) {\n    super({\n      readableObjectMode: true,\n    })\n  }\n\n  _write(\n    chunk: any,\n    encoding: BufferEncoding,\n    callback: (err?: Error | null) => void\n  ): void {\n    if (this.tempFile === undefined) {\n      tmp.file((err, name, fd) => {\n        if (doesHaveValue(err)) return callback(err)\n        this.tempFilePath = name\n        this.tempFile = fs.createWriteStream(name, { fd })\n        this.tempFile.write(chunk, encoding, callback)\n      })\n    } else {\n      this.tempFile.write(chunk, encoding, callback)\n    }\n  }\n\n  _final(callback: (error?: Error | null) => void): void {\n    this.tempFile.end(() => {\n      this.sendHttpRequest(\n        this.url,\n        this.method,\n        this.headers,\n        (err1, res1) => {\n          if (doesHaveValue(err1)) return callback(err1)\n          this.pushResponseBody(res1, () => {\n            this.emitErrorUnlessHttp2xx(res1, this.url, this.method)\n            if (\n              res1.statusCode === 202 &&\n              res1.headers.location !== undefined\n            ) {\n              this.sendHttpRequest(\n                res1.headers.location,\n                'PUT',\n                {},\n                (err2, res2) => {\n                  if (doesHaveValue(err2)) return callback(err2)\n                  this.emitErrorUnlessHttp2xx(res2, this.url, this.method)\n                  callback()\n                }\n              )\n            } else {\n              callback()\n            }\n          })\n        }\n      )\n    })\n  }\n\n  private pushResponseBody(res: http.IncomingMessage, done: () => void): void {\n    let body = Buffer.alloc(0)\n    res.on('data', (chunk) => {\n      body = Buffer.concat([body, chunk])\n    })\n    res.on('end', () => {\n      this.push(body.toString('utf-8'))\n      done()\n    })\n  }\n\n  private emitErrorUnlessHttp2xx(\n    res: http.IncomingMessage,\n    url: string,\n    method: string\n  ): void {\n    if (res.statusCode >= 300)\n      this.emit(\n        'error',\n        new Error(\n          `Unexpected http status ${res.statusCode} from ${method} ${url}`\n        )\n      )\n  }\n\n  private sendHttpRequest(\n    url: string,\n    method: HttpMethod,\n    headers: http.OutgoingHttpHeaders,\n    callback: (err?: Error | null, res?: http.IncomingMessage) => void\n  ): void {\n    const httpx = doesHaveValue(url.match(/^https:/)) ? https : http\n    const additionalHttpHeaders: http.OutgoingHttpHeaders = {}\n\n    const upload = method === 'PUT' || method === 'POST'\n    if (upload) {\n      additionalHttpHeaders['Content-Length'] = fs.statSync(\n        this.tempFilePath\n      ).size\n    }\n\n    const allHeaders = { ...headers, ...additionalHttpHeaders }\n    const req = httpx.request(url, {\n      method,\n      headers: allHeaders,\n    })\n    req.on('error', (err) => this.emit('error', err))\n    req.on('response', (res) => {\n      res.on('error', (err) => this.emit('error', err))\n      callback(null, res)\n    })\n\n    if (upload) {\n      pipeline(fs.createReadStream(this.tempFilePath), req, (err) => {\n        if (doesHaveValue(err)) {\n          this.emit('error', err)\n        }\n      })\n    } else {\n      req.end()\n    }\n  }\n}\n"]}