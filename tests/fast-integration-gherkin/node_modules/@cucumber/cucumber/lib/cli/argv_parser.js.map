{"version":3,"file":"argv_parser.js","sourceRoot":"","sources":["../../src/cli/argv_parser.ts"],"names":[],"mappings":"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","sourcesContent":["import _ from 'lodash'\nimport { Command } from 'commander'\nimport path from 'path'\nimport { dialects } from '@cucumber/gherkin'\nimport { SnippetInterface } from '../formatter/step_definition_snippet_builder/snippet_syntax'\n\n// Using require instead of import so compiled typescript will have the desired folder structure\nconst { version } = require('../../package.json') // eslint-disable-line @typescript-eslint/no-var-requires\n\nexport interface IParsedArgvFormatRerunOptions {\n  separator?: string\n}\n\nexport interface IParsedArgvFormatOptions {\n  colorsEnabled?: boolean\n  rerun?: IParsedArgvFormatRerunOptions\n  snippetInterface?: SnippetInterface\n  snippetSyntax?: string\n  [customKey: string]: any\n}\n\nexport interface IParsedArgvOptions {\n  backtrace: boolean\n  dryRun: boolean\n  exit: boolean\n  failFast: boolean\n  format: string[]\n  formatOptions: IParsedArgvFormatOptions\n  i18nKeywords: string\n  i18nLanguages: boolean\n  language: string\n  name: string[]\n  order: string\n  parallel: number\n  predictableIds: boolean\n  profile: string[]\n  publish: boolean\n  publishQuiet: boolean\n  require: string[]\n  requireModule: string[]\n  retry: number\n  retryTagFilter: string\n  strict: boolean\n  tags: string\n  worldParameters: object\n}\n\nexport interface IParsedArgv {\n  args: string[]\n  options: IParsedArgvOptions\n}\n\nconst ArgvParser = {\n  collect<T>(val: T, memo: T[]): T[] {\n    memo.push(val)\n    return memo\n  },\n\n  mergeJson(option: string): (str: string, memo: object) => object {\n    return function (str: string, memo: object) {\n      let val: object\n      try {\n        val = JSON.parse(str)\n      } catch (error) {\n        const e: Error = error\n        throw new Error(`${option} passed invalid JSON: ${e.message}: ${str}`)\n      }\n      if (!_.isPlainObject(val)) {\n        throw new Error(`${option} must be passed JSON of an object: ${str}`)\n      }\n      return _.merge(memo, val)\n    }\n  },\n\n  mergeTags(value: string, memo: string): string {\n    return memo === '' ? `(${value})` : `${memo} and (${value})`\n  },\n\n  validateCountOption(value: string, optionName: string): number {\n    const numericValue = parseInt(value)\n    if (isNaN(numericValue) || numericValue < 0) {\n      throw new Error(`${optionName} must be a non negative integer`)\n    }\n    return numericValue\n  },\n\n  validateLanguage(value: string): string {\n    if (!_.includes(_.keys(dialects), value)) {\n      throw new Error(`Unsupported ISO 639-1: ${value}`)\n    }\n    return value\n  },\n\n  validateRetryOptions(options: IParsedArgvOptions): void {\n    if (options.retryTagFilter !== '' && options.retry === 0) {\n      throw new Error(\n        'a positive --retry count must be specified when setting --retry-tag-filter'\n      )\n    }\n  },\n\n  parse(argv: string[]): IParsedArgv {\n    const program = new Command(path.basename(argv[1]))\n\n    program\n      .storeOptionsAsProperties(false)\n      .usage('[options] [<GLOB|DIR|FILE[:LINE]>...]')\n      .version(version, '-v, --version')\n      .option('-b, --backtrace', 'show full backtrace for errors')\n      .option(\n        '-d, --dry-run',\n        'invoke formatters without executing steps',\n        false\n      )\n      .option(\n        '--exit',\n        'force shutdown of the event loop when the test run has finished: cucumber will call process.exit',\n        false\n      )\n      .option('--fail-fast', 'abort the run on first failure', false)\n      .option(\n        '-f, --format <TYPE[:PATH]>',\n        'specify the output format, optionally supply PATH to redirect formatter output (repeatable)',\n        ArgvParser.collect,\n        []\n      )\n      .option(\n        '--format-options <JSON>',\n        'provide options for formatters (repeatable)',\n        ArgvParser.mergeJson('--format-options'),\n        {}\n      )\n      .option(\n        '--i18n-keywords <ISO 639-1>',\n        'list language keywords',\n        ArgvParser.validateLanguage,\n        ''\n      )\n      .option('--i18n-languages', 'list languages', false)\n      .option(\n        '--language <ISO 639-1>',\n        'provide the default language for feature files',\n        'en'\n      )\n      .option(\n        '--name <REGEXP>',\n        'only execute the scenarios with name matching the expression (repeatable)',\n        ArgvParser.collect,\n        []\n      )\n      .option('--no-strict', 'succeed even if there are pending steps')\n      .option(\n        '--order <TYPE[:SEED]>',\n        'run scenarios in the specified order. Type should be `defined` or `random`',\n        'defined'\n      )\n      .option(\n        '-p, --profile <NAME>',\n        'specify the profile to use (repeatable)',\n        ArgvParser.collect,\n        []\n      )\n      .option(\n        '--parallel <NUMBER_OF_WORKERS>',\n        'run in parallel with the given number of workers',\n        (val) => ArgvParser.validateCountOption(val, '--parallel'),\n        0\n      )\n      .option(\n        '--predictable-ids',\n        'Use predictable ids in messages (option ignored if using parallel)',\n        false\n      )\n      .option(\n        '--publish',\n        'Publish a report to https://reports.cucumber.io',\n        false\n      )\n      .option(\n        '--publish-quiet',\n        \"Don't print information banner about publishing reports\",\n        false\n      )\n      .option(\n        '-r, --require <GLOB|DIR|FILE>',\n        'require files before executing features (repeatable)',\n        ArgvParser.collect,\n        []\n      )\n      .option(\n        '--require-module <NODE_MODULE>',\n        'require node modules before requiring files (repeatable)',\n        ArgvParser.collect,\n        []\n      )\n      .option(\n        '--retry <NUMBER_OF_RETRIES>',\n        'specify the number of times to retry failing test cases (default: 0)',\n        (val) => ArgvParser.validateCountOption(val, '--retry'),\n        0\n      )\n      .option(\n        '--retryTagFilter, --retry-tag-filter <EXPRESSION>',\n        `only retries the features or scenarios with tags matching the expression (repeatable).\n        This option requires '--retry' to be specified.`,\n        ArgvParser.mergeTags,\n        ''\n      )\n      .option(\n        '-t, --tags <EXPRESSION>',\n        'only execute the features or scenarios with tags matching the expression (repeatable)',\n        ArgvParser.mergeTags,\n        ''\n      )\n      .option(\n        '--world-parameters <JSON>',\n        'provide parameters that will be passed to the world constructor (repeatable)',\n        ArgvParser.mergeJson('--world-parameters'),\n        {}\n      )\n\n    program.on('--help', () => {\n      /* eslint-disable no-console */\n      console.log(\n        '  For more details please visit https://github.com/cucumber/cucumber-js/blob/master/docs/cli.md\\n'\n      )\n      /* eslint-enable no-console */\n    })\n\n    program.parse(argv)\n    const options = program.opts() as IParsedArgvOptions\n    ArgvParser.validateRetryOptions(options)\n\n    return {\n      options,\n      args: program.args,\n    }\n  },\n\n  lint(fullArgv: string[]): void {\n    if (fullArgv.includes('--retryTagFilter')) {\n      console.warn(\n        'the argument --retryTagFilter is deprecated and will be removed in a future release; please use --retry-tag-filter'\n      )\n    }\n  },\n}\n\nexport default ArgvParser\n"]}