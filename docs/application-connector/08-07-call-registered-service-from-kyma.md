---
title: Call a registered external service from Kyma
type: Tutorials
---

This guide shows how to call a registered external service from Kyma using a simple Function.

## Prerequisites

- An Application bound to a Namespace.
- Client certificates generated for the connected Application.
- Local development only: Map `my-function-production.kyma.local` to your Minikube IP to call the Function on a local Kyma deployment.

## Steps

1. Register a service with the following specification to the desired Application.

   > **NOTE:** See the [tutorial](#tutorials-register-a-service) to learn how to register a service.

   ```json
   {
     "name": "my-service",
     "provider": "myCompany",
     "Identifier": "identifier",
     "description": "This is some service",
     "api": {
       "targetUrl": "http://httpbin.org/",
       "spec": {
         "swagger":"2.0"
       }
     }
   }
   ```
    
   A successful response returns the ID of the registered service:

   ```json
   {"id":"{YOUR_SERVICE_ID}"}
   ```

2. Export the ID of the registered service, the Namespace to which you bound your Application, and the name of your Application.
   
   ```bash
   export SERVICE_ID={YOUR_SERVICE_ID}
   export NAMESPACE={YOUR_NAMESPACE}
   export APP_NAME={YOUR_APPLICATION_NAME}
   ```

3. Get and expose the `externalName` of the Service Class of the registered service.

   ```bash
   export EXTERNAL_NAME=$(kubectl -n $NAMESPACE get serviceclass $SERVICE_ID  -o jsonpath='{.spec.externalName}')
   ```

4. Create a Service Instance for the registered service.

   ```bash
   cat <<EOF | kubectl apply -f -
   apiVersion: servicecatalog.k8s.io/v1beta1
   kind: ServiceInstance
   metadata:
     name: my-service-instance-name
     namespace: $NAMESPACE
   spec:
     serviceClassExternalName: $EXTERNAL_NAME
   EOF
   ```

5. Create a Function that sends a request to the registered service with an additional path of `/uuid`. A successful response returns a UUID generated by `httpbin.org`. To create and register the Function in the desired Namespace, run:

   ```bash
   cat <<EOF | kubectl apply -f -
   apiVersion: serverless.kyma-project.io/v1alpha1
   kind: Function
   metadata:
     name: my-function
     namespace: $NAMESPACE
     labels:
       app: my-function
       $APP_NAME-$SERVICE_ID: "true"
   spec:
     deps: |-
       {
           "name": "example-1",
           "version": "0.0.1",
           "dependencies": {
             "request": "^2.85.0"
           }
       }
     source: |-
       const request = require('request');

       module.exports = { main: function (event, context) {
           return new Promise((resolve, reject) => {
               const url = \`http://\${process.env.GATEWAY_URL}/uuid\`;
               const options = {
                   url: url,
               };

               sendReq(url, resolve, reject)
           })
       } }

       function sendReq(url, resolve, reject) {
           request.get(url, { json: true }, (error, response, body) => {
               if(error){
                   resolve(error);
               }
               resolve(response.body);
           })
       }
     env:
     - name: GATEWAY_URL
       value: $APP_NAME-$SERVICE_ID.kyma-integration
   EOF
   ```

6. Create a ServiceBinding and a ServiceBindingUsage to bind the Service Instance to the Function.

   ```bash
   cat <<EOF | kubectl apply -f -
   apiVersion: servicecatalog.k8s.io/v1beta1
   kind: ServiceBinding
   metadata:
     labels:
       function: my-function
     name: my-service-binding
     namespace: $NAMESPACE
   spec:
     instanceRef:
       name: my-service-instance-name
   EOF
   ```

   ```bash
   cat <<EOF | kubectl apply -f -
   apiVersion: servicecatalog.kyma-project.io/v1alpha1
   kind: ServiceBindingUsage
   metadata:
     labels:
       function: my-function
       serviceBinding: my-service-binding
     name: my-service-binding
     namespace: $NAMESPACE
   spec:
     serviceBindingRef:
       name: my-service-binding
     usedBy:
       kind: function
       name: my-function
   EOF
   ```

7. To expose the Function outside the cluster create an APIRule custom resource.

   ```bash
   cat <<EOF | kubectl apply -f -
   apiVersion: gateway.kyma-project.io/v1alpha1
   kind: APIRule
   metadata:
     name: my-function
     namespace: $NAMESPACE
     labels:
       function: my-function
   spec:
     gateway: kyma-gateway.kyma-system.svc.cluster.local
     rules:
     - path: /.*
       accessStrategies:
       - config: {}
         handler: noop
       methods:
       - GET
     service:
       host: my-function-$NAMESPACE.{CLUSTER_DOMAIN}
       name: my-function
       port: 80
   EOF
   ```

8. To verify that everything was set up correctly you can now call the Function through HTTPS:

    <div tabs name="service-check-call" group="check-call">
      <details>
      <summary label="cluster">
      On a cluster
      </summary>
    
      ```bash
      curl https://my-function-$NAMESPACE.{CLUSTER_DOMAIN}/ -k
      ```
    
      </details>
      <details>
      <summary label="local">
      On a local deployment
      </summary>
    
      ```bash
      curl https://my-function-$NAMESPACE.kyma.local/ -k
      ```
    
      </details>
    </div> 

       
   A successful response returns a UUID generated by `httpbin.org`:
      
   ```json
   {
     "uuid": "d44cc373-b26e-4a36-9890-6418d131a285"
   }
   ```
