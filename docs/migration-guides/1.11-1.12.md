# Migrate from v1.11 to v1.12

## API Gateway

Migration from Api to APIRule custom resources (CRs) is performed automatically by a job that runs during the Kyma upgrade. During this process, the [API Gateway Migrator tool](https://github.com/kyma-project/kyma/blob/master/components/api-gateway-migrator/README.md#api-gateway-migrator) translates the existing Api CRs to APIRule CRs and deletes the original resources.

Before starting the migration process, ensure that all Api resources have a status. To do so, fetch all Apis without the status:

```shell script
kubectl get apis --all-namespaces -o json | jq '.items | .[] | select(.status == null)'
```

Receiving no results means that you can perform the upgrade. If, however, you can see any Api resources in the output, recreate each Api using this script:

```shell script
# set variables
export API_NAME={INSERT_API_NAME_HERE}
export API_NAMESPACE={INSERT_API_NAMESPACE_HERE}
# remove dependent resources
kubectl delete virtualservice -n ${API_NAMESPACE} ${API_NAME}
kubectl delete policy -n ${API_NAMESPACE} ${API_NAME} --ignore-not-found
# recreate Api
kubectl get api -n ${API_NAMESPACE} ${API_NAME} -o yaml | kubectl replace --force -f -
```

Once the Apis are recreated check again if all of them have a status. The output should not include any Api resources.

>**CAUTION:** Migrating resources may result in a temporary downtime of the exposed service. 

During migration, it may turn out that some resource specifications are too complex or fail to meet all the migration requirements. In such a case the process skips them but doesn't break the way existing services are exposed. However, if you want to introduce further changes or remove the Api CR, your actions won't have any effect on how the service is exposed because it will still use the original configuration.  

>**NOTE:** If the migration process skipped the Api resources due to the invalid status or a blacklisted label, migration is not possible.

Here are the steps you need to follow to ensure your services are properly migrated:

1. [Verify the migration](https://github.com/kyma-project/kyma/blob/1.12/docs/api-gateway/03-04-migration.md#verify-the-automatic-migration). 
2. If you can still see any Api CRs in use, use the [manual migration](https://github.com/kyma-project/kyma/blob/1.12/docs/api-gateway/03-04-migration.md#manual-migration) guide to migrate them.

## Serverless

Lambdas (Functions) created in previous releases won't work anymore because their underlying component, Kubeless, was removed. Migration from the previous solution to the new one requires manual steps - because of the complexity of Kubeless configuration, it was not possible to migrate the functions automatically.

Follow these sections and steps to migrate your existing Kubeless-based Functions to the new KService-based ones.

>**TIP:** All examples in this section provide references to the corresponding fields from the deprecated resources. For example, `source: {spec.function}` means that you must enter the value from the **spec.function** field of the deprecated Function in the **spec.source** field of the new Function:
> ```bash
> spec:
>   ...
>   source: {spec.function}
> ```

### Migrate functions.kubeless.io to functions.serverless.kyma-project.io

1. Export these values as environment variables:

    ```bash
    # The name of your deprecated Kubeless Function:
    export FUNCTION_NAME={FUNCTION_NAME}
    
    # The Namespace in which your depracated Function was created:
    export NAMESPACE={FUNCTION_NAMESPACE}
    ```

2. Remove the **metadata.finalizers** field. To do that, edit the deprecated Function:

    ```bash
    kubectl patch functions.kubeless.io ${FUNCTION_NAME} -n ${NAMESPACE} --type=merge -p '{"metadata":{"finalizers":null}}'
    ```

3. Copy the Function to this file for reference:

    ```bash
    kubectl get functions.kubeless.io ${FUNCTION_NAME} -n ${NAMESPACE} -o yaml > function.yaml
    ```

4. Delete the Function from the cluster:

    ```bash
    kubectl delete functions.kubeless.io ${FUNCTION_NAME} -n ${NAMESPACE}
    ```

5. Create a new Function based on values from the deprecated Function (`function.yaml`):

    >**CAUTION:** Don't copy the **annotations** field.

    >**CAUTION:** If the deprecated Function has more containers or its configuration is different, it needs to be adjusted to the new Function CR. There is currently no support for defining multiple containers.

    ```bash
    cat <<EOF | kubectl apply -f  -
    apiVersion: serverless.kyma-project.io/v1alpha1
    kind: Function
    metadata:
      name: ${FUNCTION_NAME}
      namespace: ${NAMESPACE}
      labels: {metadata.labels}
    spec:
      minReplicas: {spec.horizontalPodAutoscaler.spec.minReplicas}
      maxReplicas: {spec.horizontalPodAutoscaler.spec.maxReplicas}
      env: {spec.deployment.spec.template.spec.containers.env}
      resources: {spec.deployment.spec.template.spec.containers.resources}
      source: {spec.function}
      deps: {spec.deps}
    EOF
    ```

5. Wait until the Function is running:

    ```bash
    kubectl get functions.serverless.kyma-project.io ${FUNCTION_NAME} -n ${NAMESPACE}
    ```

### Migrate Triggers assigned to the deprecated Function

1. Get the UID of the new Function:

    ```bash
    export FUNCTION_UID=$(kubectl get functions.serverless.kyma-project.io ${FUNCTION_NAME} -o jsonpath='{.metadata.uid}' -n ${NAMESPACE})
    ```

2. Edit the Subscriber and add the Owner Reference.

    ```bash
    for trigger in $(kubectl get triggers.eventing.knative.dev -l Function=${FUNCTION_NAME} -n ${NAMESPACE} -o jsonpath='{.items[*].metadata.name}'); do
        # Change the Subscriber to the new Function
        kubectl patch triggers.eventing.knative.dev ${trigger} -n ${NAMESPACE} --type=merge -p '{"spec":{"subscriber":{"uri":null,"ref":{"apiVersion":"serving.knative.dev/v1","kind":"Service","name":"'${FUNCTION_NAME}'","namespace":"'${NAMESPACE}'"}}}}'
    
        # Update the Owner Reference
        kubectl patch triggers.eventing.knative.dev ${trigger} -n ${NAMESPACE} --type=merge -p '{"metadata":{"ownerReferences":[{"apiVersion":"serving.knative.dev/v1","kind":"Service","name":"'${FUNCTION_NAME}'","uid":"'${FUNCTION_UID}'"}]}}'
    done
    ```

3. Check if Triggers are ready:

    ```bash
    kubectl get triggers.eventing.knative.dev -l Function=${FUNCTION_NAME} -n ${NAMESPACE}
    ```

### Migrate the ServiceBindingUsage that binds the Service to the Function

1. Check if the new Function is running:

    ```bash
    kubectl get functions.serverless.kyma-project.io ${FUNCTION_NAME} -n ${NAMESPACE}
    ```

2. Update the **spec.usedBy.kind** field:

    ```bash
    for binding in $(kubectl get servicebindingusages.servicecatalog.kyma-project.io -l Function=${FUNCTION_NAME} -n ${NAMESPACE} -o jsonpath='{.items[*].metadata.name}'); do
        # Set spec.usedBy.kind to knative-service
        kubectl patch servicebindingusages.servicecatalog.kyma-project.io ${binding} -n ${NAMESPACE} --type=merge -p '{"spec":{"usedBy":{"kind":"knative-service"}}}'
    done
    ```

3. Check if ServiceBindingUsages are ready:

    ```bash
    kubectl get servicebindingusages.servicecatalog.kyma-project.io -l Function=${FUNCTION_NAME} -n ${NAMESPACE} -o jsonpath='{range .items[*]}{"Name: "}{.metadata.name}{"\tReady: "}{.status.conditions[?(@.type=="Ready")].status}{end}'
    ```

### Migrate the APIRule that exposes the Function

1. Edit the **spec.service.port** field in the API Rule:

    ```bash
    for api in $(kubectl get apirules.gateway.kyma-project.io -n ${NAMESPACE} -o jsonpath="{.items[?(@.spec.service.name=='${FUNCTION_NAME}')].metadata.name}"); do
        # Set spec.service.port to 80
        kubectl patch apirules.gateway.kyma-project.io ${api} -n ${NAMESPACE} --type=merge -p '{"spec":{"service":{"port":80}}}'
    done
    ```

2. Change the value of the **spec.rules.accessStrategies.handler** field from `allow` to `noop`.

    a. List Handlers for APIRules that expose the Function:

    ```bash
    kubectl get apirules.gateway.kyma-project.io -n ${NAMESPACE} -o jsonpath='{range .items[?(@.spec.service.name=="'${FUNCTION_NAME}'")]}{"Name: "}{.metadata.name}{"\tHandlers: "}{.spec.rules[*].accessStrategies[*].handler}{"\n"}{end}'
    ```

    b. If the Handlers contain the `allow` value, change it to `noop` in the **spec.rules.accessStrategies.handler** field:

    ```bash
    kubectl edit apirules.gateway.kyma-project.io {API_RULE_NAME} -n ${NAMESPACE}
    ```
