# Migrate from v1.11 to v1.12

## API Gateway

Migration from Api to APIRule custom resources (CRs) is performed automatically by a job that runs during the Kyma upgrade. During this process, the [API Gateway Migrator tool](https://github.com/kyma-project/kyma/blob/master/components/api-gateway-migrator/README.md#api-gateway-migrator) translates the existing Api CRs to APIRule CRs and deletes the original resources.

Before starting the migration process, ensure that all Api resources have a status. To do so, fetch all Apis without the status:

```shell script
kubectl get apis --all-namespaces -o json | jq '.items | .[] | select(.status == null)'
```

Receiving no results means that you can perform the upgrade. If, however, you can see any Api resources in the output, recreate each Api using this script:

```shell script
# set variables
export API_NAME={INSERT_API_NAME_HERE}
export API_NAMESPACE={INSERT_API_NAMESPACE_HERE}
# remove dependent resources
kubectl delete virtualservice -n ${API_NAMESPACE} ${API_NAME}
kubectl delete policy -n ${API_NAMESPACE} ${API_NAME} --ignore-not-found
# recreate Api
kubectl get api -n ${API_NAMESPACE} ${API_NAME} -o yaml | kubectl replace --force -f -
```

Once the Apis are recreated check again if all of them have a status. The output should not include any Api resources.

>**CAUTION:** Migrating resources may result in a temporary downtime of the exposed service. 

During migration, it may turn out that some resource specifications are too complex or fail to meet all the migration requirements. In such a case the process skips them but doesn't break the way existing services are exposed. However, if you want to introduce further changes or remove the Api CR, your actions won't have any effect on how the service is exposed because it will still use the original configuration.  

>**NOTE:** If the migration process skipped the Api resources due to the invalid status or a blacklisted label, migration is not possible.

Here are the steps you need to follow to ensure your services are properly migrated:

1. [Verify the migration](https://github.com/kyma-project/kyma/blob/1.12/docs/api-gateway/03-04-migration.md#verify-the-automatic-migration). 
2. If you can still see any Api CRs in use, use the [manual migration](https://github.com/kyma-project/kyma/blob/1.12/docs/api-gateway/03-04-migration.md#manual-migration) guide to migrate them.

## Serverless

Old Lambdas created in previous releases don't work anymore, because the underhood component - Kubeless - was removed. Migration from old old solution to the new one requires manual steps, because Kubeless provides plenty of avaliable configuration, so it was not possible to migrate it automatically.

### Migrate functions.kubeless.io to functions.serverless.kyma-project.io

1. First thing that you need to do is removing `kubeless.io/function` from `metadata.finalizers` field, to do that you need to edit your old function.

    ```bash
    kubectl edit functions.kubeless.io {NAME} -n {NAMESPACE}
    ```

2. Copy old function to file for referencing

    ```bash
    kubectl get functions.kubeless.io {NAME} -n {NAMESPACE} -o yaml > function.yaml
    ```

3. Delete old function from cluster

    ```bash
    kubectl delete functions.kubeless.io {NAME} -n {NAMESPACE} -o yaml > function.yaml
    ```

4. Create new function based on values from old function

    ```bash
    cat <<EOF | kubectl apply -f  -
    apiVersion: serverless.kyma-project.io/v1alpha1
    kind: Function
    metadata:
      name: {NAME}
      namespace: {NAMESPACE}
      labels: {metadata.labels}
    spec:
      minReplicas: {spec.horizontalPodAutoscaler.spec.minReplicas}
      maxReplicas: {spec.horizontalPodAutoscaler.spec.maxReplicas}
      env: {spec.deployment.spec.template.spec.containers.env}
      resources: {spec.deployment.spec.template.spec.containers.resources}
      source: {spec.function}
      deps: {spec.deps
    EOF
    ```

    >**CAUTION:** Don't copy annotation field.

5. Wait for function to be in the running condition

    ```bash
    kubectl get functions.serverless.kyma-project.io {NAME} -n {NAMESPACE}
    ```

### Migrate triggers assigned to old function to the new one

1. List all 

    ```bash
    kubectl get triggers.eventing.knative.dev -l Function={NAME} -n {NAMESPACE}
    ```

2. Get a new function UUID

    ```bash
    kubectl get functions.serverless.kyma-project.io {NAME} -o jsonpath='{.metadata.uid}' -n {NAMESPACE}
    ```

3. Edit subscriber field and add Owner Reference

    ```bash
    kubectl edit triggers.eventing.knative.dev {TRIGGER_NAME} -n {NAMESPACE}
    ```

    Change subscriber field to:

    ```yaml
    spec:
      subscriber:
        ref:
          apiVersion: serving.knative.dev/v1
          kind: Service
          name: {NAME}
          namespace: {NAMESPACE}
    ```

    Add Owner Reference

    ```yaml
    metadata:
      ownerReferences:
      - apiVersion: serving.knative.dev/v1
        kind: Service
        name: {NAME}
        uid: {FUNCTION_UUID}
    ```

4. Check if trigger is ready

    ```bash
    kubectl get triggers.eventing.knative.dev {TRIGGER_NAME} -n {NAMESPACE}
    ```

### Migrate APIRule that exposes Function

1. Find APIRule that name starts with Function name

    To list APIRules in namespaces use:

    ```bash
    kubectl get apirules.gateway.kyma-project.io -n {NAMESPACE} | grep {NAME}-
    ```

    Then check which API Rule points to service with name same as function, field `spec.service.name`

2. Edit handler and service fields

    ```bash
    kubectl edit apirules.gateway.kyma-project.io {API_NAME} -n {NAMESPACE}
    ```

    If `spec.rules.accessStrategies.handler` value is `allow` then change it to `noop`.

    Change `spec.service.port` field value to `80`

### Migrate Service Binding Usage that binds Service to Function

1. Check if new Function has Running condition

    ```bash
    kubectl get functions.serverless.kyma-project.io {NAME} -n {NAMESPACE}
    ```

2. List Service Bindings Usages assigned to old Function

    ```bash
    kubectl get servicebindingusages.servicecatalog.kyma-project.io -l Function={NAME} -n {NAMESPACE}
    ```

3. Copy Service Binding Usage to file

    ```bash
    kubectl get servicebindingusages.servicecatalog.kyma-project.io {BINDING_NAME} -n {NAMESPACE} -o yaml > binding.yaml
    ```

4. Delete old Service Binding Usage

    ```bash
    kubectl delete servicebindingusages.servicecatalog.kyma-project.io {BINDING_NAME} -n {NAMESPACE}
    ```

5. Create new Service Binding Usage basing on values from old

    ```bash
    cat <<EOF | kubectl create -f  -
    apiVersion: servicecatalog.kyma-project.io/v1alpha1
    kind: ServiceBindingUsage
    metadata:
      labels: {metadata.labels}
      generateName: {FUNCTION_NAME}-
      namespace: {NAMESPACE}
      ownerReferences: {metadata.ownerReferences}
    spec:
      parameters: {spec.parameters}
      reprocessRequest: {spec.reprocessRequest}
      serviceBindingRef: {spec.serviceBindingRef}
      usedBy:
        kind: knative-service
        name: {FUNCTION_NAME}
    EOF
    ```
