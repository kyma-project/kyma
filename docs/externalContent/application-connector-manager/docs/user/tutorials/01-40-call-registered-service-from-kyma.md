# Call a Registered External Service from Kyma

This guide shows how to call a registered external service from Kyma using a simple Function.

## Prerequisites

- A [registered external service](01-20-register-manage-services.md)
- Your [service display name exported](01-20-register-manage-services.md#prerequisites) as an environment variable
- Your [Application name exported](01-10-create-application.md#prerequisites) as an environment variable
- Your desired namespace, cluster domain, and the names for your Function and APIRule exported as environment variables

  ```bash
  export NAMESPACE=default
  export CLUSTER_DOMAIN=local.kyma.dev
  export FUNCTION_NAME=my-function
  export APIRULE_NAME=$FUNCTION_NAME-ar
  ```

- [Istio sidecar injection](https://kyma-project.io/#/istio/user/tutorials/01-40-enable-sidecar-injection) enabled in your namespace

  ```bash
  kubectl label namespace $NAMESPACE istio-injection=enabled
  ```

> [!WARNING]
> On a local Kyma deployment, skip SSL certificate verification when making a `curl` call, by adding the `-k` flag to it. Alternatively, add the Kyma certificates to your local certificate storage on your machine using the `kyma import certs` command.

## Steps

1. Build a path to access your registered service:

   ```bash
   export GATEWAY_URL=http://central-application-gateway.kyma-system:8080/$APP_NAME/$SERVICE_DISPLAY_NAME
   ```

   > [!WARNING]
   > `SERVICE_DISPLAY_NAME` in the **GATEWAY_URL** path must be in its [normalized form](01-30-register-secured-api.md#register-a-secured-api). This means that, for example, if you used `test-basic-auth` as the service **displayName**, you're good to go, but if you used `"Test Basic Auth"`, you must replace it with `test-basic-auth` in the path.

2. Create a Function that sends a request to the registered service with the additional path of `/uuid`. A successful response returns a UUID generated by `httpbin.org`. To create and register the Function in the desired namespace, run:

   ```bash
   cat <<EOF | kubectl apply -f -
   apiVersion: serverless.kyma-project.io/v1alpha2
   kind: Function
   metadata:
     name: $FUNCTION_NAME
     namespace: $NAMESPACE
     labels:
       app: $APP_NAME
   spec:
     runtime: nodejs18
     source:
       inline:
         source: |-
          const request = require('request');

          module.exports = { main: function (event, context) {
           return new Promise((resolve, reject) => {
               const url = process.env.GATEWAY_URL + "/uuid";
               const options = {
                   url: url,
               };

               sendReq(url, resolve, reject)
           })
          } }

          function sendReq(url, resolve, reject) {
           request.get(url, { json: true }, (error, response, body) => {
               if(error){
                   resolve(error);
               }
               resolve(response.body);
           })
          }
         dependencies: |-
          {
           "name": "example-1",
           "version": "0.0.1",
           "dependencies": {
             "request": "^2.85.0"
           }
          }
     env:
     - name: GATEWAY_URL
       value: $GATEWAY_URL
   EOF
   ```

3. To expose the Function outside the cluster, create an APIRule custom resource.

   ```bash
   cat <<EOF | kubectl apply -f -
   apiVersion: gateway.kyma-project.io/v1beta1
   kind: APIRule
   metadata:
     name: $APIRULE_NAME
     namespace: $NAMESPACE
     labels:
       function: $FUNCTION_NAME
   spec:
     gateway: kyma-system/kyma-gateway
     host: $APIRULE_NAME.$CLUSTER_DOMAIN
     rules:
     - path: /.*
       accessStrategies:
       - config: {}
         handler: noop
       methods:
       - GET
     service:
       name: $FUNCTION_NAME
       port: 80
   EOF
   ```

4. To verify that everything was set up correctly, you can now call the Function through HTTPS:

      ```bash
      curl https://$APIRULE_NAME.$CLUSTER_DOMAIN/
      ```

   > [!NOTE]
   > If you get nothing or `no healthy upstream` as a response, wait for a few moments for the Function to get ready and call it again.

   A successful response returns a UUID generated by `httpbin.org`:

   ```json
   {
     "uuid": "d44cc373-b26e-4a36-9890-6418d131a285"
   }
   ```
